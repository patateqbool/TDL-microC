----------------------------------------------------
-- Grammaires de MC  et MCS                       --
----------------------------------------------------

-- TODO : - lors de déclarations, on doit aussi vérifier dans talias.
--        - finir avec vi dans les expressions

-- TODO : changements pour permettres à deux fonctions n'ayant pas le meme
--        type de parametres de porter le meme nom.
--            - Appel de fonction
--            - Declaration

--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;

-- TODO : Verifier que les attributs sont bien def. (Dernier update: feuille rose complète, feuille blanche V1 (TO DO: modifs noires)

inh tvar : VariableTable for
         ENTITES, ENTITE, BLOC, F, INSTS, INST, SIX, E, AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX
         ;

syn tvarS : VariableTable for 
         PARFS, PARF, DECL, ENTITE, INST, INSTS
         ; -- Utilisée pour récupérer la TDS màj avec les paramètres de la fonction.

inh talias : AliasTable for 
         ENTITES, ENTITE, BLOC, STYPE, TYPE, F, INSTS, INST, SIX, CHAMP, E, AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX
         ; --Table des alias contenant les types propres au programme.


inh tfun : FunctionTable for
         ENTITES, ENTITE, BLOC, F, INSTS, INST, SIX, E, AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX
	 ;

syn tfunS : FunctionTable for 
         DECL, ENTITE, FONCTION
         ;

syn type : Type for
         TYPE, STYPE, PTRS, DECL, FONCTION, F, CHAMP, E, A, AFFX, AX, PARF
         ;
 
inh typeH : Type for
         PTRS, INSTS, INST, DECL, FONCTION, SIX, FX, AFFX
         ;

inh funInfoH : FunctionInfo for
         PARFS, PARFSX, BLOC, INSTS, INST, SIX
				 ;

syn funInfo : FunctionInfo for
         PARFS, PARFSX, FX
	       ;

-- Attribut servant à savoir du quantième paramètre il s'agit. 
inh cParam : int for
         PARFS, PARF, PARFSX
				 ;

inh nom : String for 
         DECL, FONCTION
				 ;

syn nomS : String for 
         CHAMP
				 ;

syn code : String for
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
				 ;

inh codeH : String for
				 ES, ESX
				 ;

syn op : Operator for
				 OPADD, OPMULT, OPUN, RX, TX
				 ;

syn oprel : RelationalOperator for
				 OPREL, AX
				 ;

syn reg : Register for
				 F, T, TX, RX, E, AFFX, A, AX
				 ;

syn estVar : boolean for
         R, RX, FX, T, TX, E, A, AFFX, AX
				 ;


inh estFun : boolean for
         FX
				 ;

inh affPossible : boolean for
         AFFX
         ;

inh listeDepl : DisplacementList for
				 FX
				 ;

syn listeDeplS : DisplacementList for
				 FX
				 ;

inh typeAttendus : List<Type> for
				 ES
				 ;

syn vi : VariableInfo for
         R, T, F, E, A
			   ;

inh champs : StructFields for
				 CHAMPS
				 ;

syn champsS : StructFields for
				 CHAMPS
				 ;


-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;

--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

-- (1) : REGLES DE PRODUCTION
PROGRAMME -> #init #initTDS ENTITES #gen;
global
   machine : IMachine;
-- Transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}

-- Initialisation des TDS sans parent.
#initTDS {
local
do
  ENTITES^tvar := new VariableTable();
  ENTITES^tfun := new FunctionTable();
  ENTITES^talias := new AliasTable();
	ENTITES^machine := PROGRAMME^machine;
end
}
-- Ecrit le code dans un fichier
#gen {
local
do
   machine.writeCode(PROGRAMME^source.getFileName(), ENTITES^code);  
end
}

-- (2)
ENTITES -> #code ;

-- Fin du code.
#code {
local
do
  ENTITES^code := "";
end
}

-- (3)
ENTITES -> #passAH ENTITE #transmissionTDS ENTITES #passCode ;

-- Passage des attributs hérités.
#passAH {
local
do
  ENTITE^machine := ENTITES^machine;
	ENTITE^tvar : =ENTITE^tvar;
	ENTITE^tfun := ENTITE^tfun;
	ENTITE^talias := ENTITE^talias;
end
}

-- Transmission des TDS mise à jour après ENTITE à ENTITES1.
-- (La transmission de ENTITES à ENTITE se fait, normalement, automatiquement).
#transmissionTDS {
local
do
  ENTITES1^tvar := ENTITE^tvarS;
  ENTITES1^tfun := ENTITE^tfunS;
	ENTITES1^talias := ENTITE^taliasS;
	ENTITES1^machine := ENTITES^machine;
end
}

-- Concaténation et passage du code.
#passCode {
local
do
  ENTITES^code := ENTITE^code + ENTITES1^code;
end
}

---------------------------------------------
-------- DEFINITION D'UN NOM DE TYPE --------
--      (commence avec une majuscule)      --
---------------------------------------------

-- (4)
ENTITE -> typedef TYPE #ajout identc pv ;

-- Ajout de identc à la table des alias.
-- Vérifie que identc n'est pas déjà utilisé (par une variable, une fonction ou un autre alias).
#ajout {
local
  info : SymbolInfo;
  infoVar : VariableInfo;
	t : Type;
	ta : AliasTable;
do
  ta := ENTITE^talias;
  info := ENTITE^tvar.lookup(identc^txt, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, identc^txt);
  else
     info := ENTITE^tfun.lookup(identc^txt, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
    if info != null then
        error(IDENT_TAKEN, identc^txt);
     -- Sinon, on peut ajouter le nouveau type à la TDS.
    else
		  -- Vérification dans la table des alias.
			t := ta.lookup(identc^txt);
			if (t != null) then
			  error(IDENT_TAKEN, identc^txt);
      else
        ta.insert(identc^txt, TYPE^type );
			end
    end
  end  
	-- On fait remonter la nouvelle talias.
	ENTITE^taliasS := ta;
	-- Les autres tds ne sont pas modifiées.
	ENTITE^tvarS := ENTITE^tvar;
	ENTITE^tfunS := ENTITE^tfun;
	-- Pas de code pour cette RP.
	ENTITE^code := "";
end
}

---------------------------------------------------------
-- DEFINITION D'UNE VARIABLE GLOBALE OU D'UNE FONCTION --
--            (commence par une minuscule)             --
---------------------------------------------------------

-- (5)
ENTITE -> #talias TYPE ident #idLibre DECL #majTDS #passCode; 

-- Passage de la table des alias.
#talias {
local
do
  TYPE^talias := ENTITE^talias;
end
}

-- Vérification que ident n'est pas déjà utilisé dans une TDS.
-- On n'ajoute pas encore la variable / fonction à la table car on ne sait pas encore la nature.
-- On fait par contre passer les infos (ident^txt et type) à DECL pour qu'il puisse effectuer lui même l'ajout.
-- On fait aussi passer les TDS pour qu'il puisse les màj et s'en servir.
#idLibre {
local
  info : SymbolInfo;
	t : Type;
do
  info := ENTITE^tvar.lookup(ident^txt, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, ident^txt);
  else
     info := ENTITE^tfun.lookup(ident^txt, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
    if info != null then
        error(IDENT_TAKEN, ident^txt);
     -- Sinon, on fait passer les infos utiles à DECL.
    else
		  -- Verification dans talias.
			t := ENTITE^talias.lookup(ident^txt, true);
			if (t!= null) then
			  error(IDENT_TAKEN, ident^txt);
      end
		end
  end  
  DECL^typeH := TYPE^type;
  DECL^nom := ident^txt;
  DECL^tvar := ENTITE^tvar;
  DECL^tfun := ENTITE^tfun;
	DECL^talias := ENTITE^talias;
	DECL^machine := ENTITE^machine;
end
}

-- On met à jour les TDS de ENTITE à l'aide de celles de DECL.
#majTDS {
local
do
  ENTITE^tvarS := DECL^tvarS ;
  ENTITE^tfunS := DECL^tfunS ;
	-- La talias n'est pas modifiée par cette RP.
	ENTITE^taliasS := ENTITE^talias ;
end
}

-- Passage du code généré par DECL à ENTITE.
#passCode {
local
do
  ENTITE^code := DECL^code;
end
}


-- (6) : VARIABLE
DECL -> pv #ajoutDansTDS #genCode;

-- Ajout de la variable (puisqu'on sait désormais que c'en est une) à la TDSvar (de DECL) la TDSfun reste inchangée.
-- DECL possède les attributs nécessaires à la création de la VariableInfo.
-- Les tds à jours sont mises dans des attributs spéciaux de manière à ce que la règle de prod précèdente puisse les récupérer.
#ajoutDansTDS {
local
  tv : VariableTable ;
do
  tv := DECL^tvar;
  tv.insert(DECL^nom, DECL^typeH);
  DECL^tvarS := tv;
  DECL^tfunS := DECL^tfun ; -- La TDS fun n'est pas affectée.
end
}

-- Génération du code pour la déclaration de la variable.
#genCode {
local
do
  DECL^code := DECL^machine.generateAllocateInStack(DECL^typeH);
end
}


-- FONCTION (7)
DECL -> #transmission FONCTION #majTDS #passCode;

-- L'ajout de la fonction dans la TDS nécessitant la connaissance des params, on ne peut pas le faire dans cette RP.
-- On fait passer le type retour ainsi que le nom de la fonction à FONCTION pour l'ajout.
#transmission {
local
do
  FONCTION^nom := DECL^nom;
  FONCTION^typeH := DECL^typeH;
	FONCTION^tvar := DECL^tvar;
	FONCTION^talias := DECL^talias;
	FONCTION^tfun := DECL^tfun;
	FONCTION^machine := DECL^machine;
end
}

-- "Mise à jour" des TDS de DECL.
#majTDS {
local
do
 -- La nouvelle TDSfun contient les infos concernant la nouvelle fonction.
  DECL^tfunS := FONCTION^tfunS;
 -- La TDSvar est inchangée.
  DECL^tvarS := DECL^tvar;
end
}

--Passage du code de declaration de la fonction à DECL.
#passCode {
local
do
  DECL^code := FONCTION^code;
end
}


-- (8)
FONCTION -> #attH paro PARFS parf #ajoutEtPassFI #creationTDSPetiteFille BLOC #declFonction ;

-- Init des attributs hérités pour PARFS.
#attH {
local
do
  -- On crée la TDSvar fille pour la passer à PARFS.
  PARFS^tvar := new VariableTable(FONCTION^tvar);
  PARFS^tfun := FONCTION^tfun;
	PARFS^talias := FONCTION^talias;
	-- Creation de la FunctionInfo avec le type retour.
  PARFS^funInfoH := new FunctionInfo(FONCTION^typeH);
  -- Initialisation du compteur de parametres.
  PARFS^cParam := 0;
  PARFS^machine := FONCTION^machine;
end
}

-- Initialisation du compteur de parametres.
#initC {
local 
do
  PARFS^cParam := 0;
end
}

-- Ajout de la FunctionInfo à tfun.
-- Passage de tfun à FONCTION et BLOC.
-- Passage de la FunctionInfo à BLOC.
#ajoutEtPassFI {
local
  tf : FunctionTable;
  fi : funInfo;
do
  tf := PARFS^tfun;
  fi := PARFS^funInfo;
  tf.insert(FONCTION^nom, fi);
  -- Passage de tfun à FONCTION et à BLOC.
  FONCTION^tfunS := tf;
  BLOC^tfun := tf;
  -- Passage de funInfo à BLOC.
  BLOC^funInfoH := fi;
end
}

-- Creation d'une TDS fille de la Tvar de PARFS et passage en tant que tvar de BLOC.
#creationTDSPetiteFille {
local
do
  BLOC^tvar := new VariableTable(PARFS^tvarS);
	BLOC^talias := FONCTION^talias;
	BLOC^machine := FONCTION^machine;
end
}

-- Generation du code de la declaration de la fonction.
#declFonction {
local
do
  FONCTION^code := FONCTION^machine.generateFunctionDeclaration(PARFS^funInfo , BLOC^code);
end
}

-------------------------------------------
-------- PARAMETRES DE FONCTION -----------
-------------------------------------------

-- (9)
PARFS -> #pass ;

#pass {
local
do
  -- fin de la liste des parmètres, on transmet le fi 'final'.
  PARFS^funInfo := PARFS^funInfoH ;
	-- Passage de tvar, qui contient les paramètres de la fonction.
  PARFS^tvarS := PARFS^tvar;
end
}


-- (10)
PARFS -> #pass PARF #passTvar #ajoutType PARFSX #majTvarSynt #transFI ;
-- (Normalement le passage des TDS de PARFS à PARF puis de PARF à PARFSX se fait automatiquement).

-- Passage des params inh de PARF.
#pass {
local
  c : int;
do
  -- Incrementation du compteur de parametres.
  c := PARFS^cParam + 1;
  PARF^cParam := c;
	-- Passage des tds.
  PARF^tvar := PARFS^tvar;
  PARF^tfun := PARFS^tfun;
  PARF^talias := PARFS^talias;
	PARF^machine := PARFS^machine;
  -- Passage de c à PARFSX aussi.
	PARFSX^cParam := c;
	PARFSX^machine := PARFS^machine;
end
}

-- Passage des tds à PARFSX.
#transTvar {
local
do
  PARFSX^tvar := PARF^tvarS;
	PARFSX^tfun := PARFS^tfun;
	PARFSX^talias := PARFS^talias;
end
}


-- On ajoute le type de PARF à la fi et on transmet à PARFSX.
#ajoutType {
local
  fi : functionInfo ; 
do
  fi := PARFS^funInfoH ;
  -- On ajoute le type de PARF à la variable FunctionInfo.
  fi.add(PARF^type);
  PARFSX^funInfoH := fi;
end
}

-- On fait remonter la tvar contenant les params de la fonction.
-- Ainsi que le fi final.
#majTvarSynt {
local
do
  PARFS^tvarS := PARFSX^tvarS;
  PARFS^funInfo := PARFSX^funInfo;
end
}

-- Transmission de FunctionInfo.
#transFI {
local
do
  
end
}


-- (11)
PARFSX ->  #passageFunInfo ;

-- Passage de FunctionInfo (transformation d'attribut hérité en attribut synthétisé).
#passageFunInfo {
local
do
  PARFSX^funInfo := PARFSX^funInfoH ;
end
}

 
-- (12)
PARFSX -> #pass virg PARF #majFI PARFSX #transFI ;

-- Passages des attributs.
#pass {
local
  c : int;
do
  -- Incrementation du compteur de parametres.
  c := PARFSX^cParam + 1;
  PARF^cParam := c;
	-- Passage des tds.
  PARF^tvar := PARFSX^tvar;
  PARF^tfun := PARFSX^tfun;
  PARF^talias := PARFSX^talias;
	PARF^machine := PARFSX^machine;
  -- On passe aussi c à PARFSX1.
  PARFSX1^cParam := c;
	PARFSX1^machine := PARFSX^machine;
end
}

-- Ajout du paramètre de PARF au functionInfo et passage à PARFSX1.
-- Passage des tds.
#majFI {
local
  fi : functionInfo;
do
  fi := PARFSX^funInfoH;
  fi.add(PARF^type);
  PARFSX1^funInfoH := fi;
	PARFSX1^tvar := PARF^tvarS;
	PARFSX1^tfun := PARFSX^tfun;
	PARFSX1^talias := PARFSX^talias;
end
}

-- Transmission de FunctionInfo.
#transFI {
local
do
  PARFSX^funInfo := PARFSX1^funInfo ;
end
}


-- (13)
PARF -> #talias TYPE #ajouts ident ;

-- Passage de la table des alias.
#talias {
local
do
  TYPE^talias := PARF^talias;
enXd
}


-- Ajout de ident à la TDS locale.
-- Vérifications concernant ident.
-- Passage du type.
#ajouts {
local
  tv : VariableTable;
	t : Type;
do
  tv := PARF^tvar;
  -- Vérifications concernant ident.
  info := tv.lookup(ident^txt, false);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
    error(IDENT_TAKEN, ident^txt);
  else
    info := PARF^tfun.lookup(ident^txt, false);
    -- De même si identc est déjà utilisé dans la TDSfun.
    if info != null then
      error(IDENT_TAKEN, ident^txt);
    else
		  t := PARF^talias.lookup(ident^txt, false);
			-- De même dans talias.
			if (t != null) then
			  error(IDENT_TAKEN, ident^txt);
			else
			  -- Ajout de ident à la TDS locale.
        tv.insert(ident^txt, new VariableInfo(TYPE^type, PARF^funInfo.displacement(PARF^cParam)));
      end
		end
  end
	PARF^tvarS := tv;
  PARF^type := TYPE^type;
end
}


----------------------------------------------------------------
-------- LES TYPES (de base, noms, struct et pointeurs) --------
----------------------------------------------------------------

-- (14)
TYPE -> #talias STYPE #passage PTRS #recupType;

-- Passage talias.
#talias {
local
do
  STYPE^talias := TYPE^talias;
end
}

-- Passage du type de STYPE à PTRS pour qu'il "pointeurise" la chose.
#passage {
local
do
  PTRS^typeH := STYPE^type;
end
}

-- Recuperation du type final de l'expression.
#recupType {
local
do
  TYPE^type := PTRS^type;
end
}


-- Des * pour definir un pointeur (15)
PTRS -> #passage ;

-- Passage de l'attribut hérité à celui synthétisé. 
#passage {
local
do
  PTRS^type := PTRS^typeH;
end
}


-- (16)
PTRS -> mult #point PTRS #passage ;

-- Passage du type une foix la couche de pointeur ajoutée.
#point {
local
do
  PTRS1^typeH := new PointerType(PTRS^typeH);
end
}

-- Probablement inutile : passage de l'attribut type synthétisé.
#passage {
local
do
  PTRS^type := PTRS1^type;
end
}


-- Types de base (17)
STYPE-> void #typage ;

#typage {
local
do
  STYPE^type := new VoidType();
end
}


-- (18)
STYPE-> int #typage ;

#typage {
local
do
  STYPE^type  := new IntegerType();
end
}


-- (19)
STYPE-> char #typage ;

#typage {
local
do
  STYPE^type  := new CharacterType();
end
}

-- (20) : Nom de type (commence par une majuscule) 
STYPE -> identc #testType;

#testType {
local
  typeRech : Type;
do
  typeRech := STYPE^talias.lookup(identc^txt);
  -- Si identc n'est pas une clef dans la TDSvar, erreur.
  if typeRech = null then
     error(IDENT_UNDEFINED, identc^txt);
  end
  STYPE^type :=  typeRech;
end
}


------------------------
------ STRUCTURES ------
------------------------

-- (21)
STYPE -> struct aco #ch CHAMPS acf #type ;

-- Création de la liste de champs qui servira à construire le type.
#ch {
local
do
  CHAMPS^champs := new StructFields();
end
}

-- On récupère la liste des champs, synthétisée par CHAMPS,
-- pour créer le type.
#type {
do
  STYPE^type := new StructType(CHAMPS^champsS);
end
}


-- (22)
CHAMPS -> #pass ;

-- Passage de l'attribut hérité à celui synthétisé.
#pass {
local
do
  CHAMPS^champsS := CHAMPS^champs;
end
}


-- (23) : Un nom de champ commence par une minuscule.
CHAMPS -> #talias CHAMP #ch CHAMPS #passChamps ;

-- Passage talias.
#talias {
local
do
  CHAMP^talias := CHAMPS^talias;
end
}

#ch {
local
  c : StructFields
do
  c := CHAMPS^champs;
  if c.exist(CHAMP^nomS) then
	  -- si un champ porte déjà ce nom : erreur.
    error(IDENT_TAKEN, CHAMP^nomS);
  else
	  -- Sinon, on ajoute le champ au StructFields.
    c.insert(CHAMP^nomS,CHAMP^type);
   end
	 -- On passe le StructFields à CHAMPS1.
	 CHAMPS1^champs := c;
end
}

-- Passage du StructFields.
#passChamps {
local
do
  CHAMPS^champsS := CHAMPS1^champsS;
end
}


-- (24) 
CHAMP -> #talias TYPE #pass ident pv;

-- Passage de la table des alias.
#talias {
local
do
  TYPE^talias := CHAMP^talias;
end
}

-- Passage des attributs qui serviront à créer le champ.
#pass {
local
do
  CHAMP^nomS = ident^txt;
  CHAMP^type = TYPE^type;
end
}


----------------------------------------------------------------
----------- CORPS DE FONCTION ET BLOC D'INSTRUCTIONS -----------
----------------------------------------------------------------

-- (25)
BLOC ->  aco #passage INSTS acf #flushPassCode ;

-- Probablement inutile, mais passage des TDS de BLOC à INSTS.
-- Ainsi que la FunctionInfo de la fonction.
#passage {
local
do
  INSTS^tvar := BLOC^tvar;
  INSTS^tfun := BLOC^tfun;
	INSTS^talias := BLOC^talias;
	INSTS^machine := BLOC^machine;
  INSTS^funInfoH := BLOC^funInfoH;
end
}

-- Generation du flush de fin de bloc.
-- Passage du code généré par les INSTS (et le flush) à BLOC.
#flushPassCode {
local
  code : String;
do
  code := INSTS^code;
  code := code + BLOC^machine.generateFlush(INSTS^tvarS);
  BLOC^code := code;
end
}



-- Instructions
-- (26) : Fin des instructions du bloc.
INSTS -> #initCode #tvarS;

-- Initialisation de l'attribut code (chaine vide).
#initCode {
local
do
  INSTS^code := "";
end
}

-- On fait remonter la tvarS pour le flush.
#tvarS {
local
do
  INSTS^tvarS := INSTS^tvar;
end
}


-- (27)
INSTS -> #funInfo INST #passage INSTS #passCode ;

-- Passage du type retour de la fonction.
#funInfo {
local
do
  INST^funInfoH := INSTS^funInfoH;
	INSTS1^funInfoH := INSTS^funInfoH;
	INST^tvar := INSTS^tvar;
	INST^tfun := INSTS^tfun;
	INST^talias := INSTS^talias;
	INST^machine := INSTS^machine;
end
}

-- Passage des TDS de INST à INSTS1.
#passage {
local
do
  INSTS1^tvar := INST^tvarS;
	-- tfun, talias et machine directement hérité de INSTS.
  INSTS1^tfun := INSTS^tfun; 
	INSTS1^talias := INSTS^talias;
	INSTS1^machine := INSTS^machine;
end
}

-- Concaténation des codes et passage à INSTS.
-- Remontée de tvarS.
#passCode {
local
do
  INSTS^code := INST^code + INSTS1^code;
	INSTS^tvarS := INSTS1^tvarS;
end
}


-- (28) : Declaration de variable locale avec ou sans init 
INST -> #talais TYPE ident #attributs AFFX pv #genCode;

-- Passage de la table des alias.
#talias {
local
do
  TYPE^talias := ENTITE^talias;
end
}

-- Passage des attributs hérités de AFFX. 
#attributs {
local
do
  AFFX^machine := INST^machine;
	AFFX^tvar := INST^tvar;
	AFFX^tfun := INST^tfun;
	AFFX^talias := INST^talias;
	-- Une affectation est possible.
	AFFX^affPossible := true;
		-- Le type de cette affectationn doit être celui de TYPE.
	AFFX^typeH := TYPE^type;
end
}

-- Génération du code
-- On vérifie si on a TYPE ident := X; ou TYPE ident;
-- Dans le cas où l'affectation existe, on vérifie la compatibilité des types.
#genCode {
local
  nom : String;
  code : String;
	info : SymbolInfo;
	t : Type;
	tv : VariableTable;
do
  nom := ident^txt;
  tv := INST^tvar;
  info := INST^tvar.lookup(nom, true);
  -- Si ident est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, nom);
  else
    info := INST^tfun.lookup(nom, false);
    -- De même si identc est déjà utilisé dans la TDSfun.
    if (info != null) then
      error(ALREADY_A_FUNCTION_IDENT, nom);
		else
		  t := INST^talias.lookup(nom);
			-- De même pour la talias.
			if (t != null) then 
			  error(ALREADY_AN_ALIAS, nom);
			else
		    -- Sinon, on ajoute cet id à la tdsvar.
	   	  tv.insert(nom, TYPE^type);
				code := INST^machine.generateAllocateInStack(TYPE^type);
			end
    end
  end 
	if !(AFFX^estVar) then
    -- On a une affectation.	
		-- Verification de types inutile, elle est faite dans AFFX.
		-- On génère le code pour stocker la valeur du registre 
		-- de AFFX dans la variable qu'on vient de déclarer.
    code := code + INST^machine.generateStoreVariable(tv.lookup(ident^txt), AFFX^reg);
	end
  INST^code := code;
	INST^tvarS := tv;
end
}


-- (29) : Instruction expression (affectation et appel de procedure)
INST -> #pass E pv #passCode ;

#pass {
local
do
  E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
end
}

#passCode {
local
do
  -- Une expression ne modifie pas la tvar.
  INST^tvarS := INST^tvar;
	-- Remonéte du code.
	INST^code := E^code;
end
}


-- (30) : Bloc d'instructions
INST ->  #tdsFille #passFI BLOC #passTvar #passCode;

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#tdsFille {
local
  tfille : VariableTable;
do
  tfille := new VariableTable(INST^tvar);
  BLOC^tvar := tfille;
end
}

-- Passage de la FunctionInfo.
#passFI {
local
do
  BLOC^funInfoH := INST^funInfoH;
end
}

-- La tvar de INST n'est pas modifiée par BLOC.
#passTvar {
local
do
  INST^tvarS := INST^tvar;
end
}

-- Passage du code de BLOC à INST.
-- Les instructions de fin de bloc (flush etc) sont générés dans la RP de BLOC.
#passCode {
local
do
  INST^code := BLOC^code;
end
}

-- (31) : Conditionnelle
INST -> si paro #pass E parf #passFI #tdsFille BLOC #transTDS SIX #passAttributs #genCode;

#pass {
local
do
  E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
end
}

-- Passage de FunctionInfo.
#passFI {
local
do
  BLOC^funInfoH := INST^funInfoH;
	SIX^funInfoH := INST^funInfoH;
end
}

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#tdsFille {
local
  tfille : VariableTable;
do
  tfille := new VariableTable(INST^tvar);
  BLOC^tvar := tfille;
  BLOC^tfun := INST^tfun;
	BLOC^talias := INST^talias;
	BLOC^machine := INST^machine;
end
}

-- Useless?
-- Transmission des TDS 'parentes' à SIX.
#transTDS {
local
do
  SIX^tvar := INST^tvar;
  SIX^tfun := INST^tfun;
	SIX^talias := INST^talias;
	SIX^machine := INST^machine;
end
}

-- Passage de la TDSvar en attribut synthétisé.
#passAttributs {
local
do
  INST^tvarS := INST^tvar;
end
}

-- Génération du code pour une conditionnelle.
#genCode {
local
  code : String;
do
  code := E^code;
	-- On vérifie que le type dans la conditionnelle est bien un entier (en l'absence de booléens)
	match E^type
	with IntegerType then
		-- Si c'est le cas, on génère le code
 		code := code + INST^machine.generateIfThenElse(E^reg,BLOC^code,SIX^code);
	else
		-- Sinon, on renvoie une erreur
    error(TYPE_NOT_EQUAL);
	end
	INST^code := code ;
end
}


-- (32)
SIX -> sinon #passFI #tdsFille BLOC #passCode;

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
-- Passage du type retour de la fonction.
#tdsFille {
local
  tfille : VariableTable;
do
  BLOC^funInfoH := SIX^funInfoH;
  tfille := new VariableTable(SIX^tvar);
  BLOC^tvar := tfille;
  BLOC^tfun := SIX^tfun;
	BLOC^talias := SIX^talias;
	BLOC^machine := SIX^machine;
end
}

-- Passage du code du BLOC à SIX.
#passCode{
local
do
  SIX^code := BLOC^code;
end
}


-- (33)
SIX -> #codeVide ;
-- Rien à faire pour la gestion des TDS.
-- Génération d'une chaine de caractère vide.
#codeVide {
local
do
  SIX^code := "";
end
}



-- (34) : Retour de fonction.
INST ->  retour #pass E pv #verifTypage #genCode ;

#pass {
local
do
  E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
end
}

-- Vérification que E est du type retour de la fonction.
#verifTypage {
local
  typeRet : Type;
do
  typeRet := INST^funInfoH.returnType();
  -- Si typeRet ne correspond pas à E^type
  -- alors erreur.
  if not typeRet.isEqualTo(E^type) then
    error(TYPE_NOT_COMPATIBLE, typeRet.name(), E^type.name());  
  end
end
}

--Génération du code de retour de la fonction et du flush.
#genCode {
local
  code : String;
do
  code :=   INST^machine.generateFlush(INST^tvar)
	        + INST^machine.generateFunctionReturn(INST^funInfoH, E^reg);
	INST^code := code;
end
}


-----------------------------------------------------------------------
--------------------------- LES EXPRESSIONS ---------------------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

-- (35)
E -> #herit A #pass AFFX #attSyn;

#herit {
local
do
  A^machine := E^machine;
	A^tvar := E^tvar;
  A^tfun := E^tfun;
	A^talias := E^talias;
end
}

-- Passage des attributs hérités de AFFX.
-- Maj d'un attribut pour AFFX signalant si A est, ou non, une variable.
-- Maj de l'attribut typeH de AFFX afin de tester que les types correspondent.
#pass {
local
do
  AFFX^machine := E^machine;
	AFFX^tvar := E^tvar;
	AFFX^tfun := E^tfun;
	AFFX^talias := E^talias;
  -- L'affectation est possible si A est une variable.
  AFFX^affPossible := A^estVar;
	-- Le type de cette afectation doit être le même que A.
  AFFX^typeH := A^type;
end
}

-- Génération du code de l'affectation.
-- Passage des attributs syn de E.
#attSyn {
local
  code : String;
	reg : Register;
	estVar : boolean;
	vi : VariableInfo;
do
  reg := new Register();
  code := A^code + AFFX^code;
  -- On n'a pas d'affectation à droite.
  if ((A^estVar) && (AFFX^estVar)) then
	  -- E peut dans ce cas représenter une variable.
	  estVar := true ;
		vi := A^vi ;
  else 
	  -- E ne représente pas de variable.
	  estVar := false ;
		vi := null ;
		-- On génère le code de l'affectation.
		code := code + E^machine.generateStoreVariable(A^vi,reg);
	end
  E^type := A^type;
	E^reg := reg;
	E^estVar := estVar;
	E^vi := vi;
	E^code := code;
end
}


-- (36) : Affectation
AFFX -> affect #herit A #affValide #att ;

#herit {
local
do
  A^machine := AFFX^machine;
	A^tvar := AFFX^tvar;
  A^tfun := AFFX^tfun;
	A^talias := AFFX^talias;
end
}

-- Vérifie que l'affectation est valide :
--   - la partie à gauche du = doit être une variable,
--   - le type de A doit être compatible avec celui de AFFX.
#affValide {
local
do
  if !(AFFX^affPossible) then
    error(LEFT_PART_NOT_VARIABLE );
  else
	  -- Verification d'égalité des types.
    if !(A^type.isEqualTo(AFFX^typeH)) then
     error(TYPE_NOT_COMPATIBLE);    
		end
	end
end
}

-- On met l'attribut estVar de AFFX à faux car la règle 
-- appelante ne pourra pas être une variable suite à cette RP.
-- Le registre et le type de AFFX sont ceux de A.
#att {
local
do
  AFFX^estVar := false;
  AFFX^reg := A^reg;
  AFFX^type := A^type;
	AFFX^code := A^code;
end
}


-- (37)
AFFX -> #att ;

-- On met estVar à true car cette RP n'empeche pas la representation d'une var.
-- code est vide, reg est null, type aussi.
#att {
local
do
  AFFX^estVar := true ;
	AFFX^reg := null;
	AFFX^type := null;
	AFFX^code := "";
end
}


-- (38) : Relation
A -> #attR R #attAX AX #attA ;

#attR {
local
do
  R^machine := A^machine;
	R^tvar := A^tvar;
	R^tfun := A^tfun;
	R^talias := A^talias;
end
}

#attAX{
local
do
  AX^machine := A^machine;
	AX^tvar := A^tvar;
	AX^tfun := A^tfun;
	AX^talias := A^talias;
end
}

-- Attributs syn pour A.
#attA {
local
  reg : Register;
	code : String;
	vi : VariableInfo;
	estVar : boolean;
do
  reg := new Register();
	code := R^code + AX^code;
	-- Si AX n'est pas une variable, on doit générer le code de l'opération.
	if !(AX^estVar) then
	  -- Le type de A doit être comparable, ie il doit s'agir d'un type simple.
	  match A^type
		with SimpleType then 
		  -- Si le type est comparable :
	    -- On vérifie que les types de R et AX sont bien compatibles.
      if !(R^type.isCompatible(AX^type)) then 
		    error(TYPE_NOT_EQUAL);
		  else
  	 		-- On génnère le code de l'opération.
		    code := code + A^machine.generateOperation(AX^op,R^reg,AX^reg,reg);
	    end
		else
		  -- Le type n'est pas simple : impossible de faire une comparaison.
		  error(TYPE_NOT_COMPARABLE);
		end
	end
	-- A représente une variable si AX ne l'empêche pas 
  -- et R représente une variable, on fait alors passer
  -- la vi de R à A. Sinon, vi est à null pour R.
  if (R^estVar)&&(AX^estVar) then 
    estVar := true;
    vi := R^vi;
	else
	  estVar := false;
    vi := null;
	end
	-- Le registre de A contient le résultat de l'opération.
	A^reg := reg;
  -- Passage des autres attributs.
	A^type := new IntegerType();
  A^code := code;
  A^vi := vi;
	A^estVar := estVar;
end
}


-- (39)
AX -> OPREL #attR R #parSyn;

-- Rien à faire passer à OPREL.
#attR {
local
do
  R^machine := AX^machine;
	R^tvar := AX^tvar;
	R^tfun := AX^tfun;
	R^talias := AX^talias;
end
}

-- Paramètres syn de AX.
#parSyn {
local
do
  -- La RP appelante ne represente pas une variable.
  AX^estVar := false;
	-- Les autres attributs font passer ceux de R.
  AX^oprel = OPREL^oprel;
	AX^reg := R^reg;
	AX^type := R^type;
	AX^code := R^code;
end
}


-- (40)
AX -> #parSyn;

-- Paramètres syn de AX.
#parSyn {
local
do
  -- L'oprel de AX est null dans ce cas.
  -- Il faut tout de même l'initialiser comme il s'agit d'un attribut synthétisé.
  AX^oprel := null;
  -- La RP n'empeche pas d'etre une variable.
  AX^estVar := true;
  -- Il faut init code.
  AX^code =: "";
	-- Registre à null, de même que type.
	AX^reg := null;
	AX^type := null;
end
}


-- (41) Operateurs relationnels
OPREL -> #opr inf ;

#opr {
local
do
  OPREL^oprel := IMachine.RelationalOperator.LT;
end
}


-- (42)
OPREL -> #opr sup ;

#opr {
local
do
  OPREL^oprel := IMachine.RelationalOperator.GT;
end
}


-- (43)
OPREL -> #opr infeg ;

#opr {
local
do
  OPREL^oprel := IMachine.RelationalOperator.LEQ;
end
}


-- (44)
OPREL -> #opr supeg ;

#opr {
local
do
  OPREL^oprel := IMachine.RelationalOperator.GEQ;
end
}


-- (45)
OPREL -> #opr eg ;

#opr {
local
do
  OPREL^oprel := IMachine.RelationalOperator.EQ;
end
}


-- (46)
OPREL -> #opr neg ;

#opr {
local
do
  OPREL^oprel := IMachine.RelationalOperator.NEQ;
end
}


-- (47)
R -> T #attRX RX #attR ;

-- Attributs inh de RX.
#attRX {
local
do
  RX^machine := R^machine;
	RX^talias := R^talias;
	RX^tfun := R^tfun;
	RX^tvar := R^tvar;
end
}

-- Attributs syn de R.
#attR {
local
  code : String;
	reg : Register;
	vi : VariableInfo;
	estVar : boolean;
	type : Type;
do
  -- Init du registre dans lequel sera stocké le résultat de l'opération.
  reg := new Register();
  code := T^code + RX^code;
	type := T^type
  if (RX^op != IMachine.Operator.NOP) then
	  -- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
		  if !(type.isCompatible(RX^type)) then
			  error(TYPE_NOT_COMPATIBLE);
			else
			  code := code + RX^machine.generateOperation(RX^op,T^reg,RX^reg,reg);
	    end
		else
		  error(TYPE_NOT_SIMPLE);
		end
	end
  -- R est variable si T l'est et RX ne l'empeche pas,
  -- dans ce cas, on lui donne la vi de R. Dans le cas
  -- contraire, l'attribut vi de R est à null.
  if ((T^estVar)&&(RX^estVar)) then
	  R^estVar := true;
		R^vi := T^vi;
	else
	  R^estVar := false;
		R^vi := null;
	end
	-- Passage des attributs.
	R^reg := reg;
	R^code := code;
  R^estVar := estVar;
	R^vi := vi;
  R^type := type;
end
}


-- (48) : Additions ...
RX -> OPADD T #attRX1 RX #attRX ;

-- Pas d'attribut inh pour OPADD.
-- Attributs inh de RX1.
#attRX1 {
local
do
  RX^machine := RX1^machine;
	RX^talias := RX1^talias;
	RX^tfun := RX1^tfun;
	RX^tvar := RX1^tvar;
end
}

-- Attributs syn pour RX.
-- Génération du code de T RX en fonction de RX.
#actuOp {
local
  code : String;
	reg : Register;
	type : Type;
do
  reg := new Register();
	type := T^type;
  -- On met le code de T et RX1.
  code := T^code + RX1^code;
  if (RX1^op != IMachine.Operator.NOP) then
	  -- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
		  if !(type.isCompatible(RX1^type)) then
			  error(TYPE_NOT_COMPATIBLE);
			else
        code := code + RX^machine.generateOperation(RX1^op,T^reg,RX1^reg,reg);
	    end
		else
		  error(TYPE_NOT_SIMPLE);
		end
	end
	    -- Passage de l'operateur de OPADD à RX.
	RX^op := OPADD^op;
	RX^reg := reg;
	RX^code := code;
	RX^type := type;
  -- Si cette RP apparait dans l'expression, alors il ne s'agit pas d'une variable.
  RX^estVar := false;
end
}


-- (49)
RX -> #attRX;

#attRX {
local
do
  RX^op := IMachine.Operator.NOP;
  -- N'empeche pas la représentation d'une variable.
  RX^estVar := true;
  RX^code := "";
	RX^type := null;
	RX^reg := null;
end
}


-- (50) : Operateurs additifs
OPADD -> #op plus ;

#op {
local
do
  OPADD^op := IMachine.Operator.ADD;
end
}


-- (51)
OPADD -> #op moins ;

#op {
local
do
  OPADD^op := SIMachine.Operator.SUB;
end
}


-- (52)
OPADD -> #op ou ;

#op {
local
do
  OPADD^op :=  SIMachine.Operator.OR;
end
}


-- (53) : Multiplication, ...
T -> F TX #oper #estVarEtVi ;

-- 
#oper {
local
  code : String;
	reg : Register;
do
  reg := new Register();
  code := F^code + TX^code;
  if (TX^op != NOP) then
	  code := code + TX^machine.generateOperation(TX^op,F^reg,TX^reg,reg);
	end
	T^reg := reg;
	T^code := code;
end
}

-- T est une variable si F l'est et TX ne l'empeche pas.
-- Dans ce cas, vi de T est celui de F.
-- Sinon, vi est à null.
#estVarEtVi {
local
do
  if ((F^estVar)&&(TX^estVar)) then
	  T^estVar := true;
		T^vi := F^vi;
  else
	  T^estVar := false;
		T^vi := null;
	end
end
}


-- (54)
TX -> OPMUL F TX #actuOp #estVar;

#actuOp {
local
  code : String;
	reg : Register;
do
  reg := new Register();
	code := F^code + TX1^code;
  if (TX1^op != NOP) then
	  code := code + TX1^machine.generateOperation(TX1^op,F^reg,TX1^reg,reg);
	end
	TX^op := OPMUL^op;
	TX^reg := reg;
	TX^code := code;
end
}

--Cette RP empeche l'expression d'etre une variable.
#estVar {
local
do
  TX^estVar := false;
end
}


-- (55)
TX -> #nop #estVar ;

#nop {
local
do
  TX^op := NOP;
end
}

-- N'empeche pas l'espression de rpz une var.
#estVar {
local
do
  TX^estVar := true;
end
}


-- (56) : Operateurs multiplicatifs
OPMUL -> #op mult ;
#op {
local
do
  OPMUL^op := MUL;
end
}


-- (57)
OPMUL -> #op div ;

#op {
local
do
  OPMUL^op := DIV;
end
}


-- (58)
OPMUL -> #op mod ;

#op {
local
do
  OPMUL^op := MOD;
end
}


-- (59)
OPMUL -> #op et ;

#op {
local
do
  OPMUL^op := AND;
end
}


---------------------------------------
--------- Expressions de base ---------
---------------------------------------

-- (60) : Constante entiere
F -> entier #typeEtGenCode #estVarEtVi ;

-- Set de l'attribut de type de F pour indiquer qu'il s'agit d'un entier.
-- Génération du code pour load la valeur de l'entier dans la mémoire.
#typeEtGenCode {
local
  t : IntegerType;
  r : Registre;
	n : int;
do
  -- Creation du type et du registre.
  t := new IntegerType();
  r := new Register();
	-- Récup de l'entier et conversion au bon format.
	n := Integer.parseInt(entier^txt);
	-- Set de l'attribut type.
	F^type := t;
	-- Génération du code, et set de l'attribut le contenant.
  F^code := F^machine.generateLoadConstant(new ConstantInfo(t, n), r); 
	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
	F^reg := r;
end
}

-- Une expression de base ne peut representer une variable.
-- Donc pas de vi.
#estVarEtVi {
local
do
  F^estVar := false;
	F^vi := null;
end
}


-- (61) : Constante chaine
F -> chaine #typeEtGenCode #estVarEtVi ;

-- Set de l'attribut type et reg de F.
-- Génération de code pour load la chaine.
#typeEtGenCode {
local
  l : int;
  t : StringType;
	r : Register;
	s : String;
do
  -- Récup de la chaine.
  s := chaine^txt;
  l := s.length();
	-- Suppression des " au début et à la fin de celle-ci.
	s := s.substring(1,l-1);
	l := l-2;
	-- Initialisation du type, en précisant la taille.
	t := new StringType(l);
  -- Création du registre.
	r := new Register();
	-- Génération du code et set des attributs de F.
	F^code := F^machine.generateLoadConstant(ConstantInfo.fromString(s), r);
	F^reg =: r;
	F^type := t;

end
}

-- Une expression de base ne peut representer une variable.
-- Donc pas de vi.
#estVarEtVi {
local
do
  F^estVar := false;
  F^vi := null;
end
}


-- (62) : Constante caractere
F -> caractere #typeEtGenCode #estVarEtVi ;

-- Set de l'attribut type et reg de F.
-- Génération de code pour load le caractere.
#typeEtGenCode {
local
  c : CharacterType;
	r : Register;
	s : String;
do
  -- Récup du caractère.
	c := caractere^txt.charAt(1);
	-- Init du type et du reg.
	t := new CharacterType();
	reg := new Register();
	-- Gen du code et set des attributs de F.
	F^code := F^machine.generateLoadConstant(new ConstantInfo(t, c), r);
	F^reg := r;
	F^type := t;
end
}

-- Une expression de base ne peut representer une variable.
-- Donc pas de vi.
#estVarEtVi {
local
do
  F^estVar := false;
  F^vi := null;
end
}


-- (63) : Expression unaire
F ->  OPUN  F  #genCode #estVarEtVi;

-- Génération du code pour la déclaration de la variable.
#genCode {
local
  reg : Register();
  code : String;
do
  reg := new Register();
	code:= F1^code + F^machine.generateOperation(OPUN^op,F1^reg,reg);
  F^code := code;
	F^reg := reg;
end
}

-- Une variable ne peut contenir d'opérateur unaire.
-- Donc pas de vi.
#estVarEtVi {
local
do
  F^estVar := false;
  F^vi := null;
end
}


-- (64) : Operateurs unaires
OPUN -> plus ;

#op {
local
do
  OPUN^op := PLS;
end
}


-- (65)
OPUN -> moins ;

#op {
local
do
  OPUN^op := NEG;
end
}


-- (66)
OPUN -> non;

#op {
local
do
  OPUN^op := NOT;
end
}


-- (67) : Pointeur NULL
F -> null #estVarEtVi;

-- Le pointeur null ne représente pas une variable.
-- Donc pas de vi.
#estVarEtVi {
local
do
  F^estVar := false;
  F^vi := null;
end
}

-- (68) : Expression parenthesee
-- TODO.
F ->  paro #pass E parf FX #estVarEtVi;

#pass {
local
do
  E^machine := F^machine;
	E^tvar := F^tvar;
	E^tfun := F^tfun;
	E^talias := F^talias;
end
}

-- F est une variable si E l'est et FX ne l'empeche pas.
-- Dans ce cas, vi de F prend celui de E. Dans le cas
-- contraire, il est null.
#estVarEtVi {
local
do
  if ((E^estVar)&&(FX^estVar)) then
	  F^estVar := true;
		F^vi := E^vi;
	else
	  F^estVar := false;
		F^vi := null;
	end
end
}


-- (69) : Cast
F ->  paro #talias TYPE parf #cast F #estVarEtVi;

-- Passage de la table des alias.
#talias {
local
do
  TYPE^talias := ENTITE^talias;
end
}

-- (int)a ne représente pas une variable : 
-- le cast empeche une expression d'etre une variable.
-- Donc pas de vi.
#estVarEtVi {
local
do
  F^estVar := false;
	F^vi := null;
end
}

#cast {
local
do
  if F1^type.isCompatible(TYPE^type) then
	   F^type := TYPE^type;
		 F^vi := new VariableInfo(TYPE^type,F1^vi.disp());
  else
	   -- Pas de méthode name() dans Type pour l'instant.
     error(TYPE_NOT_COMPATIBLE, F1^type.name(), TYPE^type.name());	   
  end
end
}

-- (70) : Dereferencement.
-- TODO : F^type.
F -> mult F #estVarEtVi;

-- F représente une variable si F1 en représente une, et que celle-ci est un pointeur.
#estVarEtVi {
local
do
	
end
}

-- LA REGLE OU C'EST REPARTI EN VRILLE. --
-- TODO : code sur F et FX.
-- (71)
F -> ident #rechercheTables FX #estVar #genCodeEtReg ; 

global
  varInfo : VariableInfo;
  funInfo : FunctionInfo;
	estFun : boolean;

-- On cherche ident dans les TDS.
-- Instenciation des attributs nécessaires.
#rechercheTables {
local
  listeDepl : DisplacementList ;
	type : Type;
  info : SymbolInfo; 
do
  
  --Initialisations.
  listeDepl := new DisplacementList();
	estFun := false;
	type := null;
	varInfo := null;
	funInfo := null;

	-- Recherche dans la TVar.
  info := F^tvar.lookup(ident^txt);
  if (info = null) then
	  -- ident n'est pas dans la TVar, F n'est pas une variable.
		-- On regarde dans la TFun s'il s'agit de l'identifiant d'une fonction.
		info := F^tfun(lookup(ident^txt);
    if (info = null) then
		  -- On n'a pas trouvé le symbole dans les TDS : erreur.
			error(IDENT_UNDEFINED, ident^txt);
    else
		  -- L'id est celui d'une fonction.
			-- On passe estFun à vrai.
			listeDepl.add(0, false);
			estFun := true;
			type := funInfo.returnType();
    end
  else
		-- On peut passer le type.
		varInfo := (VariableInfo)info;
		type := varInfo.type();
		-- On rajoute toujours le déplacement de a à la liste.
		-- Le test pour savoir si a est bien un struct se fait dans les RP ,de FX.
		listeDepl.add(varInfo.displacement, false);
  end
	-- On passe les attributs qui serviront à FX.
	FX^listeDepl := listeDepl;
	FX^estFun := estFun;
	FX^typeH := type;
	FX^nom := ident^txt;
end
}

-- F est une variable si l'identifiant n'était pas celui d'une fonction : NOP.
-- On peut considérer un appel de fonction comme une variable.
#estVar {
local
do
  F^estVar := true;
	-- F^estVar := !(estFun);
end
}

-- Le type de F est celui de FX.
#type {
local
do
  F^type := FX^type;
end
}

-- Génération du code.
-- Traitements différents selon qu'on ait : - éffectué un appel de fonction.
--																					- accédé simplement à une variable.
--               														- accédé à un champ de struct.
#genCodeEtReg {
local
  listeDepl : DisplacementList; 
  reg : Registre;
	code : String;
	vi : VariableInfo;
do
  listeDepl := FX^listeDeplS;
	vi := null;
  reg := new Registre();
	if estFun then
    -- On a un appel de fonction, peut être suivi d'accés à des champs de struct.
	  -- regRetourFun est le registre contenant le résultat de l'appel de fonction,
		-- il se trouve dans le FunctionInfo \o/.
    code := F^machine.generateMakeAddress(funInfo.register(), listeDepl, reg);
	else 
	  -- On n'a pas d'appel de fonction. 
		if (listeDepl.size() > 1) then
	    -- Des déplacements ont été ajoutés à la liste en plus de celui de ident : on a accédé à des champs de struct !
		  -- Le registre contient l'adresse de la variable accédée par FX dans le struct.
      code := F^machine.generateMakeAddress(listeDepl.register(), reg);
		else
      -- Accés direct à une variable.
      -- On ne génére pas de code directement ici, par contre on fait remonter la vi.
			-- La VariableInfo est déjà dans varInfo.
      code := "";
			vi := varInfo;
		end
  end
	F^vi := vi;
	F^code := FX^code + code;
end
}


-- (72)
FX -> #verifFonction #typeEtDepl ;

-- Vérifie qu'on n'attendait pas une liste d'argument pour un appel de fonction.
#verifFonction {
local
do
  if FX^estFun then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
end
}

-- On fait remonter le type.
-- Et la liste de déplacements.
-- Et une chaine vide comme code.
#typeEtDepl {
local
do
  FX^code := "";
  FX^type := FX^typeH;
  FX^listeDeplS := FX^listeDepl;
end
}

-- (73) : Acces champ
FX -> pt ident #rechChamp FX #typeEtPileDepl;

-- Recherche du champ. 
#rechChamp {
local
  typeStruct : StructType; 
	type : Type;
	listeDepl : DisplacementList;
do
  -- On vérifie qu'on était pas dans un appel de fonction.
	if FX^estFun then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  listeDepl := FX^listeDepl;
	type := FX^typeH;
  -- On vérifie que ce qui est à gauche de cet appel est bien un struct.
  match type
	with StructType then  
		-- On vérifie que le champ existe et on y accède.
    typeStruct := (StructType)type;
		if (typeStruct.fields().instanceOf(ident^txt) = -1) then
		  -- Si le instanceOf renvoie -1, c'est que l'identifiant n'apparait pas dans les champs : erreur.
		  error(CHAMP_INEXISTANT, ident^txt);
		else
      -- Si le champ existe, on ajoute le déplacement correspondant à la liste.
			listeDepl.add(typeStruct.fieldDisplacement(ident^txt),false);
			-- On récupère le type.
   		type := typeStruct.find(ident^txt);
	  end
	else
		-- Sinon : erreur !
	  error(NOT_STRUCT);
  end
	FX1^listeDepl := listeDepl;
	FX1^estFun := false;
	FX1^typeH := type;
  FX1^nom := ident^txt;	
end
}

-- On fait remonter le code, le type et la liste de deplacement.
#typeEtPileDepl{
local
do
  FX^code := FX1^code;
  FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
end
}


-- (74) : Acces champ pointeur
FX -> arrow ident #rechChamp FX #typeEtPileDepl;

-- Comme dans la RP precedent, on doit vérifier que la règle est applicable.
-- Le type passé à FX doit etre celui d'un pointeur et le type pointé un struct.
-- La champ doit exister dans le type pointé.
#rechChamp {
local
  type : Type;
	typeP : PointerType;
	typeS : StructType;
	listeDepl : DisplacementList;
do
  -- On vérifie qu'on était pas dans un appel de fonction.
	if FX^estFun then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  type := FX^typeH;
	listeDepl := FX^listeDepl;
	match type
	with PointerType then
	-- Si type est un pointeur on va vérifier qu'il s'agit d'un pointeur sur struct.
    typeP := (PointerType)type;
		type := typeP.getType();
		-- Si le type pointé est struct, on va vérifier que le champ existe.
    match type
		with StructType
		  typeS := (StructType)type;
      if (typeS.fields().instanceOf(ident^txt) = -1) then
		    -- Si le instanceOf renvoie -1, c'est que l'identifiant n'apparait pas dans les champs : erreur.
		    error(CHAMP_INEXISTANT, ident^txt);
		  else
        -- Si le champ existe, on ajoute le déplacement correspondant à la liste.
		  	listeDepl.add(typeS.fieldDisplacement(ident^txt),true);
		  	-- On récupère le type.
   	  	type := typeS.find(ident^txt);
	    end
		-- Sinon : erreur !
		else
      error(NOT_STRUCT);
		end
	else
	-- Sinon : erreur !
	  error(NOT_A_POINTEUR);
  end
	FX1^estFun := false;
	FX1^typeH := type;
	FX1^listeDepl := listeDepl;
  FX1^nom := ident^txt;
end
}

-- On fait remonter le code, le type et la liste de deplacement.
#typeEtPileDepl{
local
do
  FX^code := FX1^code;
  FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
end
}


-- (75) : Appel de sous-programme
-- La verification des paramètres ainsi que la generation des pushs
-- se font dans ES.
FX -> #estFun #passParams paro ES parf #verifFun #attributs FX #genCode #attributs2;
global
  codeAppel : String

-- Verification que l'appelant est une fonction.
#estFun {
local
do
  if !(FX^estFun) then
	  error(NOT_A_FUN);
	end
end
}

-- Init de la liste des types des params et du code des pops. 
#passParams {
local
do
  ES^typesParams := new List<Type>;
  ES^codeH := "";
end
}

-- Verification qu'il existe bien une fonction avec cette signature.
#verifFun {
local
  fi : functionInfo;
do
  fi := FX^tfun.lookup(FX^nom, ES^typesParamsS);
	if (fi = null) then
	  error(NO_FUN_WITH_SUCH_PARS, FX^nom);
	end
end
}

-- Instenciation des arguments hérités de FX.
#attributs {
local
do
  -- La liste des deplacements n'a pas été modifié par le parcours des arguments.
  FX1^listeDepl := FX^listeDepl;
	-- L'appel de fonction n'est pas une fonction.
	FX1^estFun := false; 
	-- Le type de l'appel est le type de retour de la fonction.
	FX1^typeH := FX^typeH;
	-- Pas de nom pour FX ici.
	FX1^nom := "";
end
}

-- On push les arguments, le code est dans ES^code.
-- Puis on appel la fonction.
-- Et on met le code de FX1.
#genCode {
local
do
  FX^code := ES^code + generateFunctionCall(FX^funInfoH) + FX1^code; 
end
}

-- On fait remonter les attributs hérités.
#attributs2 {
local
do
  FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
end
}


-- (76) : Arguments appel de sous-programme
ES -> #tparams #genCode ;

-- Passage de la liste des types des params de l'appel.
#tparams {
local
do
  ES^typesParamsS := ES^typesParams;
end
}

-- On n'a rien à ajouter comme code à cette RP.
-- On fait remonter le code des paramètres précédents.
#genCode {
local
do
  ES^code := ES^codeH;
end
}


-- (77)
ES -> #pass E #typesEtPassListe ESX #genCode ;

#pass {
local
do
  E^machine := ES^machine;
	E^tvar := ES^tvar;
	E^tfun := ES^tfun;
	E^talias := ES^talias;
end
}

-- On vérifie que E est bien du type attendu pour ce paramètre.
-- Egalité stricte entre les types, on pourrait améliorer en utilisant isEqual.
-- Et on fait passer le reste de la liste des paramètres.
#typesEtPassListe {
local
  l : List<Types>;
  code : String;
do
  -- Ajout du type de E à la liste des types des params.
  l := ES^typesParams;
	l.add(E^type);
  -- Ajout du code du push pour ce param.
  code := code + E^code + ES^machine.generateFunctionPushArgument(E^reg);
  ESX^typesParams := l;
  ESX^codeH := code;
end
}

-- Passage de la liste des types des params.
#tparams {
local
do
  ES^typesParamsS := ESX^typesParamsS;
end
}

-- Passage du code de ESX à ES.
-- Et remontée de la liste des types.
#gencode {
local
do
  ES^code := ESX^code;
	ES^typesParamsS := ESX^typesParamsS;
end
}


-- (78)
ESX -> #tparams #genCode ;

-- Passage des types des params.
#tparams {
local
do
  ESX^typesParamsS := ESX^typesParams;
end
}

-- On n'a rien à ajouter comme code à cette RP.
-- On fait remonter le code des paramètres précédents.
#genCode {
local
do
  ESX^code := ESX^codeH;
end
}


-- (79)
ESX -> virg #pass E #typesEtPassListe ESX #genCode ;

#pass {
local
do
  E^machine := ESX^machine;
	E^tvar := ESX^tvar;
	E^tfun := ESX^tfun;
	E^talias := ESX^talias;
end
}

-- On vérifie que E est bien du type attendu pour ce paramètre.
-- Egalité stricte entre les types, on pourrait améliorer en utilisant isEqual.
-- Et on fait passer le reste de la liste des paramètres.
#typesEtPassListe {
local
  l : List<Types>;
	code : String;
do
  l := ESX^typesParams;
  l.add(E^type);
  code := ESX^codeH + E^code + ESX^machine.generateFunctionPushArgument(E^reg);
  ESX1^typesParams := l;
  ESX1^codeH := code;
end
}

-- Passage du code de ESX à ES.
-- Et remontée de la liste des types.
#gencode {
local
do
  ESX^code := ESX1^code;
  ESX^typesParamsS := ESX1^typesParamsS;
end
}

-----------------------------------------
------------- INLINE ASM ----------------
-----------------------------------------

-- (80)
ENTITE -> asm #tds ASM #gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}


-- (81)
INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool #typage ;
----TODO coté ARM: Ajouter un BooleanType
--#typage {
--local
--do
--  TYPE^type := new BooleanType();
--end
--}

---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true #typeEtGenCode #estVarEtVi ;

---- Set de l'attribut de type de F pour indiquer qu'il s'agit d'un booléen.
---- Génération du code pour load la valeur du booléen dans la mémoire.
--#typeEtGenCode {
--local
--  t : BooleanType;
--  r : Registre;
--do
--  -- Creation du type et du registre.
--  t := new BooleanType();
--  r := new Register();
--	-- Set de l'attribut type.
--	F^type := t;
--	-- Génération du code, et set de l'attribut le contenant.
--	-- TODO : Gérer les booléens coté ConstantInfo
--  F^code := F^machine.generateLoadConstant(new ConstantInfo(t, true), r); 
--	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
--	F^reg := r;
--end
--}

---- Une expression de base ne peut representer une variable.
---- Donc pas de vi.
--#estVarEtVi {
--local
--do
--  F^estVar := false;
--	F^vi := null;
--end
--}
--F -> false #typeEtGenCode #estVarEtVi ;

---- Set de l'attribut de type de F pour indiquer qu'il s'agit d'un booléen.
---- Génération du code pour load la valeur du booléen dans la mémoire.
--#typeEtGenCode {
--local
--  t : BooleanType;
--  r : Registre;
--do
--  -- Creation du type et du registre.
--  t := new BooleanType();
--  r := new Register();
--	-- Set de l'attribut type.
--	F^type := t;
--	-- Génération du code, et set de l'attribut le contenant.
--	-- TODO : Gérer les booléens coté ConstantInfo
--  F^code := F^machine.generateLoadConstant(new ConstantInfo(t, false), r); 
--	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
--	F^reg := r;
--end
--}

---- Une expression de base ne peut representer une variable.
---- Donc pas de vi.
--#estVarEtVi {
--local
--do
--  F^estVar := false;
--	F^vi := null;
--end
--}
--F -> this FX;
-- base = super
--F -> base FX;
----compatible avec null
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
