-----------------------------------------------------
-- Grammaires de MC  et MCS                       --
-----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;

inh tvar : VariableTable for  -- A completer --
         ENTITES, ENTITE
         ;

syn tvarS : VariableTable for 
         PARFS, DECL
         ; -- Utilisée pour récupérer la TDS màj avec les paramètres de la fonction.

inh tfun : FunctionTable for -- A completer --
         ENTITES, ENTITE
	 ;

syn tfunS : FunctionTable for 
         DECL
         ;

inh type : Type for -- A completer --
         TYPE, DECL, FONCTION
         ;

inh nom : String for -- A completer (pas sur) --
         DECL, FONCTION
         ;

-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;

--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

-- REGLS DE PRODUCTION
PROGRAMME -> #init #initTDS ENTITES #gen;
global
   machine : IMachine;
-- Transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}

-- Initialisation des TDS sans parent.
#initTDS {
local
do
  ENTITES^tvar := new VariableTable();
  ENTITES^tfun := new FunctionTable();
end
}
-- Ecrit le code dans un fichier
#gen {
local
do
   machine.writeCode(PROGRAMME^source.getFileName(),"; no code\n");  
end
}


ENTITES -> ;


ENTITES -> ENTITE #transmissionTDS ENTITES ;

-- Transmission des TDS mise à jour après ENTITE à ENTITES1.
-- (La transmission de ENTITES à ENTITE se fait, normalement, automatiquement).
#transmissionTDS {
local
do
  ENTITES1^tvar := ENTITE^tvar;
  ENTITES1^tfun := ENTITE^tfun;
end
}

---------------------------------------------
-------- DEFINITION D'UN NOM DE TYPE --------
--      (commence avec une majuscule)      --
---------------------------------------------

ENTITE -> typedef TYPE #ajout identc pv ;

-- Ajout de identc à TDSvar.
-- Vérifie que identc n'est pas déjà utilisé (par une variable ou une fonction).
#ajout {
local
  info : SymbolInfo;
  infoVar : VariableInfo;
do
  info := ENTITE^tvar.lookup(identc^txt, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, identc^txt);
  else {
     info := ENTITE^tfun.lookup(identc^txt, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
     if info != null then
        error(IDENT_TAKEN, identc^txt);
     -- Sinon, on peut ajouter le nouveau type à la TDS.
     else {
        -- TODO
        -- Création de la VariableInfo à ajouter à la TDS.
      
        ENTITE^tvar.insert(identc^txt, infoVar);
    }
  }  
end
}

---------------------------------------------------------
-- DEFINITION D'UNE VARIABLE GLOBALE OU D'UNE FONCTION --
--            (commence par une minuscule)             --
---------------------------------------------------------

ENTITE -> TYPE ident #idLibre DECL #majTDS; 

-- Vérification que ident n'est pas déjà utilisé dans une TDS.
-- On n'ajoute pas encore la variable / fonction à la table car on ne sait pas encore la nature.
-- On fait par contre passer les infos (ident^txt et type) à DECL pour qu'il puisse effectuer lui même l'ajout.
-- On fait aussi passer les TDS pour qu'il puisse les màj.
#idLibre {
local
  info : SymbolInfo;
do
  info := ENTITE^tvar.lookup(ident^txt, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, ident^txt);
  else {
     info := ENTITE^tfun.lookup(ident^txt, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
     if info != null then
        error(IDENT_TAKEN, ident^txt);
     -- Sinon, on fait passer les infos utiles à DECL.
     else {
        DECL^type := TYPE^type;
        DECL^nom := ident^txt;
        DECL^tvar := ENTITE^tvar;
        DECL^tfun := ENTITE^tfun;
    }
  }  
end
}

-- On met à jour les TDS de ENTITE à l'aide de celles de DECL.
#majTDS {
local
do

end
}



-- VARIABLE
DECL -> pv #ajout;

-- Ajout de la variable (puisqu'on sait désormais que c'en est une) à la TDSvar (de DECL) la TDSfun reste inchangée.
-- DECL possède les attributs nécessaires à la création de la VariableInfo.
-- Les tds à jours sont mises dans des attributs spéciaux de manière à ce que la règle de prod précèdete puisse les récupérer.
#ajout {
local
do
  

  DECL^tvarS := 
  DECL^tfunS := DECL^tfun ; -- La TDS fun n'est pas affectée.
end
}



-- FONCTION
DECL -> #transmission FONCTION #majTDS;

-- L'ajout de la fonction dans la TDS nécessitant la connaissance des params, on ne peut pas le faire dans cette RP.
-- On fait passer le type retour ainsi que le nom de la fonction à FONCTION pour l'ajout.
#transmission {
local
do
  FONCTION^nom := DECL^nom;
  FONCTION^type := DECL^type;
end
}

-- Mise à jour des TDS de DECL.
#majTDS {
local
do

end
}



FONCTION -> #creationTDSfille paro PARFS parf #ajout #recupTDSs BLOC ;

-- On crée la TDSvar fille pour la passer à PARFS.
#creationTDSfille {
local
do
  PARFS^tvar := new VariableTable(FONCTION^tvar);
  PARFS^tfun := FONCTION^tfun;
end
}

-- Récupération de la TDS synthétisée à partir de la liste des paramètres.
#recupTDSs {
local
do
  BLOC^tvar := PARFS^tvarS;
end
}

-- Ajout de la fonction à la TDS.
-- On a vérifié que le nom était "libre" dans "ENTITE -> TYPE ident #idLibre DECL".
-- Le nom ainsi que le type retour sont des attributs de FONCTION.
-- La liste des paramètres un attribut de PARFS.
#ajout {
local
  funInfo : functionInfo;
do
  funInfo := new FunctionInfo(FONCTION^type , PARFS^lTypes);
end
}


-------------------------------------------
-------- PARAMETRES DE FONCTION -----------
-------------------------------------------
PARFS ->  #creationLTypes ;

-- Il n'y a pas de param à la fonction.
-- Création de lTypes, vide.
#creationLTypes {
local
do
  PARFS^lTypes := new ArrayList<Type>;
end
}



PARFS -> PARF PARFSX #creationLTypes #majTvarSynt;
-- (Normalement le passage des TDS de PARFS à PARF puis de PARF à PARFSX se fait automatiquement).

-- Création de lTypes de PARFS à partir de la liste des types de PARFSX et du type de PARF.
#creationLTypes {
local
  lt : ArrayList<Type>; 
do
  lt := PARFSX^lTypes;
  -- On ajoute le type de PARF en tête de liste.
  lt.add(0,PARF^Type);
  PARFS^lTypes := lt;
end
}

-- On crée une TDSvar synthétisée à partir de la liste des paramètres qu'on passe à PARFS.
-- Ce sera la TDS du corps de la fonction.
#majTvarSynt {
local
do
  PARFS^tvarS := PARFSX^tvar;
end
}



PARFSX ->  #creationLTypes;

-- Création de la liste des types qui sera vide pour PARFSX.
#creationLTypes {
local
do
  PARFS^lTypes := new ArrayList<Type>;
end
}

 
PARFSX ->  virg PARF PARFSX #creationLTypes;

-- Création de la liste des types en ajoutant le type de PARF à la liste des paramètres restants.
#creationLTypes {
local
  lt : ArrayList<Type>; 
do
  lt := PARFSX1^lTypes;
  -- On ajoute le type de PARF en tête de liste.
  lt.add(0,PARF^Type);
  PARFS^lTypes := lt;
end
}


-- TODO : - Vérifier que ident n'est pas déjà use.
--        - Ajouter ident à la TDS de la fonction.
--        - Gestion du typage.
PARF ->  TYPE ident ;



----------------------------------------------------------------
-------- LES TYPES (de base, noms, struct et pointeurs) --------
----------------------------------------------------------------
TYPE -> STYPE  PTRS ;
-- type de base
-- des * pour definir un pointeur
PTRS -> ;
PTRS -> mult PTRS ;
-- types de base
STYPE-> void  ;
STYPE-> int ;
STYPE-> char ;
-- nom de type (commence par une majuscule)
STYPE -> identc;
-------------  
-- et struct
STYPE -> struct aco CHAMPS acf ;
CHAMPS -> ;
-- un nom de champ commence par une minuscule
CHAMPS -> CHAMP CHAMPS ;
CHAMP -> TYPE ident pv;

----------------------------------------------------------------
----------- CORPS DE FONCTION ET BLOC D'INSTRUCTIONS -----------
----------------------------------------------------------------
BLOC ->  aco INSTS acf ;
-- instructions
INSTS ->   ;
INSTS ->  INST INSTS  ;
-- declaration de variable locale avec ou sans init 
INST ->  TYPE ident AFFX pv ;
-- instruction expression (affectation et appel de procedure)
INST -> E pv ;
-- bloc d'instructions
INST ->  BLOC  ;
-- conditionnelle
INST ->   si paro E parf BLOC SIX ;
SIX ->    sinon BLOC ;
SIX -> ;
-- retour de fonction
INST ->  retour  E pv ;

-----------------------------------------------------------------------
--------------------------- LES EXPRESSIONS ---------------------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
E ->   A  AFFX ;
-- affectation
AFFX -> affect  A  ;
AFFX -> ;
-- relation
A ->   R AX  ;
AX -> OPREL R;
AX ->  ;
-- operateurs relationnels
OPREL -> inf ;
OPREL -> sup ;
OPREL -> infeg ;
OPREL -> supeg ;
OPREL -> eg ;
OPREL -> neg ;
R ->  T  RX ;
-- additions ...
RX ->   OPADD  T RX  ;
RX -> ;
-- operateurs additifs
OPADD -> plus ;
OPADD -> moins ;
OPADD -> ou ;
-- multiplication, ...
T ->  F  TX  ;
TX ->   OPMUL  F TX  ;
TX ->  ;
-- operateurs multiplicatifs
OPMUL -> mult ;
OPMUL -> div ;
OPMUL -> mod ;
OPMUL -> et ;
-- expressions de base
-- Constante entiere
F -> entier   ;
-- Constante chaine
F -> chaine ;
-- Constante caractere
F -> caractere ;
-- expression unaire
F ->  OPUN  F  ;
-- operateurs unaires
OPUN -> plus ;
OPUN -> moins ;
OPUN -> non;
-- pointeur NULL
F -> null  ;
-- expression parenthesee
F ->  paro E parf FX ;
F ->  paro TYPE parf  F ;
F -> mult F ;
F -> ident FX ;
FX -> ;
-- acces champ
FX ->   pt  ident FX ;
-- acces champ pointeur
FX ->   arrow  ident FX ;
-- appel de sous-programme
FX ->   paro ES parf FX;
-- arguments appel de sous-programme
ES -> ;
ES -> E ESX  ;
ESX ->  ;
ESX -> virg E ESX ;


-----------------------------------------
------------- INLINE ASM ----------------
-----------------------------------------
ENTITE ->   asm #tds ASM#gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}
#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
