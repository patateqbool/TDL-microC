----------------------------------------------------
-- Grammaires de MC  et MCS                       --
----------------------------------------------------



--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : AbstractMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F, FX,
         BASE, DEFS, DEF
         ;

inh indentation : Integer for 
         ENTITE, ENTITES, TYPE, STYPE, PTRS, DECL, FONCTION, PARF, PARFS, PARFSX, BLOC, SIX, 
				 CHAMP, CHAMPS, INST, INSTS, E, A, AX, AFFX, R, RX, T, TX, F, FX, OPADD, OPMUL, OPREL, OPUN,
				 ES, ESX, DEFS, DEF, IDC, HERITAGE, ACCES, BASE
				 ;

-- Dernières updates : attributs noirs et verts.

inh tvar : VariableTable for
         ENTITES, ENTITE, BLOC, F, INSTS, INST, SIX, E, AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX,
				 R, RX, T, TX, FX, ES, ESX, DEFS, DEF, BASE
         ;

inh talias : AliasTable for 
         ENTITES, ENTITE, BLOC, STYPE, TYPE, F, INSTS, INST, SIX, CHAMPS, CHAMP, E,
				 AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX,
         R, RX, T, TX, FX, ES, ESX, DEFS, DEF, BASE
         ; --Table des alias contenant les types propres au programme.

inh tfun : FunctionTable for
         ENTITES, ENTITE, BLOC, F, INSTS, INST, SIX, E, AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX,
				 R, RX, T, TX, FX, ES, ESX, DEFS, DEF, BASE
				 ;

syn type : Type for
         TYPE, STYPE, PTRS, F, CHAMP, E, A, AFFX, AX, FX,
				 R, RX, T, TX 
         ;

inh typesParams : List<Type> for
         ES, ESX
				 ;
 
syn typesParamsS : List<Type> for
         ES, ESX
				 ;

inh typeH : Type for
         PTRS, DECL, FONCTION, FX, AFFX
         ;

inh funInfoH : FunctionInfo for
         PARFS, PARFSX, BLOC, INSTS, INST, SIX, PARF--, FX
				 ;

syn funInfo : FunctionInfo for
         PARF, PARFS, PARFSX, DECL, FONCTION
	       ;

-- Attribut servant à savoir du quantième paramètre il s'agit. 
inh cParam : int for
         PARFS, PARF, PARFSX
				 ;

inh nom : String for 
         DECL, FONCTION, FX
				 ;

syn nomS : String for 
         CHAMP
				 ;

syn code : String for
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX,
				 DEFS, DEF, BASE
				 ;

inh codeH : String for
				 ES, ESX, FX
				 ;

syn op : Integer for -- Operator for
				 OPADD, OPMUL, OPUN, RX, TX
				 ;

syn oprel : Integer for -- : RelationalOperator for
				 OPREL, AX
				 ;

syn reg : Register for
				 F, FX, T, TX, R, RX, E, AFFX, A, AX
				 ;

syn regAdr : Register for 
         A, R, T, F;

syn estVar : boolean for
         R, RX, T, TX, E, A, AFFX, AX, F, FX
				 ;

inh estFun : boolean for
         FX
				 ;

inh affPossible : boolean for
         AFFX
         ;

inh listeDepl : DisplacementList for
				 FX
				 ;

syn listeDeplS : DisplacementList for
				 FX
				 ;

syn vi : VariableInfo for
         R, T, F, E, A
			   ;

inh champs : StructFields for
				 CHAMPS
				 ;

syn champsS : StructFields for
				 CHAMPS
				 ;

inh ni : NamespaceInfo for 
         ENTITE, PARF, INST, F, FX, ENTITES, FONCTION, DECL,
				 PARFS, PARFSX, INSTS, BLOC, AFFX, E, SIX, A, R, AX, T, RX,
				 TX, ES, ESX, IDC, HERITAGE, DEFS, DEF, BASE, TYPE, STYPE, CHAMPS, CHAMP 
				 ;

inh listeNi : NamespaceInfoList for
         ENTITE, PARF, INST, F, FX, ENTITES, FONCTION, DECL,
				 PARFS, PARFSX, INSTS, BLOC, AFFX, E, SIX, A, R, AX, T, RX,
				 TX, ES, ESX, HERITAGE, IDC, DEFS, DEF, BASE, TYPE, STYPE, CHAMPS, CHAMP
				 ;

inh tklass : KlassTable for
				 ENTITES, ENTITE, BLOC, F, INSTS, INST, SIX, E, 
				 AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX,
				 R, RX, T, TX, FX, ES, ESX, IDC, HERITAGE, DEFS, DEF, BASE, 
				 TYPE, STYPE, CHAMPS, CHAMP
				 ;	

inh tns : NamespaceTable for
         PROGRAMME, ENTITES, ENTITE, DECL, FONCTION, BLOC, SIX, INSTS, INST,  
				 PARFS, PARF, PARFSX, TYPE, STYPE, CHAMPS, CHAMP,       
				 E, AFFX, A, AX, R, RX, T, TX, F, FX, ES, ESX,
         DEFS, DEF, BASE, IDC, HERITAGE 
				 ;	

syn niS : NamespaceInfo for
				 IDC
				 ;

syn acc : Integer for
				 ACCES
				 ;

inh accH : Integer for
         DEF
				 ;

inh klass : Klass for
         PROGRAMME, ENTITES, ENTITE, DECL, FONCTION, BLOC, SIX, INSTS, INST,  
         E, AFFX, A, AX, R, RX, T, TX, F, FX, ES, ESX,
         DEFS, DEF, BASE,
				 IDC
         ;

syn klassS : Klass for 
         IDC, HERITAGE
				 ;

syn ci : ConstructorInfo for
         BASE
				 ;

inh regH : Register for
         FX
				 ;

-- Ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for AASM;
inh tds_asm : VariableTable for AASM;
inh namespace_asm : NamespaceInfo for AASM;
inh mach_asm : AbstractMachine for AASM;
inh listeni_asm : List<NamespaceInfo> for AASM;

--Terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar tantque is "while";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
--Objet.
sugar ref is "ref" ;
sugar out is "out";
sugar namespace is "namespace";
sugar using is "using";
sugar class is "class";
sugar public is "public" ;
sugar private is "private";
sugar dpts is "\:";
sugar bool is "bool";
sugar true is "true";
sugar false is "false";
sugar this is "this";
sugar new is "new" ;
sugar null2 is "null";
sugar base is "base" ;
--Operateurs et idents.
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";


-- pour les instructions en assembleur TAM 'inline'
compil AASM;

-- (1) : REGLES DE PRODUCTION
PROGRAMME -> #attENTITES ENTITES #attPROGRAMME;
global
   machine : AbstractMachine;
   ni : NamespaceInfo;
	 listeNi : NamespaceInfoList;
   tfun : FunctionTable;

-- Transmission de la machine cible  (choisie par l'option -m au lancement) 
#attENTITES {
local
do
  machine := PROGRAMME^source.getMachine();
  if machine = null then
    error(NO_MACH, PROGRAMME^source.getMachName());
  else
    ENTITES^machine := machine;
  end
  ENTITES^tvar := new VariableTable();
  tfun := new FunctionTable();
	ENTITES^tfun := tfun;
  ENTITES^talias := new AliasTable();
	ENTITES^tklass := new KlassTable();
	ENTITES^tns := new NamespaceTable();
	ENTITES^machine := machine;
	ni := new DefaultNamespaceInfo();
	ENTITES^ni := ni;
	listeNi := new NamespaceInfoList();
  ENTITES^listeNi := listeNi;
	ENTITES^indentation := 0;
  ENTITES^klass := null;
end
}
-- Ecrit le code dans un fichier
#attPROGRAMME {
local
  fi : SymbolInfo;
  t : Type;
do
  fi := tfun.lookup("main", ni, listeNi, new ArrayList<Type>());
	if (fi = null) then
    error(NO_MAIN);
	else
	  match fi 
		with FunctionInfo then
		  t := fi.returnType();
	    match t
		  with IntegerType then
		  else
		    error(MAIN_NOT_INT);
		  end
		end
	end
	machine.writeCode(PROGRAMME^source.getFileName(), ENTITES^code); 
  write("\nEtat final des registres (L est une anomalie) :\n" + machine.logRegisters());
end
}

-- (2)
ENTITES -> #attENTITES ;

-- Fin du code.
#attENTITES {
local
do
  ENTITES^code := "";
end
}

-- (3)
ENTITES -> #attENTITE ENTITE #attENTITES1 ENTITES #attENTITES ;

-- Passage des attributs hérités.
#attENTITE {
local
do
  ENTITE^machine := ENTITES^machine;
	ENTITE^tvar := ENTITES^tvar;
	ENTITE^tfun := ENTITES^tfun;
	ENTITE^talias := ENTITES^talias;
	ENTITE^ni := ENTITES^ni;
	ENTITE^indentation := ENTITES^indentation + 1;
  ENTITE^listeNi := ENTITES^listeNi;
  ENTITE^klass := ENTITES^klass;
end
}

-- Transmission des TDS mise à jour après ENTITE à ENTITES1.
-- (La transmission de ENTITES à ENTITE se fait, normalement, automatiquement).
#attENTITES1 {
local
do
  ENTITES1^tvar := ENTITES^tvar;
	ENTITES1^machine := ENTITES^machine;
	ENTITES1^ni := ENTITES^ni;
	ENTITES1^listeNi := ENTITES^listeNi;
  ENTITES1^klass := ENTITES^klass;
	ENTITES1^indentation := ENTITES^indentation + 1 ;
end
}

-- Concaténation et passage du code.
#attENTITES {
local
do
  ENTITES^code := ENTITE^code + ENTITES1^code;
end
}

---------------------------------------------
-------- DEFINITION D'UN NOM DE TYPE --------
--      (commence avec une majuscule)      --
---------------------------------------------

-- (4)
ENTITE -> typedef #attTYPE TYPE identc pv #attENTITE ;

#attTYPE {
local
do
  TYPE^talias := ENTITE^talias;
  TYPE^tklass := ENTITE^tklass;
	TYPE^ni := ENTITE^ni;
	TYPE^listeNi := ENTITE^listeNi;
	TYPE^indentation := ENTITE^indentation + 1;
end
}

-- Ajout de identc à la table des alias.
-- Vérifie que identc n'est pas déjà utilisé (par une variable, une fonction ou un autre alias).
#attENTITE {
local
  info : SymbolInfo;
  infoVar : VariableInfo;
	t : Type;
	ta : AliasTable;
do
  ta := ENTITE^talias;
  info := ENTITE^tvar.lookup(identc^txt, ENTITE^ni, ENTITE^listeNi, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, identc^txt);
  else
     info := ENTITE^tfun.lookup(identc^txt, ENTITE^ni, ENTITE^listeNi, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
    if info != null then
        error(IDENT_TAKEN, identc^txt);
     -- Sinon, on peut ajouter le nouveau type à la TDS.
    else
		  -- Vérification dans la table des alias.
			t := ta.lookup(identc^txt, ENTITE^ni, ENTITE^listeNi);
			if (t != null) then
			  error(IDENT_TAKEN, identc^txt);
      else
        ta.insert(identc^txt, TYPE^type, ENTITE^ni);
			end
    end
  end  
	-- Pas de code pour cette RP.
  ENTITE^code := ENTITE^machine.generateComment("(4) TypeDef: " + identc^txt + " (" + TYPE^type + ")", "");
end
}

---------------------------------------------------------
-- DEFINITION D'UNE VARIABLE GLOBALE OU D'UNE FONCTION --
--            (commence par une minuscule)             --
---------------------------------------------------------

-- (5)
ENTITE -> #attTYPE TYPE ident #attDECL DECL #attENTITE; 

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := ENTITE^talias;
  TYPE^tklass := ENTITE^tklass;
	TYPE^ni := ENTITE^ni;
	TYPE^listeNi := ENTITE^listeNi;
	TYPE^indentation := ENTITE^indentation + 1; 
end
}

-- Attributs inh de DECL.
-- On n'ajoute pas encore la variable / fonction à la table car on ne sait pas encore la nature.
-- Passage du nom et du type retour pour la récursivité en cas de declaration de fonction.
#attDECL {
local
  info : SymbolInfo;
	t : Type;
do
  DECL^nom := ident^txt;
  DECL^typeH := TYPE^type;
  DECL^tvar := ENTITE^tvar;
  DECL^tfun := ENTITE^tfun;
	DECL^talias := ENTITE^talias;
	DECL^machine := ENTITE^machine;
	DECL^ni := ENTITE^ni;
  DECL^listeNi := ENTITE^listeNi;
  DECL^indentation := ENTITE^indentation + 1;
  DECL^klass := ENTITE^klass;
end
}

-- Attributs syn de ENTITE.
-- On effectue ici la vérification de disponibilité du nom,
-- et on effectue l'ajout dans la TDS appropriée.
#attENTITE {
local
  tv : VariableTable;
	tf : FunctionTable;
	fi : FunctionInfo;
  info : SymbolInfo;
	t : Type;
	b : boolean;
	code : String;
do
--write("À la fin de (5)\n");
  fi := DECL^funInfo;
  tv := ENTITE^tvar;
	tf := ENTITE^tfun;
  -- Si l'ident apprait dans tvar ou talias, on a une erreur.
	info := ENTITE^tvar.lookup(ident^txt, ENTITE^ni, ENTITE^listeNi, true);
  code := DECL^code;
	if (info != null) then
    error(IDENT_TAKEN, ident^txt);
  else
		t := ENTITE^talias.lookup(ident^txt, ENTITE^ni, ENTITE^listeNi);
	--write("(5) info not null\n");
		if (t!= null) then
		  error(ALREADY_AN_ALIAS, ident^txt);
	  else
		--write("(5) ident not already taken for type\n");
		  --info := tf.lookup(ident^txt, ENTITE^ni, true);
      if (fi = null) then
			--write("(5) It's a variable declaration\n");
	      -- On a une variable.
        if (tf.exists(ident^txt, ENTITE^ni, ENTITE^listeNi, fi)) then
				  -- Dans ce cas, il ne faut pas que l'ident soit pris par une fonction.
          error(IDENT_TAKEN, ident^txt);
        else
				--write("(5) Add variable \\o/\n");
				  -- Si ce n'est pas le cas, on peut add la variable à la tvar.
          tv.insert(ident^txt, TYPE^type, ENTITE^ni);
			  	write("(5) Ajout de " + ident^txt + " dans le ns " + ENTITE^ni.name() + "\n");					
					code := ENTITE^machine.generateComment("(5) Variable declaration:", "") + code ;
				end
	   else
		   code := ENTITE^machine.generateComment("(5) Function declaration:", "")
			       + code ;
	    end
    end
	end
  -- Passage du code généré par DECL à ENTITE.
--write("Code (5) : " + DECL^code + "\n");
  ENTITE^code := code + ENTITE^machine.generateComment("(5) End of declaration.", "");
end
}


-- (6) : VARIABLE
DECL -> pv #attDECL;

-- Attributs syn de DECL.
-- On génère le code d'allocation mémoire pour cette variable.
-- funInfo est à null car il ne s'agit pas d'une fonction.
#attDECL {
local
	code : String;
do
	code := DECL^machine.generateAllocateInStack(DECL^typeH);
  DECL^code := code;
	DECL^funInfo := null;
--write("(6) fin, code: " + code + "\n");
end
}


-- FONCTION (7)
DECL -> #attFONCTION FONCTION #attDECL;

-- Attributs inh de FONCTION.
-- On fait passer typeH qui servira à créer le functionInfo.
#attFONCTION {
local
do
  FONCTION^nom := DECL^nom;
  FONCTION^typeH := DECL^typeH;
	FONCTION^tvar := DECL^tvar;
	FONCTION^talias := DECL^talias;
	FONCTION^tfun := DECL^tfun;
	FONCTION^machine := DECL^machine;
	FONCTION^ni := DECL^ni;
	FONCTION^listeNi := DECL^listeNi;
  FONCTION^indentation := DECL^indentation + 1;
  FONCTION^klass := DECL^klass;
end
}

-- "Mise à jour" des TDS de DECL.
#attDECL {
local
	code : String;
do
	code := FONCTION^code;
  -- Passage du code de declaration de la fonction à DECL.
  DECL^code := code;
--write("Code (7) : " + code + "\n");
	-- Passage du functionInfo.
	DECL^funInfo := FONCTION^funInfo;
end
}


-- (8)
FONCTION -> #attPARFS paro PARFS parf #attBLOC BLOC #attFONCTION ;
global
	tvparams : VariableTable;

-- Init des attributs hérités pour PARFS.
#attPARFS {
local
do
	tvparams := new VariableTable(FONCTION^tvar);
  -- On crée la TDSvar fille pour la passer à PARFS.
  PARFS^tvar := tvparams;
  PARFS^tfun := FONCTION^tfun;
	PARFS^talias := FONCTION^talias;
	-- Creation de la FunctionInfo avec le type retour.
  PARFS^funInfoH := new FunctionInfo(FONCTION^nom, FONCTION^typeH, FONCTION^ni, FONCTION^machine.functionReturn());
  -- Initialisation du compteur de parametres.
  PARFS^cParam := 0;
  PARFS^machine := FONCTION^machine;
	PARFS^ni := FONCTION^ni;
	PARFS^listeNi := FONCTION^listeNi;
  PARFS^indentation := FONCTION^indentation + 1;
--write("Regle (8)\n");
end
}

-- Ajout de la FunctionInfo à la tfun de BLOC.
-- Passage de la FunctionInfo à BLOC.
#attBLOC {
local
  tf : FunctionTable;
  fi : FunctionInfo;
do
  tf := FONCTION^tfun;
  fi := PARFS^funInfo;
  
	if (!(tf.insert(FONCTION^nom, fi))) then
		error(ALREADY_A_FUN_WITH_THAT_SIGN, FONCTION^nom);
	end
  
  BLOC^indentation := FONCTION^indentation + 1;
	BLOC^tfun := tf;
	BLOC^funInfoH := fi;
  BLOC^tvar := new VariableTable(tvparams);
	BLOC^talias := FONCTION^talias;
	BLOC^machine := FONCTION^machine;
	BLOC^ni := FONCTION^ni;
  BLOC^listeNi := FONCTION^listeNi;
  BLOC^klass := FONCTION^klass;
--write("Regle (8) : milieu\n");
end
}

-- Generation du code de la declaration de la fonction.
#attFONCTION {
local
	code : String;
do
	code := FONCTION^machine.generateFunctionDeclaration(PARFS^funInfo , BLOC^code);
--write("Code (8) : " + code + "\n");
  FONCTION^code := code; 
	FONCTION^funInfo := PARFS^funInfo;
end
}

-------------------------------------------
-------- PARAMETRES DE FONCTION -----------
-------------------------------------------

-- (9)
PARFS -> #attPARFS ;

#attPARFS {
local
do
--write("Regle (9)\n");
  -- fin de la liste des parmètres, on transmet le fi 'final'.
  PARFS^funInfo := PARFS^funInfoH ;
end
}


-- (10)
PARFS -> #attPARF PARF #attPARFSX PARFSX #attPARFS ;

-- Passage des params inh de PARF.
#attPARF {
local
  c : int;
do
--write("Regle (10)\n");
  -- Incrementation du compteur de parametres.
  c := PARFS^cParam + 1;
  PARF^cParam := c;
	-- Passage des tds.
  PARF^tvar := PARFS^tvar;
  PARF^tfun := PARFS^tfun;
  PARF^talias := PARFS^talias;
	PARF^machine := PARFS^machine;
	PARF^ni := PARFS^ni;
  PARF^listeNi := PARFS^listeNi;
-- Passage de c à PARFSX aussi.
	PARFSX^cParam := c;
  PARF^indentation := PARFS^indentation + 1;
end
}

-- Passage des tds à PARFSX.
#attPARFSX {
local
  fi : FunctionInfo ; 
do
  PARFSX^funInfoH := PARF^funInfo;
--write("(10) middle : passage tvar\n" + PARFS^tvar + "\n");
	PARFSX^tvar := PARFS^tvar;
	PARFSX^tfun := PARFS^tfun;
	PARFSX^talias := PARFS^talias;
	PARFSX^machine := PARFS^machine;
	PARFSX^ni := PARFS^ni;
  PARFSX^listeNi := PARFS^listeNi;
  PARFSX^indentation := PARFS^indentation + 1; 
end
}

-- On fait remonter la tvar contenant les params de la fonction.
-- Ainsi que le fi final.
#attPARFS {
local
do
  PARFS^funInfo := PARFSX^funInfo;
end
}

-- (11)
PARFSX -> #attPARFSX ;

-- Passage de FunctionInfo (transformation d'attribut hérité en attribut synthétisé).
#attPARFSX {
local
do
  PARFSX^funInfo := PARFSX^funInfoH ;
end
}

 
-- (12)
PARFSX -> virg #attPARF PARF #attPARFSX1 PARFSX #attPARFSX ;

-- Passages des attributs.
#attPARF {
local
  c : int;
do
  -- Incrementation du compteur de parametres.
  c := PARFSX^cParam + 1;
  PARF^cParam := c;
	-- Passage des tds.
  PARF^tvar := PARFSX^tvar;
  PARF^tfun := PARFSX^tfun;
  PARF^talias := PARFSX^talias;
	PARF^machine := PARFSX^machine;
	PARF^ni := PARFSX^ni;
  PARF^listeNi := PARFSX^listeNi;
  PARF^indentation := PARFSX^indentation + 1; 
  -- On passe aussi c à PARFSX1.
  PARFSX1^cParam := c;
end
}

-- Ajout du paramètre de PARF au functionInfo et passage à PARFSX1.
-- Passage des tds.
#attPARFSX1 {
local
do
  PARFSX1^funInfoH := PARF^funInfo;
	PARFSX1^tvar := PARFSX^tvar;
	PARFSX1^tfun := PARFSX^tfun;
	PARFSX1^talias := PARFSX^talias;
	PARFSX1^machine := PARFSX^machine;
	PARFSX1^ni := PARFSX^ni;
  PARFSX1^listeNi := PARFSX^listeNi;
  PARFSX1^indentation := PARFSX^indentation + 1; 
end
}

-- Transmission de FunctionInfo.
#attPARFSX {
local
do
  PARFSX^funInfo := PARFSX1^funInfo ;
end
}


-- (13)
PARF -> #attTYPE TYPE ident #attPARF; 

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := PARF^talias;
	TYPE^tklass := PARF^tklass;
	TYPE^ni := PARF^ni;
	TYPE^listeNi := PARF^listeNi;
	TYPE^indentation := PARF^indentation + 1; 
end
}


-- Ajout de ident à la TDS locale.
-- Vérifications concernant ident.
-- Passage du type.
#attPARF {
local
  tv : VariableTable;
	t : Type;
	info : SymbolInfo;
  fi : FunctionInfo;
do
--write("Regle (13) : " + TYPE^type + " " + ident^txt + " [" + PARF^ni.name() + "]" + "\n");
  
	tv := PARF^tvar;
  fi := PARF^funInfoH;
  -- Vérifications concernant ident.
  --info := tv.lookup(ident^txt, PARF^ni, false);
  -- Si identc est une clef dans la TDSvar, erreur.
  if (tv.exists(ident^txt, PARF^ni, PARF^listeNi, false)) then
    error(IDENT_TAKEN, ident^txt);
  else
    --info := PARF^tfun.lookup(ident^txt, PARF^ni, false);
    -- De même si identc est déjà utilisé dans la TDSfun.
    if (PARF^tfun.exists(ident^txt, PARF^ni, PARF^listeNi)) then
      error(IDENT_TAKEN, ident^txt);
    else
		  t := PARF^talias.lookup(ident^txt, PARF^ni, PARF^listeNi);
			-- De même dans talias.
			if (t != null) then
			  error(IDENT_TAKEN, ident^txt);
			else
			  -- Ajout de ident à la TDS locale et au fi.
			  fi.add(TYPE^type);
			--write("(13) ns = " + PARF^ni.name() + ", " + fi + "\n");
        tv.insert(ident^txt, new VariableInfo(TYPE^type, fi.displacement(PARF^cParam), PARF^ni));
      --write("(13) Après ajout :\n" + tv + "\n");      
			end
		end
  end
	PARF^funInfo := fi;
end
}


----------------------------------------------------------------
-------- LES TYPES (de base, noms, struct et pointeurs) --------
----------------------------------------------------------------

-- (14)
TYPE -> #attSTYPE STYPE #attPTRS PTRS #attTYPE;

-- Passage talias.
#attSTYPE {
local
do
  STYPE^talias := TYPE^talias;
	STYPE^tklass := TYPE^tklass;
  STYPE^ni := TYPE^ni;
	STYPE^listeNi := TYPE^listeNi;
	STYPE^indentation := TYPE^indentation + 1;
end
}

-- Passage du type de STYPE à PTRS pour qu'il "pointeurise" la chose.
#attPTRS {
local
do
  PTRS^typeH := STYPE^type;
	PTRS^indentation := TYPE^indentation + 1;
end
}

-- Recuperation du type final de l'expression.
#attTYPE {
local
do
  TYPE^type := PTRS^type;
end
}


-- Des * pour definir un pointeur (15)
PTRS -> #attPTRS ;

-- Passage de l'attribut hérité à celui synthétisé. 
#attPTRS {
local
do
  PTRS^type := PTRS^typeH;
end
}


-- (16)
PTRS -> mult #attPTRS1 PTRS #attPTRS ;

-- Passage du type une foix la couche de pointeur ajoutée.
#attPTRS1 {
local
do
  PTRS1^typeH := new PointerType(PTRS^typeH);
	PTRS1^indentation := PTRS^indentation + 1;
end
}

-- Passage de l'attribut type synthétisé.
#attPTRS {
local
do
  PTRS^type := PTRS1^type;
end
}


-- Types de base (17)
STYPE-> void #attSTYPE ;

#attSTYPE {
local
do
  STYPE^type := new VoidType();
end
}


-- (18)
STYPE-> int #attSTYPE ;

#attSTYPE {
local
do
  STYPE^type  := new IntegerType();
end
}


-- (19)
STYPE-> char #attSTYPE ;

#attSTYPE {
local
do
  STYPE^type  := new CharacterType();
end
}

-- (20) : Nom de type (commence par une majuscule) 
STYPE -> identc #attSTYPE ;

#attSTYPE {
local
  typeRech : Type;
do
  typeRech := STYPE^talias.lookup(identc^txt, STYPE^ni, STYPE^listeNi);
  -- Si identc n'est pas une clef dans la TDSvar, erreur.
  if (typeRech = null) then
	  typeRech := STYPE^tklass.lookup(identc^txt, STYPE^ni, STYPE^listeNi);
	  if (typeRech = null) then
	    error(IDENT_UNDEFINED, identc^txt);
    end
	end
  STYPE^type := typeRech;
end
}


------------------------
------ STRUCTURES ------
------------------------

-- (21)
STYPE -> struct aco #attCHAMPS CHAMPS acf #attSTYPE ;

-- Création de la liste de champs qui servira à construire le type.
#attCHAMPS {
local
do
  CHAMPS^champs := new StructFields();
	CHAMPS^talias := STYPE^talias;
	CHAMPS^tklass := STYPE^tklass;
	CHAMPS^ni := STYPE^ni;
	CHAMPS^listeNi := STYPE^listeNi;
	CHAMPS^indentation := STYPE^indentation + 1;
end
}

-- On récupère la liste des champs, synthétisée par CHAMPS,
-- pour créer le type.
#attSTYPE {
do
  STYPE^type := new StructType(CHAMPS^champsS);
end
}


-- (22)
CHAMPS -> #attCHAMPS ;

-- Passage de l'attribut hérité à celui synthétisé.
#attCHAMPS {
local
do
  CHAMPS^champsS := CHAMPS^champs;
end
}


-- (23) : Un nom de champ commence par une minuscule.
CHAMPS -> #attCHAMP CHAMP #attCHAMPS1 CHAMPS #attCHAMPS ;

-- Passage talias.
#attCHAMP {
local
do
  CHAMP^talias := CHAMPS^talias;
	CHAMP^tklass := CHAMPS^tklass;
	CHAMP^ni := CHAMPS^ni;
	CHAMP^listeNi := CHAMPS^listeNi;
	CHAMP^indentation := CHAMPS^indentation + 1;
end
}

#attCHAMPS1 {
local
  c : StructFields;
do
  c := CHAMPS^champs;
  if (c.exists(CHAMP^nomS)) then
	  -- si un champ porte déjà ce nom : erreur.
    error(IDENT_TAKEN, CHAMP^nomS);
  else
	  -- Sinon, on ajoute le champ au StructFields.
    c.insert(CHAMP^nomS,CHAMP^type);
  end
	-- On passe le StructFields à CHAMPS1.
	CHAMPS1^champs := c;
	CHAMPS1^indentation := CHAMPS^indentation + 1;
end
}

-- Passage du StructFields.
#attCHAMPS {
local
do
  CHAMPS^champsS := CHAMPS1^champsS;
end
}


-- (24) 
CHAMP -> #attTYPE TYPE ident pv #attCHAMP ;

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := CHAMP^talias;
	TYPE^tklass := CHAMP^tklass;
	TYPE^ni := CHAMP^ni;
	TYPE^listeNi := CHAMP^listeNi;
	TYPE^indentation := CHAMP^indentation + 1;
end
}

-- Passage des attributs qui serviront à créer le champ.
#attCHAMP {
local
do
  CHAMP^nomS := ident^txt;
  CHAMP^type := TYPE^type;
end
}


----------------------------------------------------------------
----------- CORPS DE FONCTION ET BLOC D'INSTRUCTIONS -----------
----------------------------------------------------------------

-- (25)
BLOC -> aco #attINSTS INSTS acf #attBLOC ;

-- Probablement inutile, mais passage des TDS de BLOC à INSTS.
-- Ainsi que la FunctionInfo de la fonction.
#attINSTS {
local
do
--write("Regle (25)\n");
  INSTS^tvar := BLOC^tvar;
  INSTS^tfun := BLOC^tfun;
	INSTS^talias := BLOC^talias;
	INSTS^machine := BLOC^machine;
  INSTS^funInfoH := BLOC^funInfoH;
	INSTS^ni := BLOC^ni;
  INSTS^listeNi := BLOC^listeNi;
  INSTS^indentation := BLOC^indentation + 1 ;
  INSTS^klass := BLOC^klass;
end
}

-- Generation du flush de fin de bloc.
-- Passage du code généré par les INSTS (et le flush) à BLOC.
#attBLOC {
local
  code : String;
do
  code := BLOC^machine.generateComment("(25) Bloc:", "")
				+ INSTS^code
				+ BLOC^machine.generateComment("(25) End of bloc.", "");
--write("Code (25) [pre-flush] : " + code + "\n");
  code := code + BLOC^machine.generateFlush(BLOC^tvar);
--write("Code (25) : " + code + "\n");
  BLOC^code := code;
end
}



-- Instructions
-- (26) : Fin des instructions du bloc.
INSTS -> #attINSTS ;

-- Initialisation de l'attribut code (chaine vide).
#attINSTS {
local
do
--write("Regle (26)\n");
  INSTS^code := INSTS^machine.generateComment("(26) End of instructions for this bloc.", "\t");
end
}


-- (27)
INSTS -> #attINST INST #attINSTS1 INSTS #attINSTS ;

-- Passage du type retour de la fonction.
#attINST {
local
do
--write("Regle (27)\n");
  INST^funInfoH := INSTS^funInfoH;
	INSTS1^funInfoH := INSTS^funInfoH;
	INST^tvar := INSTS^tvar;
	INST^tfun := INSTS^tfun;
	INST^talias := INSTS^talias;
	INST^machine := INSTS^machine;
	INST^ni := INSTS^ni;
  INST^listeNi := INSTS^listeNi;
  INST^indentation := INSTS^indentation + 1 ;
  INST^klass := INSTS^klass;
end
}

-- Passage des TDS de INST à INSTS1.
#attINSTS1 {
local
do
--write("Regle (27) : milieu : " + INST^code + "\n");
  INSTS1^tvar := INSTS^tvar;
	-- tfun, talias et machine directement hérité de INSTS.
  INSTS1^tfun := INSTS^tfun; 
	INSTS1^talias := INSTS^talias;
	INSTS1^machine := INSTS^machine;
	INSTS1^ni := INSTS^ni;
  INSTS1^listeNi := INSTS^listeNi;
  INSTS1^indentation := INSTS^indentation + 1 ;
  INSTS1^klass := INSTS^klass;
end
}

-- Concaténation des codes et passage à INSTS.
#attINSTS {
local
	code : String;
do
	code := INSTS^machine.generateComment("(27) New instruction:", "\t")
	      + INST^code
				+ INSTS^machine.generateComment("(27) End of instruction.", "\t")
				+ INSTS1^code;
  INSTS^code := code;
--write("Regle (27) : fin : " + code + "\n");
end
}


-- (28) : Declaration de variable locale avec ou sans init. 
INST -> #attTYPE TYPE ident #attAFFX AFFX pv #attINST;

-- Passage de la table des alias.
#attTYPE {
local
do
--write("Regle (28)\n");
  TYPE^talias := INST^talias;
	TYPE^tklass := INST^tklass;
	TYPE^ni := INST^ni;
	TYPE^listeNi := INST^listeNi;
	TYPE^indentation := INST^indentation + 1 ;
end
}

-- Passage des attributs hérités de AFFX. 
#attAFFX {
local
do
--write("(28) So you declarin' some " + TYPE^type + ", named : " + ident^txt + "...\n"); 
  AFFX^machine := INST^machine;
	AFFX^tvar := INST^tvar;
	AFFX^tfun := INST^tfun;
	AFFX^talias := INST^talias;
	-- Une affectation est possible.
	AFFX^affPossible := true;
		-- Le type de cette affectationn doit être celui de TYPE.
	AFFX^typeH := TYPE^type;
	AFFX^ni := INST^ni;
  AFFX^listeNi := INST^listeNi;
  AFFX^indentation := INST^indentation + 1 ;
  AFFX^klass := INST^klass;
end
}

-- Génération du code
-- On vérifie si on a TYPE ident := X; ou TYPE ident;
-- Dans le cas où l'affectation existe, on vérifie la compatibilité des types.
#attINST {
local
  nom : String;
  code : String;
	info : SymbolInfo;
	t : Type;
	tv : VariableTable;
	si : SymbolInfo;
do
--write("(28) Debut de la fin; nom : " + ident^txt + "\n");
  nom := ident^txt;
  tv := INST^tvar;
  --info := INST^tvar.lookup(nom, INST^ni, true);
	code := "";
  -- Si ident est une clef dans la TDSvar, erreur.
  if (INST^tvar.exists(nom, INST^ni, INST^listeNi, true)) then
     error(IDENT_TAKEN, nom);
  else
    --info := INST^tfun.lookup(nom, INST^ni, false);
    -- De même si identc est déjà utilisé dans la TDSfun.
    if (INST^tfun.exists(nom, INST^ni, INST^listeNi)) then
      error(ALREADY_A_FUNCTION_IDENT, nom);
		else
		  t := INST^talias.lookup(nom, INST^ni, INST^listeNi);
			-- De même pour la talias.
			if (t != null) then 
			  error(ALREADY_AN_ALIAS, nom);
			else
			--write("(28) [" + INST^ni + "] " + ident^txt + " (" + TYPE^type + ") n'existe pas\n");
		    -- Sinon, on ajoute cet id à la tdsvar.
	   	  tv.insert(nom, TYPE^type, INST^ni);
				code := INST^machine.generateComment("(28) Allocate in stack:", "\t\t")
				      + INST^machine.generateAllocateInStack(TYPE^type)
							+ INST^machine.generateComment("(28) End of allocation.", "\t\t");
			--write("(28) Code (allocation) : \n" + code + "\n");
			--write("(28) Après allocation : \n" + INST^machine.logRegisters() + "\n");
			end
    end
  end 
	if !(AFFX^estVar) then
	--write("(28) C'est une variable\n");
    -- On a une affectation.	
		-- Verification de types inutile, elle est faite dans AFFX.
		-- On génère le code pour stocker la valeur du registre 
		-- de AFFX dans la variable qu'on vient de déclarer.
		si := tv.lookup(ident^txt, INST^ni, INST^listeNi, true);
		match si
		with VariableInfo then
		  code := code
			      + INST^machine.generateComment("(28) Expression to affect:", "\t\t")
			      + AFFX^code
						+ INST^machine.generateComment("(28) End of Expression to affect, affectation:" ,"\t\t")
						+ INST^machine.generateStoreVariable(si, AFFX^reg)
						+ INST^machine.generateComment("(28) End of affectation.", "\t\t");
		--write("(28) SI : " + si + "; Code: " + code + "\n");
		else
		  error(SHOULD_NOT_HAPPEN_SI_NOT_VI);
		end
	end
	INST^code := INST^machine.generateComment("(28) Variable declaration:", "\t")
	           + code
						 + INST^machine.generateComment("(28) End of variable declaration.", "\t");
end
}


-- (29) : Instruction expression (affectation et appel de procedure)
INST -> #attE E pv #attINST ;

#attE {
local
do
	E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
	E^ni := INST^ni;
  E^listeNi := INST^listeNi;
  E^indentation := INST^indentation + 1 ;
  E^klass := INST^klass;
end
}

#attINST {
local
do
  write("(29) Code de E :\n" + E^code + "\n"); 
	-- Remontée du code.
	INST^code := INST^machine.generateComment("(29) Expression:", "\t")
	           + E^code
						 + INST^machine.generateComment("(29) End of expression.", "\t");
end
}


-- (30) : Bloc d'instructions
INST ->  #attBLOC BLOC #attINST;

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#attBLOC {
local
	tfille : VariableTable;
do
	tfille := new VariableTable(INST^tvar);
	BLOC^tvar := tfille;
	BLOC^funInfoH := INST^funInfoH;
  BLOC^ni := INST^ni;
  BLOC^listeNi := INST^listeNi;
  BLOC^indentation := INST^indentation + 1 ;
  BLOC^klass := INST^klass;
end
}

-- La tvar de INST n'est pas modifiée par BLOC.
#attINST {
local
do
	-- Passage du code de BLOC à INST.
	-- Les instructions de fin de bloc (flush etc) sont générés dans la RP de BLOC.
	INST^code := BLOC^code;
end
}


-- (31) : Conditionnelle
INST -> si paro #attE E parf #attBLOC BLOC #attSIX SIX #attINST;

#attE {
local
do
--write("(31) Avant la condition.\n");
	E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
	E^ni := INST^ni;
	E^listeNi := INST^listeNi;
	E^indentation := INST^indentation + 1 ;
  E^klass := INST^klass;
end
}

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#attBLOC {
local
	tfille : VariableTable;
do
--write("(31) Après la condition,\n     Type de la condition : " + E^type + "\n");
	BLOC^funInfoH := INST^funInfoH;
	tfille := new VariableTable(INST^tvar);
	BLOC^tvar := tfille;
	BLOC^tfun := INST^tfun;
	BLOC^talias := INST^talias;
	BLOC^machine := INST^machine;
	BLOC^ni := INST^ni;
  BLOC^listeNi := INST^listeNi;
  BLOC^indentation := INST^indentation + 1 ;
  BLOC^klass := INST^klass;
end
}

-- Transmission des TDS 'parentes' à SIX.
#attSIX {
local
do
	SIX^funInfoH := INST^funInfoH;
	SIX^tvar := INST^tvar;
	SIX^tfun := INST^tfun;
	SIX^talias := INST^talias;
	SIX^machine := INST^machine;
	SIX^ni := INST^ni;
  SIX^listeNi := INST^listeNi;
  SIX^indentation := INST^indentation + 1 ;
  SIX^klass := INST^klass;
end
}

#attINST {
local
	code : String;
	codeTHEN : String;
	codeELSE : String;
do
	-- Génération du code pour une conditionnelle.
	code := "";
	codeTHEN := BLOC^code;
	codeELSE := SIX^code;
	-- On vérifie que le type dans la conditionnelle est bien un booléen (prec. un entier)
	match E^type
	with BooleanType then
		-- Si c'est le cas, on génère le code
		code := INST^machine.generateComment("(31) IF THEN ELSE:", "\t") 
		      + INST^machine.generateComment("(31) Expression for condition:", "\t\t")
		      + E^code
					+ INST^machine.generateComment("(31) End of condition.", "\t\t");
		codeTHEN := INST^machine.generateComment("(31) Bloc THEN:", "\t\t")
		          + codeTHEN
							+ INST^machine.generateComment("(31) End bloc THEN.", "\t\t");
		if (codeELSE = "") then 
		  codeTHEN := codeTHEN + INST^machine.generateComment("(31) No ELSE.", "\t\t");
		else
		  codeELSE := INST^machine.generateComment("(31) Bloc ELSE:", "\t\t")
		          + codeTHEN
							+ INST^machine.generateComment("(31) End bloc ELSE.", "\t\t");
		end
		code := code 
		      + INST^machine.generateIfThenElse(E^reg,BLOC^code,SIX^code)
	        + INST^machine.generateComment("(31) END IF THEN ELSE.", "\t");
	else
		-- Sinon, on renvoie une erreur
		error(TYPE_CONDITION);
	end
	INST^code := code ;
end
}


-- (32)
SIX -> sinon #attBLOC BLOC #attSIX;

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
-- Passage du type retour de la fonction.
#attBLOC {
local
	tfille : VariableTable;
do
	BLOC^funInfoH := SIX^funInfoH;
	tfille := new VariableTable(SIX^tvar);
	BLOC^tvar := tfille;
	BLOC^tfun := SIX^tfun;
	BLOC^talias := SIX^talias;
	BLOC^machine := SIX^machine;
	BLOC^ni := SIX^ni;
  BLOC^listeNi := SIX^listeNi;
  BLOC^indentation := SIX^indentation + 1 ; 
  BLOC^klass := SIX^klass;
end
}

-- Passage du code du BLOC à SIX.
#attSIX {
local
do
	SIX^code := BLOC^code;
end
}


-- (33)
SIX -> #attSIX ;
-- Rien à faire pour la gestion des TDS.
-- Génération d'une chaine de caractère vide.
#attSIX {
local
do
	SIX^code := "";
end
}


-- (31.5) : Boucle while
INST -> tantque paro #attE E parf #attBLOC BLOC #attINST;

#attE {
local
do
	E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
	E^ni := INST^ni;
	E^listeNi := INST^listeNi;
	E^indentation := INST^indentation + 1 ;
end
}

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#attBLOC {
local
	tfille : VariableTable;
do
	BLOC^funInfoH := INST^funInfoH;
	tfille := new VariableTable(INST^tvar);
	BLOC^tvar := tfille;
	BLOC^tfun := INST^tfun;
	BLOC^talias := INST^talias;
	BLOC^machine := INST^machine;
	BLOC^ni := INST^ni;
	BLOC^listeNi := INST^listeNi;
  BLOC^indentation := INST^indentation + 1 ;
end
}

#attINST {
local
	code : String;
do
	-- Génération du code pour une boucle tant que.
	code := "";
	-- On vérifie que le type dans la conditionnelle est bien un booléen (prec. un entier)
	match E^type
	with BooleanType then
		-- Si c'est le cas, on génère le code
    code := INST^machine.generateWhile(E^code, E^reg, BLOC^code);
	else
		-- Sinon, on renvoie une erreur
		error(TYPE_CONDITION);
	end
	INST^code := code ;
end
}


-- (34) : Retour de fonction.
INST ->  retour #attE E pv #attINST ;

#attE {
local
do
--write("Regle (34)\n");
	E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
	E^ni := INST^ni;
  E^listeNi := INST^listeNi;
  E^indentation := INST^indentation + 1 ; 
  E^klass := INST^klass;
end
}

-- Vérification que E est du type retour de la fonction.
#attINST {
local
	typeRet : Type;
	code : String;
do
--write("(34) Début de la fin\n");
	
	if (INST^funInfoH = null) then
	--write("(34) funInfoH est null !\n");
	end

	typeRet := INST^funInfoH.returnType();
	-- Si typeRet ne correspond pas à E^type
	-- alors erreur.
--write("(34) E^type = " + E^type + "; fi^type = " + typeRet + "\n");
	if (!typeRet.isEqualTo(E^type)) then
		error(TYPE_NOT_COMPATIBLE);  
	end
--write("(34) Milieu de la fin : " + E^reg.debug() + "\n");
	--Génération du code de retour de la fonction et du flush.
	code := INST^machine.generateComment("(34) Return:","\t") 
	      + INST^machine.generateComment("(34) Expression to return:","\t\t")
				+ E^code
				+ INST^machine.generateComment("(34) End of expression. Flush:","\t\t")
				+ INST^machine.generateFlush(INST^tvar)
				+ INST^machine.generateComment("(34) End of flush. Function return:","\t\t")
	    	+ INST^machine.generateFunctionReturn(INST^funInfoH, E^reg)
				+ INST^machine.generateComment("(34) End of return.","\t");
--write("Code (34) : " + code + "\n");
	INST^code := code;
end
}


-----------------------------------------------------------------------
--------------------------- LES EXPRESSIONS ---------------------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

-- (35)
E -> #attA A #attAFFX AFFX #attE;

#attA {
local
do
  --write("(35) Début.\n");
	A^machine := E^machine;
	A^tvar := E^tvar;
	A^tfun := E^tfun;
	A^talias := E^talias;
	A^ni := E^ni;
  A^listeNi := E^listeNi;
  A^indentation := E^indentation + 1 ;
  A^klass := E^klass;
end
}

-- Passage des attributs hérités de AFFX.
-- Maj d'un attribut pour AFFX signalant si A est, ou non, une variable.
-- Maj de l'attribut typeH de AFFX afin de tester que les types correspondent.
#attAFFX {
local
do
--write("Regle (35) : milieu : " + A^code + "\n");
	AFFX^machine := E^machine;
	AFFX^tvar := E^tvar;
	AFFX^tfun := E^tfun;
	AFFX^talias := E^talias;
	AFFX^ni := E^ni;
  AFFX^listeNi := E^listeNi;
  -- L'affectation est possible si A est une variable.
	AFFX^affPossible := A^estVar;
	-- Le type de cette afectation doit être le même que A.
	AFFX^typeH := A^type;
  AFFX^indentation := E^indentation + 1 ;
  AFFX^klass := E^klass;
--write("(35) Code de A :\n" + A^code + "\n");
end
}

-- Génération du code de l'affectation.
-- Passage des attributs syn de E.
#attE {
local
	code : String;
	reg : Register;
	estVar : boolean;
	vi : VariableInfo;
do
--write("(35) Après AFFX, type de A : " + A^type + "\n");
--write("(35) Code de AFFX :\n" + AFFX^code + "\n");
  reg := null;
	code := A^code;
	estVar := false;
	vi := null;
	-- On n'a pas d'affectation à droite.
	if (AFFX^estVar) then
		--write("(35) AFFX est vide.\n");
		-- E peut dans ce cas représenter une variable.
		estVar := true ;
		vi := A^vi ;
		reg := A^reg ;
		code := E^machine.generateComment("(35) Not an affectation.", "\t\t")
		      + code;
		-- regAdr ne sera pas use, on peut changer le statut.
		if (!(A^regAdr = null)) then
		  A^regAdr.setStatus(2);
		end
	else
		if (A^estVar) then
			-- E ne représente pas de variable.
			estVar := false ;
			vi := null ;
			-- On génère le code de l'affectation.
			-- La compatibilité des types est effectuée dans AFFX.
		--write("(35) Code else : " + code + "\n");
			code := E^machine.generateComment("(35) Affectation, left part:", "\t\t")
			      + code
			      + E^machine.generateComment("(35) End of left part, right part:", "\t\t")
						+ AFFX^code
						+ E^machine.generateComment("(35) End of right part, store:", "\t\t");
			if (A^regAdr = null) then
			  code := code  
				      + E^machine.generateStoreVariable(A^vi,AFFX^reg)
						  + E^machine.generateComment("(35) End of store (direct).", "\t\t");
			else 
			  A^regAdr.unlock();
				A^reg.setStatus(2);
			  code := code 
				      + E^machine.generateStoreInHeap(A^regAdr, 0, AFFX^reg)
							+ E^machine.generateComment("(35) End of store (at the address indicated).", "\t\t");
			end
			reg := AFFX^reg;
		else
			error(LEFT_PART_NOT_VARIABLE);
		end
	end
--write("(35) reg = " + reg.debug() + "\n");
--write("(35) type = " + A^type + "\n");
--write("(35) Type de A : " + A^type + "\n");
	E^type := A^type;
	E^reg := reg;
	E^estVar := estVar;
	E^vi := vi;
	E^code := code;
--write("(35) Code de l'affectation : " + code + "\n");
end
}


-- (36) : Affectation
AFFX -> affect #attA A #attAFFX ;

#attA {
local
do
--write("(36) Affectation.");
	A^machine := AFFX^machine;
	A^tvar := AFFX^tvar;
	A^tfun := AFFX^tfun;
	A^talias := AFFX^talias;
	A^ni := AFFX^ni;
  A^listeNi := AFFX^listeNi;
  A^indentation := AFFX^indentation + 1 ;
  A^klass := AFFX^klass;
end
}

-- Vérifie que l'affectation est valide :
--   - la partie à gauche du = doit être une variable,
--   - le type de A doit être compatible avec celui de AFFX.
#attAFFX {
local
do
--write("(36) Après A.\n");
	if !(AFFX^affPossible) then
		error(LEFT_PART_NOT_VARIABLE );
	else
		-- Verification d'égalité des types.
		if !(A^type.isEqualTo(AFFX^typeH)) then
		error(TYPE_NOT_COMPATIBLE);    
		end
	end
	-- On met l'attribut estVar de AFFX à faux car la règle 
	-- appelante ne pourra pas être une variable suite à cette RP.
	-- Le registre et le type de AFFX sont ceux de A.
	if (A^regAdr != null) then
	  write("(35) Unlocking " + A^regAdr.debug() + "\n");
		A^regAdr.unlock();
	  A^regAdr.setStatus(2);
	end
	AFFX^estVar := false;
	AFFX^reg := A^reg;
	AFFX^type := A^type;
	AFFX^code := A^code;
--write("(36) Code gauche affectation : " + A^code + "\n");
end
}


-- (37)
AFFX -> #attAFFX ;

-- On met estVar à true car cette RP n'empeche pas la representation d'une var.
-- code est vide, reg est null, type aussi.
#attAFFX {
local
do
--write("Regle (37)\n");
	AFFX^estVar := true ;
	AFFX^reg := null;
	AFFX^type := null;
	AFFX^code := "";
end
}


-- (38) : Relation
A -> #attR R #attAX AX #attA ;

#attR {
local
do
  --write("Regle (38)\n");
	R^machine := A^machine;
	R^tvar := A^tvar;
	R^tfun := A^tfun;
	R^talias := A^talias;
	R^ni := A^ni;
  R^listeNi := A^listeNi;
	R^indentation := A^indentation + 1 ;
  R^klass := A^klass;
end
}

#attAX {
local
do
--write("Regle (38) : milieu\n");
	AX^machine := A^machine;
	AX^tvar := A^tvar;
	AX^tfun := A^tfun;
	AX^talias := A^talias;
	AX^ni := A^ni;
  AX^listeNi := A^listeNi;
	AX^indentation := A^indentation + 1;
  AX^klass := A^klass;
end
}

-- Attributs syn pour A.
#attA {
local
	reg : Register;
	rw : RegisterWrapper;
	code : String;
	vi : VariableInfo;
	estVar : boolean;
	t : Type;
	type : Type;
do
	type := null;
	reg := null;
	rw := new RegisterWrapper();
	code := R^code;
	t := R^type;
  --write("(38) R^type = " + t + "\n");
	-- Si AX n'est pas une variable, on doit générer le code de l'opération.
	if !(AX^estVar) then
		-- Le type de A doit être comparable, ie il doit s'agir d'un type simple.
		match t
		with SimpleType then 
			-- Si le type est comparable :
			-- On vérifie que les types de R et AX sont bien compatibles.
			if !(t.isCompatible(AX^type)) then 
				error(TYPE_NOT_EQUAL);
			else
				-- On génère le code de l'opération.
				code := A^machine.generateComment("(38) Comparison, left part:","\t\t")
				      + code
							+ A^machine.generateComment("(38) End left part, right part:","\t\t")
							+ AX^code
							+ A^machine.generateComment("(38) End right part, operation:","\t\t")
							+ A^machine.generateOperation(AX^oprel,R^reg,AX^reg,rw)
							+ A^machine.generateComment("(38) End of comparison.","\t\t");
				reg := rw.get();
				-- Une comparaison renvoie un booléen (précédemment un entier)
				type := new BooleanType();
			end
		else
			-- Le type n'est pas simple : impossible de faire une comparaison.
			error(TYPE_NOT_COMPARABLE);
		end
	else
	  code := A^machine.generateComment("(38) Not a comparison.","\t\t")
		      + code;
		reg := R^reg;
		type := R^type;
	end
	-- A représente une variable si AX ne l'empêche pas 
	-- et R représente une variable, on fait alors passer
	-- la vi de R à A. Sinon, vi est à null pour R.
	if (R^estVar)&&(AX^estVar) then 
		estVar := true;
		vi := R^vi;
	else
		estVar := false;
		vi := null;
	end
	-- Le registre de A contient le résultat de l'opération.
	A^reg := reg;
	-- Passage des autres attributs.
	A^type := type;
	A^code := code;
--write("(38) Reg : " + reg.debug() + "\n");
--write("(38) Code : " + code + "\n");
	A^vi := vi;
	A^estVar := estVar;
  A^regAdr := R^regAdr;
end
}


-- (39)
AX -> #attOPREL OPREL #attR R #attAX ;

#attOPREL {
local
do
  OPREL^indentation := AX^indentation + 1 ; 
end
}

#attR {
local
do
	R^machine := AX^machine;
	R^tvar := AX^tvar;
	R^tfun := AX^tfun;
	R^talias := AX^talias;
	R^ni := AX^ni;
  R^listeNi := AX^listeNi;
	R^indentation := AX^indentation + 1; 
  R^klass := AX^klass;
end
}

-- Paramètres syn de AX.
#attAX {
local
do
	-- La RP appelante ne represente pas une variable.
	AX^estVar := false;
	-- Les autres attributs font passer ceux de R.
	AX^oprel := OPREL^oprel;
	AX^reg := R^reg;
	AX^type := R^type;
	AX^code := R^code;
end
}


-- (40)
AX -> #attAX ;

-- Paramètres syn de AX.
#attAX {
local
do
--write("Regle (40)\n");
	-- L'oprel de AX est null dans ce cas.
	-- Il faut tout de même l'initialiser comme il s'agit d'un attribut synthétisé.
	AX^oprel := null;
	-- La RP n'empeche pas d'etre une variable.
	AX^estVar := true;
	-- Il faut init code.
	AX^code := "";
	-- Registre à null, de même que type.
	AX^reg := null;
	AX^type := null;
end
}


-- (41) Operateurs relationnels
OPREL -> inf #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 13;
end
}


-- (42)
OPREL -> sup #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 15; 
end
}


-- (43)
OPREL -> infeg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 14;
end
}


-- (44)
OPREL -> supeg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 16;
end
}


-- (45)
OPREL -> eg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 11;
end
}


-- (46)
OPREL -> neg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 12;
end
}


-- (47)
R -> #attT T #attRX RX #attR ;

-- Attributs inh de T.
#attT {
local
do
--write("Regle (47)\n");
	T^machine := R^machine;
	T^talias := R^talias;
	T^tfun := R^tfun;
	T^tvar := R^tvar;
	T^ni := R^ni;
  T^listeNi := R^listeNi;
	T^indentation := R^indentation + 1 ; 
  T^klass := R^klass;
end
}


-- Attributs inh de RX.
#attRX {
local
do
--write("Regle (47) : milieu\n");
	RX^machine := R^machine;
	RX^talias := R^talias;
	RX^tfun := R^tfun;
	RX^tvar := R^tvar;
	RX^ni := R^ni;
  RX^listeNi := R^listeNi;
	RX^indentation := R^indentation + 1 ; 
  RX^klass := R^klass;
end
}

-- Attributs syn de R.
#attR {
local
	code : String;
	reg : Register;
	rw : RegisterWrapper;
	vi : VariableInfo;
	estVar : boolean;
	type : Type;
do
	-- Init du registre dans lequel sera stocké le résultat de l'opération.
	rw := new RegisterWrapper();
	reg := null;
	code := T^code;
	type := T^type;

--write("(47) T^type = " + type + "\n");

	if (RX^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
			if !(type.isCompatible(RX^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := R^machine.generateComment("(47) Additive operation, left part:","\t\t")
				      + code
							+ R^machine.generateComment("(47) End left part, right part:","\t\t") 
				      + RX^code
							+ R^machine.generateComment("(47) End right part, operation:","\t\t")
				      + R^machine.generateOperation(RX^op,T^reg,RX^reg,rw)
							+ R^machine.generateComment("(47) End additive operation.","\t\t");
				reg := rw.get();
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	else
	  code := R^machine.generateComment("(47) No additive operation.","\t\t")
		      + code;
		reg := T^reg;
	end
	-- R est variable si T l'est et RX ne l'empeche pas,
	-- dans ce cas, on lui donne la vi de R. Dans le cas
	-- contraire, l'attribut vi de R est à null.
	if ((T^estVar)&&(RX^estVar)) then
		estVar := true;
		vi := T^vi;
	else
		estVar := false;
		vi := null;
	end
	-- Passage des attributs.
	R^reg := reg;
	R^code := code;
	R^estVar := estVar;
	R^vi := vi;
	R^type := type;
	R^regAdr := T^regAdr;
--write("(47) reg : " + reg.debug() + "\n");
--write("(47) code : " + code + "\n");
end
}


-- (48) : Additions ...
RX -> #attOPADD OPADD #attT T #attRX1 RX #attRX ;

#attOPADD {
local
do
  OPADD^indentation := RX^indentation + 1 ; 
end
}

-- Attributs inh de T.
#attT {
local
do
	T^machine := RX^machine;
	T^talias := RX^talias;
	T^tfun := RX^tfun;
	T^tvar := RX^tvar;
	T^ni := RX^ni;
  T^listeNi := RX^listeNi;
	T^indentation := RX^indentation + 1 ; 
  T^klass := RX^klass;
end
}

-- Attributs inh de RX1.
#attRX1 {
local
do
	RX1^machine := RX^machine;
	RX1^talias := RX^talias;
	RX1^tfun := RX^tfun;
	RX1^tvar := RX^tvar;
	RX1^ni := RX^ni;
  RX1^listeNi := RX^listeNi;
	RX1^indentation := RX^indentation + 1 ; 
  RX1^klass := RX^klass;
end
}

-- Attributs syn pour RX.
-- Génération du code de T RX en fonction de RX.
#attRX {
local
	code : String;
	rw : RegisterWrapper;
	reg : Register;
	type : Type;
do
  reg := null;
	rw := new RegisterWrapper();
	type := T^type;
	-- On met le code de T et RX1.
	code := T^code;
	if (RX1^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
			if !(type.isCompatible(RX1^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := RX^machine.generateComment("(48) Additive operation, left part:", "\t\t") 
				      + code
							+ RX^machine.generateComment("(48) End left part, right part:", "\t\t")
							+ RX1^code
							+ RX^machine.generateComment("(48) End right part, operation:", "\t\t")
							+ RX^machine.generateOperation(RX1^op,T^reg,RX1^reg,rw)
							+ RX^machine.generateComment("(48) End additive operation.", "\t\t");
			reg := rw.get();
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	else
	  -- Il n'y a pas d'autre opération additive.
		reg := T^reg;
		code := RX^machine.generateComment("(48) No additive operation.", "\t\t")
		      + code;
	end
	-- Passage de l'operateur de OPADD à RX.
	RX^op := OPADD^op;
	RX^reg := reg;
	RX^code := code;
	RX^type := type;
	-- Si cette RP apparait dans l'expression, alors il ne s'agit pas d'une variable.
	RX^estVar := false;
end
}


-- (49)
RX -> #attRX;

#attRX {
local
do
	RX^op := 0;
	-- N'empeche pas la représentation d'une variable.
	RX^estVar := true;
	RX^code := "";
	RX^type := null;
	RX^reg := null;
end
}


-- (50) : Operateurs additifs
OPADD -> plus #attOPADD ;

#attOPADD {
local
do
	OPADD^op := 1;
end
}


-- (51)
OPADD -> moins #attOPADD ;

#attOPADD {
local
do
	OPADD^op := 2;
end
}


-- (52)
OPADD -> ou #attOPADD ;

#attOPADD {
local
do
	OPADD^op :=  6;
end
}


-- (53) : Multiplication, ...
T -> #attF F #attTX TX #attT ;

-- Attributs inh de F.
#attF {
local
do
--write("Regle (53)\n");
	F^machine := T^machine;
	F^talias := T^talias;
	F^tfun := T^tfun;
	F^tvar := T^tvar;
	F^ni := T^ni;
  F^listeNi := T^listeNi;
	F^indentation := T^indentation + 1 ; 
  F^klass := T^klass;
end
}

-- Attributs inh de TX.
#attTX {
local
do
--write("Regle (53) : milieu\n");
	TX^machine := T^machine;
	TX^talias := T^talias;
	TX^tfun := T^tfun;
	TX^tvar := T^tvar;
	TX^ni := T^ni;
  TX^listeNi := T^listeNi;
	TX^indentation := T^indentation + 1 ; 
  TX^klass := T^klass;
--write("(53) Code de F :\n" + F^code + "\n");
end
}

-- Attributs syn de T. 
#attT {
local
	code : String;
	rw : RegisterWrapper;
	reg : Register;
	vi : VariableInfo;
	estVar : boolean;
	t : Type;
do
  reg := null;
	rw := new RegisterWrapper();
	code := F^code;
	t := F^type;
	write("(53) Code de F :\n" + code + "\n");
	if (TX^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match t
		with SimpleType then
			if !(t.isCompatible(TX^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := T^machine.generateComment("(53) Product operation, left part:", "\t\t") 
				      + code
							+ T^machine.generateComment("(53) End left part, right part:", "\t\t")
							+ TX^code
							+ T^machine.generateComment("(53) end right part, operation:", "\t\t")
  						+ T^machine.generateOperation(TX^op,F^reg,TX^reg,rw)
							+ T^machine.generateComment("(53) End product operation:", "\t\t");
			reg := rw.get();
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	else
		reg := F^reg;
		code := T^machine.generateComment("(53) No product operation.", "\t\t")
		      + code;
	end
	-- T est une variable si F l'est et TX ne l'empeche pas.
	-- Dans ce cas, vi de T est celui de F.
	-- Sinon, vi est à null.
	if ((F^estVar)&&(TX^estVar)) then
		estVar := true;
		vi := F^vi;
	else
		estVar := false;
		vi := null;
	end
	-- Passage des attributs.
--write("(53) reg : " + reg.debug() + "\n");
	T^reg := reg;
	T^code := code;
	T^vi := vi;
	T^estVar := estVar;
	T^type := t;
  T^regAdr := F^regAdr;
--write("(53) code : " + code + "\n");
end
}


-- (54)
TX -> #attOPMUL OPMUL #attF F #attTX1 TX #attTX;

#attOPMUL {
local
do
  OPMUL^indentation := TX^indentation + 1 ; 
end
}

-- Pas d'attribut inh pour OPMUL.
-- Attributs inh de F.
#attF {
local
do
	F^machine := TX^machine;
	F^talias := TX^talias;
	F^tfun := TX^tfun;
	F^tvar := TX^tvar;
	F^ni := TX^ni;
  F^listeNi := TX^listeNi;
	F^indentation := TX^indentation + 1 ; 
  F^klass := TX^klass;
end
}

-- Attributs inh de TX1.
#attTX1 {
local
do
	TX1^machine := TX^machine;
	TX1^talias := TX^talias;
	TX1^tfun := TX^tfun;
	TX1^tvar := TX^tvar;
	TX1^ni := TX^ni;
  TX1^listeNi := TX^listeNi;
	TX1^indentation := TX^indentation + 1 ; 
  TX1^klass := TX^klass;
end
}

-- Attributs syn de TX.
#attTX {
local
	code : String;
	rw : RegisterWrapper;
	reg : Register;
	type : Type;
do
  reg := null;
	rw := new RegisterWrapper();
	code := F^code;
	type := F^type;
	if (TX1^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
			if !(type.isCompatible(TX1^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := TX^machine.generateComment("(54) Product operation, left part:", "\t\t") 
				      + code
							+ TX^machine.generateComment("(54) End left part, right part:", "\t\t")
							+ TX1^code
							+ TX^machine.generateComment("(54) end right part, operation:", "\t\t")
  						+ TX^machine.generateOperation(TX1^op,F^reg,TX1^reg,rw)
							+ TX^machine.generateComment("(54) End product operation:", "\t\t");
			reg := rw.get();
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	else
	  reg := F^reg;
		code := code 
		      + TX^machine.generateComment("(54) No product operation.", "\t\t");
	end
	TX^op := OPMUL^op;
	TX^code := code;
	TX^reg := reg;
	--Cette RP empeche l'expression d'etre une variable.
	TX^estVar := false;
	TX^type := type;
end
}


-- (55)
TX -> #attTX ;

-- Attributs syn de TX.
#attTX {
local
do
	TX^op := 0;
	TX^code := "";
	TX^reg := null;
	-- N'empeche pas l'espression de rpz une var.
	TX^estVar := true;
	TX^type := null;
end
}


-- (56) : Operateurs multiplicatifs
OPMUL -> mult #attOPMUL ;

#attOPMUL {
local
do
	OPMUL^op := 3;
end
}


-- (57)
OPMUL -> div #attOPMUL;

#attOPMUL {
local
do
	OPMUL^op := 4;
end
}


-- (58)
OPMUL -> mod #attOPMUL ;

#attOPMUL {
local
do
	OPMUL^op := 7;
end
}


-- (59)
OPMUL -> et #attOPMUL ;

#attOPMUL {
local
do
	OPMUL^op := 17;
end
}


---------------------------------------
--------- Expressions de base ---------
---------------------------------------

-- (60) : Constante entiere
F -> entier #attF ;

-- Attributs syn de F.
-- Génération du code pour load la valeur de l'entier dans la mémoire.
#attF {
local
	t : IntegerType;
	rw : RegisterWrapper;
	reg : Register;
	r : Register;
  c : ConstantInfo;
do
--write("(60) Debut\n");
	-- Creation du type et du registre.
	t := new IntegerType();
	rw := new RegisterWrapper();
	reg := null;
	-- Récup de l'entier et conversion au bon format.
	-- Génération du code, et set de l'attribut le contenant.
	c := new ConstantInfo(t, entier^txt);
--write("(60) : ConstantInfo : " + c + "\n");
	F^code := F^machine.generateComment("(60) Integer constant:", "\t\t")
	        + F^machine.generateLoadConstant(c, rw)
					+ F^machine.generateComment("(60) End integer constant.", "\t\t"); 
  reg := rw.get();
--write("(60) reg : " + r.debug() + "\n");
	-- Une expression de base ne peut representer une variable.
	-- Donc pas de vi.
	F^vi := null;
	F^estVar := false;
	-- Set de l'attribut type.
	F^type := t;
	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
	F^reg := reg;
  F^regAdr := null;
end
}


-- (61) : Constante chaine
F -> chaine #attF ;

-- Attributs syn de F.
-- Génération de code pour load la chaine.
#attF {
local
	l : int;
	t : StringType;
	reg : Register;
	rw : RegisterWrapper;
	s : String;
do
	-- Récup de la chaine.
	s := chaine^txt;
	l := s.length();
	-- Suppression des " au début et à la fin de celle-ci.
	s := s.substring(1,l-1);
	l := l-2;
	-- Initialisation du type, en précisant la taille.
	t := new StringType(l);
	-- Création du registre.
	rw := new RegisterWrapper();
	reg := null;
	-- Génération du code et set des attributs de F.
	F^code := F^machine.generateComment("(61) String constant:", "\t\t")
	        + F^machine.generateLoadConstant(new ConstantInfo(t, s), rw)
					+ F^machine.generateComment("(61) End string integer.", "\t\t");
	reg := rw.get();
	-- Une expression de base ne peut representer une variable.
	-- Donc pas de vi.
	F^vi := null;
	F^estVar := false;
	F^type := t;
	F^reg := reg;
	F^regAdr := null;
end
}


-- (62) : Constante caractere
F -> caractere #attF ;

-- Attributs syn de F.
-- Génération de code pour load le caractere.
#attF {
local
	c : char;
	r : Register;
	t : Type;
	reg : Register;
  rw : RegisterWrapper;
  code : String;
do
	 --write("(60) This, sir, is a character constant!\n");
-- Récup du caractère.
	c := caractere^txt.charAt(1);
	-- Init du type et du reg.
	t := new CharacterType();
	reg := null;
	rw := new RegisterWrapper();
	-- Gen du code et set des attributs de F.
	code := F^machine.generateComment("(62) Char constant:", "\t\t")
	        + F^machine.generateLoadConstant(new ConstantInfo(t, c), rw)
					+ F^machine.generateComment("(62) End char constant.", "\t\t");
	reg := rw.get();
	-- Une expression de base ne peut representer une variable.
	-- Donc pas de vi.
  F^code := code;
	--write("(60) Da code you'll need to use this constant is right heere : \n" + code + "\n");
	F^vi := null;
	F^estVar := false;
	F^type := t;
	F^reg := reg;
	F^regAdr := null;
end
}


-- (63) : Expression unaire
F -> #attOPUN OPUN #attF1 F #attF ;

#attOPUN {
local
do
  OPUN^indentation := F^indentation + 1 ; 
end
}

-- Pas d'att inh pour OPUN.
-- Attributs inh de F1.
#attF1 {
local
do
	F1^machine := F^machine;
	F1^talias := F^talias;
	F1^tfun := F^tfun;
	F1^tvar := F^tvar;
	F1^ni := F^ni;
  F1^listeNi := F^listeNi;
	F1^indentation := F^indentation + 1; 
  F1^klass := F^klass;
end
}

-- Attributs syn de F.
-- Génération du code pour la déclaration de la variable.
#attF {
local
  rw : RegisterWrapper;
	reg : Register;
	code : String;
	t : Type;
do
	rw := new RegisterWrapper();
	reg := null;
	t := F1^type;
	code := "";
	match t
	with SimpleType then
		code := F^machine.generateComment("(63) Unary operation, expression:", "\t\t")
		      + F1^code
					+ F^machine.generateComment("(63) End of expression, operation:", "\t\t")
					+ F^machine.generateOperation(OPUN^op,F1^reg,rw)
					+ F^machine.generateComment("(63) End of unary operation.", "\t\t");
	  reg := rw.get();
	else 
		error(TYPE_NOT_SIMPLE);
	end
	F^code := code;
	-- Une variable ne peut contenir d'opérateur unaire.
	-- Donc pas de vi.
	F^estVar := false;
	F^vi := null;
	F^type := t; 
	F^reg := reg;
  F^regAdr := null; -- Pas d'adresse.
end
}


-- (64) : Operateurs unaires
OPUN -> plus #attOPUN ;

#attOPUN {
local
do
	OPUN^op := 10;
end
}


-- (65)
OPUN -> moins #attOPUN ;

#attOPUN {
local
do
	OPUN^op := 8;
end
}


-- (66)
OPUN -> non #attOPUN ;

#attOPUN {
local
do
	OPUN^op := 9;
end
}


-- (67) : Pointeur NULL
F -> null #attF ;

-- Le pointeur null ne représente pas une variable.
-- Donc pas de vi.
#attF {
local
do
	F^estVar := false;
	F^vi := null;
	F^code := F^machine.generateComment("(67) Null pointer: NO CODE", "\t\t");
	F^type := null;
	F^reg := null; 
  F^regAdr := null;
end
}

-- (68) : Expression parenthesee
F ->  paro #attE E parf #attFX FX #attF;

-- Attributs inh de E.
#attE {
local
do
	E^machine := F^machine;
	E^tvar := F^tvar;
	E^tfun := F^tfun;
	E^talias := F^talias;
	E^ni := F^ni;
  E^listeNi := F^listeNi;
	E^indentation := F^indentation + 1 ; 
  E^klass := F^klass;
end
}

-- Attributs inh de FX.
#attFX {
local
	dl : DisplacementList;
do
	dl := new DisplacementList();
	FX^machine := F^machine;
	FX^tvar := F^tvar;
	FX^tfun := F^tfun;
	FX^talias := F^talias;
	-- La partie avant FX n'est pas un appel de fonction.
	FX^estFun := false;
	--FX^funInfoH := null;
	-- La liste des déplacements de FX est initialisée ici.
	FX^listeDepl := dl;
	-- On met le nom à "", pas d'appel de fonction de cette manière. 
	FX^nom := "";
	-- On fait passer le type de E à FX pour d'éventuelles verifs.
	FX^typeH := E^type;
	FX^ni := F^ni;
  FX^listeNi := F^listeNi;
	FX^indentation := F^indentation + 1 ; 
  FX^klass := F^klass;
	FX^regH := null; -- A modifier si on veut autoriser une EP à etre une poignée.
  FX^codeH := "";
end
}

-- Attributs syn de F.
-- On ne récupère pas le code de FX car il est vide sauf en cas d'appel de fonction, impossible ici.
#attF {
local
  estVar : boolean;
	vi : VariableInfo;
	dl : DisplacementList;
	rv : RegisterWrapper;
	ra : RegisterWrapper;
  code : String;
  regAdr : Register;
	regVal : Register;
do
  dl := FX^listeDeplS;
  rv := new RegisterWrapper();
	ra := new RegisterWrapper();
  regVal := null;
	regAdr := null;
  code := F^machine.generateComment("(68) Parenthesized expression:", "\t\t")
		    + E^code
				+ F^machine.generateComment("(68) End of parenthesized expression.", "\t\t");
	if ((dl.size()) != 0) then -- : > 0) then
    -- On a accédé à des champs dans FX.
    -- On génère le code correspondant, en prenant le registre de E comme base.
    -- Les verification d'existence de champs ont été faites dans FX.
    code := code
		      + F^machine.generateComment("(68) Make address:", "\t\t")
					+ F^machine.generateMakeAddress(dl, E^reg, rv, ra)
					+ F^machine.generateComment("(68) End make address.", "\t\t");
		regVal := rv.get();
		regAdr := ra.get();
	else
		regVal := E^reg;
  end
  -- F est une variable si E l'est et FX ne l'empeche pas.
  -- Dans ce cas, vi de F prend celui de E. Dans le cas
  -- contraire, il est null.
  if ((E^estVar)&&(FX^estVar)) then
	  estVar := true;
		vi := E^vi;
	else
	  estVar := false;
		vi := null;
	end
  F^code := code;
	F^vi := vi;
	F^estVar := estVar;
	F^type := FX^type;
	F^reg := regVal;
  F^regAdr := regAdr;
end
}


-- (69) : Cast
F ->  paro #attTYPE TYPE parf #attF1 F #attF;

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := F^talias;
  TYPE^tklass := F^tklass;
	TYPE^ni := F^ni;
	TYPE^listeNi := F^listeNi;
	TYPE^indentation := F^indentation + 1 ; 
end
}

-- Attributs inh de F1.
#attF1 {
local
do
  F1^machine := F^machine;
	F1^talias := F^talias;
	F1^tfun := F^tfun;
	F1^tvar := F^tvar;
	F1^ni := F^ni;
  F1^listeNi := F^listeNi;
	F1^indentation := F^indentation + 1 ; 
  F1^klass := F^klass;
end
}

-- Attributs syn de F.
#attF {
local
  t : Type;
	vi : VariableInfo;
do
  t := TYPE^type;
	vi := null;
  if (F1^type.isCompatible(t)) then
		 vi := new VariableInfo(TYPE^type, F1^vi.displacement(), F^ni);
  else
     error(TYPE_NOT_COMPATIBLE);	   
  end
  F^code := F^machine.generateComment("(69) Cast: NO CODE.", "\t\t")
	        + F1^code;
  -- (int)a ne représente pas une variable : 
  -- le cast empeche une expression d'etre une variable.
  -- Donc pas de vi.
  F^estVar := false;
	F^vi := vi;
	F^type := t;
	F^reg := F1^reg;
	F^regAdr := null; 
end
}


-- (70) : Dereferencement.
F -> mult #attF1 F #attF;

-- Attributs inh de F1.
#attF1 {
local
do
--write("(70) Dereferencement.\n");
  F1^machine := F^machine;
	F1^talias := F^talias;
	F1^tfun := F^tfun;
	F1^tvar := F^tvar;
	F1^ni := F^ni;
  F1^listeNi := F^listeNi;
	F1^indentation := F^indentation + 1 ; 
  F1^klass := F^klass;
end
}

-- Attributs syn de F.
-- F représente une variable si F1 en représente une, et que celle-ci est un pointeur.
#attF {
local
  t : Type;
	type : Type;
  reg : Register;
  rw : RegisterWrapper;
	code : String;
do
	t := F1^type;
	type := null; 
  rw := new RegisterWrapper();
	reg := null;
	-- On vérifie que ce qu'on deref' est un pointeur. 
  match t 
	with PointerType then
    type := t.getType();
	else
	  error(SHOULD_BE_A_POINTER);
	end
  -- A la suite du code généré par F1, on load le champ pointé.
	code := F^machine.generateComment("(70) Unreferencing, code of what to unreference:", "\t\t")
	      + F1^code 
	  		+ F^machine.generateComment("(70) Unreferencing:", "\t\t")
				+ F^machine.generateLoadFromHeap(F1^reg, 0, rw)
				+ F^machine.generateComment("(70) End of unreferencing.", "\t\t");
	
--write("(70) Code après déréf' : \n" + code + "\n");
	reg := rw.get();
	F^code := code;
	F^vi := null;
	F^estVar := true;
	F^type := type;
	F^reg := reg;
	if (F1^regAdr = null) then
	  reg.lock();
	  F^regAdr := reg;
	else
	  F^regAdr := F1^regAdr;
	end
--write("(70) Fin deref.\n");
end
}


-- (71)
F -> ident #attFX FX #attF ;
global
  varInfo : VariableInfo;
	estFun : boolean;

-- Attributs inh de FX.
-- On cherche ident dans les TDS.
-- Instenciation des attributs nécessaires.
#attFX {
local
  listeDepl : DisplacementList ;
	type : Type;
  info : SymbolInfo; 
	code : String;
	rw : RegisterWrapper;
  reg : Register;
do
  write("(71) : " + ident^txt + ", " + F^ni.name() + "\n");
  --Initialisations.
	code := "";
  listeDepl := new DisplacementList();
	estFun := false;
	type := null;
	varInfo := null;
	info := null;
	reg := null;
	rw := new RegisterWrapper();
	-- Recherche dans la TVar (globalement).
  write("(71) NamespaceList : " + F^listeNi + "\n");
	if (!(F^tvar.exists(ident^txt, F^ni, F^listeNi, false))) then
	  --write("(71) " + ident^txt + " n'est pas dans la tvar\n");
	  -- ident n'est pas dans la TVar, F n'est pas une variable.
		-- On regarde dans la TFun s'il s'agit de l'identifiant d'une fonction.
    if (!(F^tfun.exists(ident^txt, F^ni, F^listeNi))) then
		  -- On n'a pas trouvé le symbole dans les TDS : erreur.
			error(IDENT_UNDEFINED, ident^txt);
    else
		  -- L'id est celui d'une fonction.
			-- On passe estFun à vrai.
		--write("(71).attFX C'est une fonction\n");
			listeDepl.add(0, false);
			estFun := true;
			type := null;
    end
  else
		-- On peut passer le type.
	  --write("(71) " + ident^txt + " trouvé.\n");
		info := F^tvar.lookup(ident^txt, F^ni, F^listeNi, false);
		match info
		with VariableInfo then
		  varInfo := info;
	    type := varInfo.type();
			match type
			with Klass then
			  -- Si on a une poignée, on génère le code pour y accéder, de manière à faire passer le reg.
			  code := F^machine.generateLoadFromStack(type.thisDisplacement(F^machine), rw);
			  reg := rw.get();
			else
		    -- On rajoute toujours le déplacement de a à la liste.
		    -- Le test pour savoir si a est bien un struct se fait dans les RP ,de FX.
		    listeDepl.add(varInfo.displacement(), false);
			end
		else
		  error(SHOULD_NOT_HAPPEN_SI_NOT_VI);
		end
  end
	-- On passe les attributs qui serviront à FX.
	FX^listeDepl := listeDepl;
	FX^estFun := estFun;
	--FX^funInfoH := funInfo;
	FX^typeH := type;
	FX^nom := ident^txt;
	FX^tvar := F^tvar;
	FX^tfun := F^tfun;
	FX^talias := F^talias;
	FX^machine := F^machine;
	FX^ni := F^ni;
  FX^listeNi := F^listeNi;
	FX^indentation := F^indentation + 1 ; 
  FX^klass := F^klass;
	FX^regH := reg;
	FX^codeH := code;
--write("Regle 71 : au milieu à peu près\n");
end
}

-- Attributs syn de F.
#attF {
local
  listeDepl : DisplacementList; 
  reg : Register;
	regAdr : Register;
	rv : RegisterWrapper;
	ra : RegisterWrapper;
	code : String;
do
--write("Après Règle 71\n");
  -- Génération du code.
  -- Traitements différents selon qu'on ait : - éffectué un appel de fonction.
  --																					- accédé simplement à une variable.
  --               														- accédé à un champ de struct.
  listeDepl := FX^listeDeplS;
  rv := new RegisterWrapper();
	ra := new RegisterWrapper();
	reg := null;
	regAdr := null;
	code := FX^code;
	if (estFun) then
	--write("(71).attF C'est une fonction\n");
    -- On a un appel de fonction, peut être suivi d'accés à des champs de struct.
	  -- regRetourFun est le registre contenant le résultat de l'appel de fonction,
		-- il se trouve dans le FunctionInfo \o/.
	--write("(71) DL :\n" + listeDepl + "\n     reg : " + FX^reg.debug() + "\n"); 
    code := code
		      + F^machine.generateComment("(71) Make address:", "\t\t")
		      + F^machine.generateMakeAddress(listeDepl, FX^reg, rv, ra)
				  + F^machine.generateComment("(71) End make address.", "\t\t"); 
		reg := rv.get();
	  regAdr := ra.get();
	else 
	  -- On n'a pas d'appel de fonction. 
		if ((listeDepl.size() != 0 )&&(listeDepl.size() != 1)) then --> 1) then
	    -- Des déplacements ont été ajoutés à la liste en plus de celui de ident : on a accédé à des champs de struct !
		  -- Le registre contient l'adresse de la variable accédée par FX dans le struct.
      code := code
			      + F^machine.generateComment("(71) Make address:", "\t\t") 
			      + F^machine.generateMakeAddress(listeDepl, rv, ra)	
						+ F^machine.generateComment("(71) End make address.", "\t\t");
			reg := rv.get();
		  regAdr := ra.get();
		else
      -- Accés direct à une variable.
   		-- La VariableInfo est déjà dans varInfo.
      code := code
			      + F^machine.generateComment("(71) Load value:", "\t\t")
			      + F^machine.generateLoadValue(varInfo, rv)
						+ F^machine.generateComment("(71) End load value.", "\t\t");
		  reg := rv.get();
		end
  end
	write("(71) Fin, code :\n" + code + "\n"); 
	F^vi := varInfo;
	F^code := code;
  F^estVar := true;
  F^type := FX^type;
	F^reg := reg;
	F^regAdr := regAdr;
--write("(71) reg : " + reg.debug() + "\n");
--write("(71) code: " + code + "\n");
end
}


-- (72)
FX -> #attFX ;

-- Attributs syn de FX. 
#attFX {
local
do
  -- Vérifie qu'on n'attendait pas une liste d'argument pour un appel de fonction.
  if (FX^estFun) then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  FX^code := FX^codeH;
  FX^type := FX^typeH;
  FX^listeDeplS := FX^listeDepl;
	FX^estVar := true;
	FX^reg := FX^regH;
--write("Regle (72) (FX -> /\\)\n");
end
}


-- (73) : Acces champ
FX -> pt ident #attFX1 FX #attFX;

-- Attributs inh de FX1. 
#attFX1 {
local
  typeStruct : StructType; 
	type : Type;
	type2 : Type;
	listeDepl : DisplacementList;
	fields : List<String>;
	estFun : boolean;
  att : AttributeInfo;
do
  -- On vérifie qu'on était pas dans un appel de fonction.
	if (FX^estFun) then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  listeDepl := FX^listeDepl;
	type := FX^typeH;
	estFun := false;
  -- On regarde ce qui est à gauche de cet appel, soit un struct, soit une poignée.
	type2 := FX^typeH;
  match type2
	with StructType then  
		-- On vérifie que le champ existe et on y accède.
    typeStruct := type2;
		fields := typeStruct.fields();
		if (fields.indexOf(ident^txt) = (-1)) then
		  -- Si le instanceOf renvoie -1, c'est que l'identifiant n'apparait pas dans les champs : erreur.
		  error(CHAMP_INEXISTANT, ident^txt);
		else
      -- Si le champ existe, on ajoute le déplacement correspondant à la liste.
			listeDepl.add(typeStruct.fieldDisplacement(ident^txt),false);
			-- On récupère le type.
   		type := typeStruct.find(ident^txt);
			estFun := false;
	  end
	with Klass then
	  --On a une poignée à gauche. On regarde si ident représente un attribut ou si c'est un appel de méthode.
    att := type2.lookupAttribute(ident^txt);
		if (att = null) then
      -- Ce n'est pas un attribut : c'est forcément un appel de méthode.
		  -- La verification se fera plus tard.
			estFun := true;
			listeDepl.add(0, false);
			type := type;
		else
		  -- On a un attribut.
			-- TODO vérifier l'accès (si on est dans une méthode : tous ok, sinon : public).
			-- On ajoute le déplacement et on récupère le type.
			listeDepl.add(att.displacement(), false);
			type := att.type();
			estFun := false;
  	end
	else
		-- Sinon : erreur !
	  error(NOT_STRUCT_OR_KLASS);
  end
	FX1^listeDepl := listeDepl;
	FX1^estFun := estFun;
	FX1^typeH := type;
  FX1^nom := ident^txt;	
	FX1^tvar := FX^tvar;
	FX1^tfun := FX^tfun;
	FX1^talias := FX^talias;
	FX1^machine := FX^machine;
	FX1^ni := FX^ni;
  FX1^indentation := FX^indentation + 1 ; 
  FX1^klass := FX^klass;
	FX1^codeH := FX^codeH;
end
}

-- Attributs syn de FX.
-- On fait remonter le code, le type et la liste de deplacement.
#attFX{
local
do
  FX^code := FX1^code;
  FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
	FX^estVar := FX1^estVar;
	FX^reg := null;
end
}


-- (74) : Acces champ pointeur
FX -> arrow ident #attFX1 FX #attFX;

-- Attributs inh de FX1.
-- Comme dans la RP precedent, on doit vérifier que la règle est applicable.
-- Le type passé à FX doit etre celui d'un pointeur et le type pointé un struct.
-- La champ doit exister dans le type pointé.
#attFX1 {
local
  type : Type;
	typeP : Type;
	typeS : Type;
	listeDepl : DisplacementList;
	fields : List<String>;
do
  -- On vérifie qu'on était pas dans un appel de fonction.
	if (FX^estFun) then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  type := FX^typeH;
	listeDepl := FX^listeDepl;
	typeP := type;
	match typeP
	with PointerType then
	-- Si type est un pointeur on va vérifier qu'il s'agit d'un pointeur sur struct.
		type := typeP.getType();
		-- Si le type pointé est struct, on va vérifier que le champ existe.
		typeS := type;
    match typeS
		with StructType then
			fields := typeS.fields();
      if (fields.indexOf(ident^txt) = -1) then
		    -- Si le instanceOf renvoie -1, c'est que l'identifiant n'apparait pas dans les champs : erreur.
		    error(CHAMP_INEXISTANT, ident^txt);
		  else
        -- Si le champ existe, on ajoute le déplacement correspondant à la liste.
		  	listeDepl.add(typeS.fieldDisplacement(ident^txt),true);
		  	-- On récupère le type.
   	  	type := typeS.find(ident^txt);
	    end
		-- Sinon : erreur !
		else
      error(NOT_STRUCT);
		end
	else
	-- Sinon : erreur !
	  error(NOT_A_POINTEUR);
  end
	FX1^estFun := false;
	--FX1^funInfoH := null;
	FX1^typeH := type;
	FX1^listeDepl := listeDepl;
  FX1^nom := ident^txt;
	FX1^tvar := FX^tvar;
	FX1^tfun := FX^tfun;
	FX1^talias := FX^talias;
	FX1^machine := FX^machine;
	FX1^ni := FX^ni;
  FX1^listeNi := FX^listeNi;
	FX1^indentation := FX^indentation + 1 ; 
  FX1^klass := FX^klass;
  FX1^codeH := FX^codeH;
end
}

-- Attributs syn de FX.
-- On fait remonter le code, le type et la liste de deplacement.
#attFX {
local
do
  FX^code := FX1^code;
  FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
	FX^estVar := FX1^estVar;
	FX^reg := null;
end
}


-- (75) : Appel de sous-programme
-- La verification des paramètres ainsi que la generation des pushs
-- se font dans ES.
FX -> #attES paro ES parf #attFX1 FX #attFX;

-- Attributs inh de ES.
-- Verification que l'appelant est une fonction.
#attES {
local
do
--write("Regle (75)\n");
  if !(FX^estFun) then
	  error(NOT_A_FUN);
	end
  ES^typesParams := new ArrayList<Type>();
  ES^codeH := "";
	ES^tvar := FX^tvar;
	ES^tfun := FX^tfun;
	ES^talias := FX^talias;
	ES^machine := FX^machine;
	ES^ni := FX^ni;
  ES^listeNi := FX^listeNi;
	ES^indentation := FX^indentation + 1 ; 
  ES^klass := FX^klass;

end
}

-- Attributs inh de FX1.
-- Verification qu'il existe bien une fonction avec cette signature.
#attFX1 {
local
	type : Type;
	th : Type;
	si : SymbolInfo;
  code : String;
  listeDepl : DisplacementList;
	rv : RegisterWrapper;
	ra : RegisterWrapper;
	reg : Register;
	regAdr : Register;
	regH : Register;
do
	reg := null;
	type := null;
	rv := new RegisterWrapper();
	ra := new RegisterWrapper();
  code := FX^codeH;
  listeDepl := FX^listeDepl;
	regH := FX^regH;
  -- On va générer le function/method pour ça, on a besoin de générer l'addresse.
  if (regH = null) then 
    code := FX^machine.generateComment("(75) Make address before function call:", "\t\t") 
		      + FX^machine.generateMakeAddress(listeDepl, rv, ra)
					+ FX^machine.generateComment("(75) End of make address.", "\t\t");
	else 
	  code := FX^machine.generateComment("(75) Make address before function call:", "\t\t") 
		      + FX^machine.generateMakeAddress(listeDepl, regH, rv, ra)
					+ FX^machine.generateComment("(75) End of make address.", "\t\t");
  end
	reg := rv.get();
	regAdr := ra.get();
  listeDepl := new DisplacementList();
	if (FX^nom = "") then
	  error(NO_PAR_CALL);
	else  
	  if (FX^typeH = null) then
		  -- On est dans un cas d'appelle de fonction sans rien avant.
		  -- On cherche avec la fonction qui ne prend pas de booléen, mais une liste de types pour les params.
      si := FX^tfun.lookup(FX^nom, FX^ni, FX^listeNi, ES^typesParamsS);
	    --write("(75) " + si + "\n");
		  if (si = null) then
		    error(NO_FUN_WITH_SUCH_PARS, FX^nom);
		  end
			match si
			with FunctionInfo then
		  	code := code
				      + FX^machine.generateComment("(75) Function call, parameters pushes:", "\t\t")
				      + ES^code
							+ FX^machine.generateComment("(75) End of pushes. Generate function call:", "\t\t")
							+ FX^machine.generateFunctionCall(si)
							+ FX^machine.generateComment("(75) End of function call.", "\t\t");
				type := si.returnType();
				reg := si.register();
			--write("(75) fi : " + si + "\n");
	  	else 
		  	error(SHOULD_NOT_HAPPEN_SI_NOT_FI);
			end
		else
		  th := FX^typeH;
		  match th
		  with Klass then
        si := th.lookupMethod(FX^nom, ES^typesParamsS);
			  match si
			  with MethodInfo then
			    code := FX^machine.generateComment("(75) Method call, parameters pushes:", "\t\t")
				        + ES^code
					    	+ FX^machine.generateComment("(75) End of pushes. Generate method call:", "\t\t")
						    + FX^machine.generateMethodCall(si, reg)
						    + FX^machine.generateComment("(75) End of method call.", "\t\t");
				  type := si.returnType();
				  reg := si.register();
			  else
          error(SHOULD_NOT_HAPPEN_SI_NOT_MI);
			  end
			else
		    error(TYPE_NOT_KLASS_NOR_NULL_IN_CALL);
	    end
		end
	end

-- TODO faut-il faire qqchose de regAdr 

  -- La liste des depl a été réinitialisée comme on a 'consommé' les déplacements antèrieurs à l'appel.
  FX1^listeDepl := listeDepl;
	-- L'appel de fonction n'est pas une fonction.
	FX1^estFun := false; 
	-- Le type de l'appel est le type de retour de la fonction.
	FX1^typeH := type;
	-- Pas de nom pour FX ici.
	FX1^nom := "";
	FX1^tvar := FX^tvar;
	FX1^tfun := FX^tfun;
	FX1^talias := FX^talias;
	FX1^machine := FX^machine;
	FX1^ni := FX^ni;
	FX1^listeNi := FX^listeNi;
  FX1^indentation := FX^indentation + 1 ; 
  FX1^klass := FX^klass;
	FX1^codeH := code; 
	FX1^regH := reg;
end
}

-- Attributs syn de FX.
-- On push les arguments, le code est dans ES^code.
-- Puis on appel la fonction. Et on met le code de FX1.
#attFX {
local
do
	FX^code := FX1^code;
	FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
	FX^estVar := false;
  FX^reg := FX1^reg;
end
}


-- (76) : Arguments appel de sous-programme
ES -> #attES ;

-- Attributs syn de ES
#attES {
local
do
  -- Passage de la liste des types des params de l'appel.
  ES^typesParamsS := ES^typesParams;
  -- On n'a rien à ajouter comme code à cette RP.
  -- On fait remonter le code des paramètres précédents.
  ES^code := ES^codeH
	         + ES^machine.generateComment("(76) End of arguments (Empty).", "\t\t");
end
}


-- (77)
ES -> #attE E #attESX ESX #attES ;

-- Attributs inh de E
#attE {
local
do
  E^machine := ES^machine;
	E^tvar := ES^tvar;
	E^tfun := ES^tfun;
	E^talias := ES^talias;
	E^ni := ES^ni;
  E^listeNi := ES^listeNi;
	E^indentation := ES^indentation + 1 ; 
  E^klass := ES^klass;
end
}

-- Attributs inh de ESX et ajout du type du paramètre.
#attESX {
local
  l : List<Type>;
  code : String;
do
  -- Ajout du type de E à la liste des types des params.
  l := ES^typesParams;
	l.add(E^type);
  -- Ajout du code du push pour ce param.
  code := ES^machine.generateComment("(77) Expression to push:", "\t\t") 
	      + E^code
				+ ES^machine.generateComment("(77) End of expression. Pushing:", "\t\t")
				+ ES^machine.generateFunctionPushArgument(E^reg)
				+ ES^machine.generateComment("(77) End of pushing.", "\t\t");
  ESX^typesParams := l;
  ESX^codeH := code;
	ESX^machine := ES^machine;
	ESX^tvar := ES^tvar;
	ESX^tfun := ES^tfun;
	ESX^talias := ES^talias;
	ESX^ni := ES^ni;
  ESX^listeNi := ES^listeNi;
	ESX^indentation := ES^indentation + 1 ; 
  ESX^klass := ES^klass;
end
}

-- Passage du code de ESX à ES.
-- Et remontée de la liste des types.
#attES {
local
do
  ES^code := ESX^code;
	ES^typesParamsS := ESX^typesParamsS;
end
}


-- (78)
ESX -> #attESX ;

-- Attributs syn de ESX.
#attESX {
local
do
  ESX^typesParamsS := ESX^typesParams;
  ESX^code := ESX^codeH
	          + ESX^machine.generateComment("(78) End of arguments.", "\t\t");
end
}


-- (79)
ESX -> virg #attE E #attESX1 ESX #attESX ;

-- Attributs inh de E.
#attE {
local
do
  E^machine := ESX^machine;
	E^tvar := ESX^tvar;
	E^tfun := ESX^tfun;
	E^talias := ESX^talias;
	E^ni := ESX^ni;
  E^listeNi := ESX^listeNi;
	E^indentation := ESX^indentation + 1 ; 
  E^klass := ESX^klass;
end
}

-- Attributs inh de ESX1, ajout du type du param.
#attESX1 {
local
  l : List<Type>;
	code : String;
do
  l := ESX^typesParams;
  l.add(E^type);
  code := ESX^codeH
	      + ESX^machine.generateComment("(79) Expression to push:", "\t\t") 
				+ E^code
				+ ESX^machine.generateComment("(79) End of expression. Pushing.", "\t\t")
				+ ESX^machine.generateFunctionPushArgument(E^reg)
				+ ESX^machine.generateComment("(79) End of pushing.", "\t\t");
  ESX1^typesParams := l;
  ESX1^codeH := code;
	ESX1^machine := ESX^machine;
	ESX1^tvar := ESX^tvar;
	ESX1^tfun := ESX^tfun;
	ESX1^talias := ESX^talias;
	ESX1^ni := ESX^ni;
  ESX1^listeNi := ESX^listeNi;
	ESX1^indentation := ESX^indentation + 1 ; 
  ESX1^klass := ESX^klass;
end
}

-- Attributs syn de ESX.
-- Passage du code de ESX à ES.
-- Et remontée de la liste des types.
#attESX {
local
do
  ESX^code := ESX1^code;
  ESX^typesParamsS := ESX1^typesParamsS;
end
}

-------------------------------------------
--------------- INLINE ASM ----------------
-------------------------------------------
--
---- (80)
ENTITE -> asm #tds AASM #gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code ASM puisse acceder aux variables de MC ou MCS
  write("There is an asm block !\n");
  AASM^tds_asm := ENTITE^tvar;
  AASM^mach_asm := ENTITE^machine;
  AASM^namespace_asm := ENTITE^ni;
  AASM^listeni_asm := ENTITE^listeNi;
end
}

#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
  ENTITE^code := AASM^code_asm;
end
}


-- (81)
INST ->  asm   #tds AASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  AASM^tds_asm := INST^tvar;
  AASM^mach_asm := INST^machine;
  AASM^namespace_asm := INST^ni;
  AASM^listeni_asm := INST^listeNi;
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
  INST^code := AASM^code_asm;
end
}


-----------------------------------------------------
------------------- CS extension --------------------
-----------------------------------------------------

-- (82)
TYPE -> bool #attTYPE ;

#attTYPE {
local
do
  TYPE^type := new BooleanType();
end
}

-- (83) Definit un contenu d'un namespace
ENTITE -> namespace identc #attENTITES aco ENTITES acf #attENTITE;

-- Ajout de identc à la table des namespaces.
-- Vérifie que identc n'est pas déjà utilisé (par une classe ou un namespace).
#attENTITES {
local
	tns : NamespaceTable;
	ni : NamespaceInfo;
do
  write("Creation namespace.\n");
  tns := ENTITE^tns;
  -- Si identc est une clef dans la TDSKlass, erreur.
  if (ENTITE^tklass.exists(identc^txt, ENTITE^ni, ENTITE^listeNi)) then
     error(IDENT_TAKEN, identc^txt);
  end
  -- Si identc est une clef dans la TDSNamespace, erreur.	
  if (tns.exists(identc^txt, ENTITE^ni, ENTITE^listeNi)) then
    error(IDENT_TAKEN, identc^txt);
  end
  -- Sinon, on peut ajouter le nouveau namespace à la TDS.
	if (ENTITE^talias.exists(identc^txt, ENTITE^ni, ENTITE^listeNi)) then
	  error(IDENT_TAKEN, identc^txt);
	end
	ni := new NamespaceInfo(identc^txt, ENTITE^ni);
	tns.add(ni);
	ENTITES^ni := ni;
  ENTITES^machine := ENTITE^machine;
	ENTITES^tvar := ENTITE^tvar;
	ENTITES^tfun := ENTITE^tfun;
	ENTITES^talias := ENTITE^talias;
  ENTITES^tns := ENTITE^tns;
	ENTITES^tklass := ENTITE^tklass;
  ENTITES^indentation := ENTITE^indentation + 1;
  ENTITES^klass := ENTITE^klass;
end
}

-- Attributs syn de ENTITE.
#attENTITE {
local
do
  -- Pas de code à ajouter dans cette RP, 
	-- on fait tout de même remonter le code des ENTITES du namespace.
  ENTITE^code := ENTITE^machine.generateComment("(83) Namesapce creation (" + identc^txt + "):", "")
	             + ENTITES^code
							 + ENTITE^machine.generateComment("(83) End of namespace.", "");
end
}


-- (84) : Donne l'acces au contenu du 'namespace'.
-- Le chemin du ns doit être donné depuis "la racine".
ENTITE -> using identc #attIDC IDC #attENTITE pv ;

-- Attributs inh de IDC.
#attIDC {
local 
  ni : NamespaceInfo;
do
  -- Comme l'adresse du namesapce doit être donnée depuis la racine,
	-- on effectue la première recherche en mettant le dns comme parent.
	ni := ENTITE^tns.lookup(identc^txt, new DefaultNamespaceInfo(), new NamespaceInfoList());
	if (ni = null) then 
		error(NOT_A_NS);
	end
	-- Passage des attributs à IDC pour continuer la recherche à partir du ni.
  IDC^tns := ENTITE^tns;
  IDC^tklass := ENTITE^tklass;
	-- Le ni qui sera utilisé comme parent de la prochaine recherche.
	IDC^ni := ni;
  IDC^listeNi := ENTITE^listeNi;
	IDC^indentation := ENTITE^indentation + 1;
end
}

-- Attributs syn de ENTITE.
#attENTITE {
local 
do
  -- On ajoute à la liste des ns utilisés ici celui renvoyé par IDC.
	if (IDC^niS = null) then
	  error(PATH_NOT_NS);
	end
	ENTITE^listeNi.add(IDC^niS);
	ENTITE^code := "";
end
}


-- (85)
IDC -> #attIDC ;

-- Attributs syn de IDC.
-- On vérifie qu'on a obtenu ce qu'on cherchait.
#attIDC {
local
do
	-- On fait directement remonter le ni de IDC.
	IDC^klassS := IDC^klass;
	IDC^niS := IDC^ni;
end
}

-- (86)
IDC -> pt identc #attIDC1 IDC #attIDC ;

-- Attributs inh de IDC1.
#attIDC1 {
local
  ni : NamespaceInfo;
	k : Klass;
do
  ni := null;
	k := null;
  -- On cherche si on a bien obtenu un namespace précédemment
	-- Comme on n'a pas de classe interne, on doit avoir ni.ni.ni.X
 	if (IDC^ni = null) then
	  -- Si le ni de IDC est null, on a eu le chemin d'une classe à l'étape d'avant : erreur.
		error(INVALID_PATH);
	else
	  -- On recherche l'existence d'identc, d'abord dans les ns, 
		-- en précisant le ns précédent en parent.
		ni := IDC^tns.lookup(identc^txt, IDC^ni, IDC^listeNi);
  	if (ni = null) then
			-- On cherche si ce n'est pas une classe, avec le même ns en parent.
			k := IDC^tklass.lookup(identc^txt, IDC^ni, IDC^listeNi);
			if (k = null) then
			  error(INVALID_PATH);
			end
		end
	end
  IDC1^tns := IDC^tns;
  IDC1^tklass := IDC^tklass;
	IDC1^klass := k;
  IDC1^ni := ni;
  IDC1^listeNi := IDC^listeNi;
  IDC1^indentation := IDC^indentation + 1;
end
}

-- Attributs syn de IDC.
#attIDC {
local 
do
  -- On propage ce qu'il y a à propager
	IDC^klassS := IDC1^klassS;
	IDC^niS := IDC1^niS;
end
}


-- (87) : Définition d'une classe (peut etre en dehors d'un namespace)
ENTITE -> #attACCES ACCES class identc #attHERITAGE HERITAGE aco #attDEFS DEFS acf #attENTITE;

-- Attributs inh de ACCES.
#attACCES {
local
do
  write("(87) Definition d'une classe.\n");
  ACCES^indentation := ENTITE^indentation + 1;
end
}

-- Attributs inh de HERITAGE.
-- Vérifie que identc n'est pas déjà utilisé (par une classe ou un namespace).
#attHERITAGE {
local
do
  -- Si identc est une clef dans la TDSKlass, erreur.
  if (ENTITE^tklass.exists(identc^txt, ENTITE^ni, ENTITE^listeNi)) then
     error(IDENT_TAKEN, identc^txt);
  end 
  if (ENTITE^tns.exists(identc^txt, ENTITE^ni, ENTITE^listeNi)) then
      error(IDENT_TAKEN, identc^txt);
  end
  if (ENTITE^talias.exists(identc^txt, ENTITE^ni, ENTITE^listeNi)) then
	    error(IDENT_TAKEN, identc^txt);
	end
  -- Pas de code pour cette RP.	
  HERITAGE^tns := ENTITE^tns;
	HERITAGE^tklass := ENTITE^tklass;
  HERITAGE^ni := ENTITE^ni;
	HERITAGE^listeNi := ENTITE^listeNi;
	HERITAGE^indentation := ENTITE^indentation + 1;
end
}

-- Attributs inh de DEFS.
#attDEFS {
local
	kl : Klass;
do
  write("(87) Avant les DEFS.\n");
-- ENTITE^klass.intToEnum(ACCES^acc)
	kl := new Klass(ACCES^acc, identc^txt, HERITAGE^klassS, ENTITE^ni);
	ENTITE^tklass.insert(kl);
  DEFS^tvar := ENTITE^tvar;
	DEFS^tfun := ENTITE^tfun;
	DEFS^talias := ENTITE^talias;
	DEFS^tklass := ENTITE^tklass;
	-- On peut enfin ajouter la nouvelle classe à la TDS, maintenant qu'on a la classe héritée.
	DEFS^machine := ENTITE^machine;
	DEFS^klass := kl;
	DEFS^ni := ENTITE^ni;
	DEFS^listeNi := ENTITE^listeNi;
  DEFS^indentation := ENTITE^indentation + 1;
end
}

-- Attributs syn de ENTITE.
#attENTITE {
local
do
  ENTITE^code := DEFS^code;
end
}


-- (88) : Acces 
ACCES -> public #attACCES;

#attACCES {
local
do
  ACCES^acc := 1;
end
}

-- (89)
ACCES -> private #attACCES;

#attACCES {
local
do
  ACCES^acc := 2;
end
}

-- (90)
ACCES -> #attACCES;

#attACCES {
local
do
  ACCES^acc := 3;
end
}


-- (91) : Heritage.
HERITAGE -> #attHERITAGE;

#attHERITAGE {
local 
do
  write("(91) Pas d'héritage.\n");
  -- Aucun héritage
	HERITAGE^klassS := null;
end
}

-- (92)
HERITAGE -> dpts identc #attIDC IDC #attHERITAGE;

#attIDC {
local 
  ni : NamespaceInfo;
	k : Klass;
do
	-- On recherche l'existence d'identc, d'abord dans les ns, 
	-- en précisant le ns de HERITAGE comme parent.
  k := null;
  ni := HERITAGE^tns.lookup(identc^txt, HERITAGE^ni, HERITAGE^listeNi);
  if (ni = null) then
		-- On cherche si ce n'est pas une classe, avec le même ns en parent.
		k := HERITAGE^tklass.lookup(identc^txt, HERITAGE^ni, HERITAGE^listeNi);
		if (k = null) then
		  error(INVALID_PATH);
		end
	end
  IDC^tns := HERITAGE^tns;
  IDC^tklass := HERITAGE^tklass;
	IDC^ni := ni;
  IDC^listeNi := HERITAGE^listeNi;
	IDC^klass := k;
  IDC^indentation := HERITAGE^indentation + 1;
end
}

#attHERITAGE {
local 
do
	-- On renvoie la classe dont on hérite.
  if (IDC^klassS = null) then
    error(INVALID_PATH);
  end
	HERITAGE^klassS := IDC^klassS;
end
}


-- (93)
DEFS -> #attDEFS ;

#attDEFS {
local
do
  -- Pas de code ici.
  DEFS^code := "";
end
}

-- (94)
DEFS -> #attACCES ACCES #attDEF DEF #attDEFS1 DEFS #attDEFS;

-- Attributs inh de ACCES.
#attACCES {
local
do
  ACCES^indentation := DEFS^indentation + 1;
end
}

-- Attributs inh de DEF.
#attDEF {
local
do
	DEF^machine := DEFS^machine;
	DEF^tvar := DEFS^tvar;
	DEF^tfun := DEFS^tfun;
	DEF^talias := DEFS^talias;
	DEF^klass := DEFS^klass;
	DEF^tklass := DEFS^tklass; 
  DEF^ni := DEFS^ni;
	DEF^listeNi := DEFS^listeNi;
	DEF^accH := ACCES^acc;
  DEF^indentation := DEFS^indentation + 1;
end
}

-- Attributs inh de DEFS1.
#attDEFS1 {
local
do
	DEFS1^machine := DEFS^machine;
	DEFS1^tvar := DEFS^tvar;
	DEFS1^tfun := DEFS^tfun;
	DEFS1^talias := DEFS^talias;
	DEFS1^tklass := DEFS^tklass;
	DEFS1^klass :=DEFS^klass;
	DEFS1^ni := DEFS^ni;
  DEFS1^listeNi := DEFS^listeNi;
  DEFS1^indentation := DEFS^indentation + 1;
end
}

-- Attributs syn de DEFS.
#attDEFS {
local
do
  DEFS^code := DEF^code
	           + DEFS1^code;
end
}


-- (95)
DEF -> #attTYPE TYPE ident #attDECL DECL #attDEF ;

-- Attributs inh de TYPE.
#attTYPE {
local
do
  TYPE^talias := DEF^talias;
  TYPE^tklass := DEF^tklass;
	TYPE^ni := DEF^ni;
	TYPE^listeNi := DEF^listeNi;
	TYPE^indentation := DEF^indentation + 1;
end
}

#attDECL {
local
  name : String;
	k : Klass;
do
  k := DEF^klass;
	name := k.name();
  -- Normalement impossible de rentrer dans ce cas (ident != identc)
	if (name.equals(ident^txt)) then
		write("WOW");
		error(DEFINITION_SAME_NAME_CLASS, ident^txt);
	end
  write("(95) Definition de : " + ident^txt + "\n");
	DECL^tvar := DEF^tvar;
	DECL^tfun := DEF^tfun;
	DECL^talias := DEF^talias;
  DECL^tklass := DEF^tklass;
  DECL^klass := DEF^klass;
	DECL^typeH := TYPE^type;
	DECL^nom := ident^txt;
	DECL^machine := DEF^machine;
	DECL^indentation := DEF^indentation + 1;
end
}

#attDEF {
local
  code : String;
	fi : FunctionInfo;
do
  code := "";
	fi := DECL^funInfo;
  -- Si funInfo est null, c'est une def d'attribut.
	if (fi = null) then
		if (DEF^klass.attributeExists(ident^txt)) then
		  error(ALREADY_ATTRIBUTE, ident^txt, DEF^klass.name());			
		else
		  DEF^klass.addAttribute(ident^txt, DEF^klass.intToEnum(DEF^accH), TYPE^type);
		end
	else
		match fi
		with MethodInfo then
			if (DEF^klass.methodExists(fi)) then
		  	error(ALREADY_METHOD, ident^txt, DEF^klass.name());			
			else
		 		DEF^klass.addMethod(ident^txt, DEF^klass.intToEnum(DEF^accH), DECL^funInfo);		
			  code := DEF^machine.generateMethodDeclaration(fi, DECL^code);			
			end
		else
			error(NOT_A_METHOD);
		end
	end
	DEF^code := code;
end
}


-- (96) : Constructeur.
DEF  ->  identc #attPARFS paro PARFS parf #attBASE BASE #attBLOC BLOC #attDEF ;
global
	tvparams : VariableTable;

-- Init des attributs hérités pour PARFS.
#attPARFS {
local
do
	if (DEF^klass.name() != identc^txt) then
		error(CONSTR_NOT_NAME_CLASS,identc^txt,DEF^klass.name());
	end
	tvparams := new VariableTable(DEF^tvar);
  -- On crée une TDSvar fille pour la passer à PARFS.
  PARFS^tvar := tvparams;
  PARFS^tfun := DEF^tfun;
	PARFS^talias := DEF^talias;
	-- Creation de la FunctionInfo avec le type retour.
  PARFS^funInfoH := new ConstructorInfo(DEF^klass.intToEnum(DEF^accH), DEF^klass, DEF^machine.functionReturn());
  -- Initialisation du compteur de parametres.
  PARFS^cParam := 0;
  PARFS^machine := DEF^machine;
	PARFS^ni := DEF^ni;
  PARFS^listeNi := DEF^listeNi;
	PARFS^indentation := DEF^indentation + 1;	
end
}

-- Init des attributs hérités pour PARFS.
#attBASE {
local
do
  BASE^machine := DEF^machine;
	BASE^tvar := DEF^tvar;
	BASE^tfun := DEF^tfun;
	BASE^talias := DEF^talias;
	BASE^tklass := DEF^tklass;
	BASE^ni := DEF^ni;
	BASE^listeNi := DEF^listeNi;
	BASE^klass := DEF^klass;
	BASE^indentation := DEF^indentation + 1;
end
}

-- Ajout de la FunctionInfo à la tfun de BLOC.
-- Passage de la FunctionInfo à BLOC.
#attBLOC {
local
  tf : FunctionTable;
  fi : FunctionInfo;
do
  tf := DEF^tfun;
  fi := PARFS^funInfo;
 	BLOC^tfun := tf;
  BLOC^indentation := DEF^indentation + 1;	
	BLOC^funInfoH := fi;
  BLOC^tvar := new VariableTable(tvparams);
	BLOC^talias := DEF^talias;
	BLOC^machine := DEF^machine;
	BLOC^ni := DEF^ni;
	BLOC^listeNi := DEF^listeNi;
  BLOC^klass := DEF^klass;
end
}

-- Génération du constructeur + GC
#attDEF {
local
	fi : FunctionInfo;
do
	fi := PARFS^funInfo;
	match fi
	with ConstructorInfo then
		DEF^klass.addConstructor(fi);
	  DEF^code := DEF^machine.generateConstructorDeclaration(fi, BASE^ci, BASE^code, BLOC^code);			
	else
		error(NOT_A_CONSTR);
	end
end
}

-- (97) : Appel eventuel au constructeur de la classe parente.
BASE -> #codeVide ;

#codeVide {
local
do
	BASE^code := "";
  BASE^ci := null;
end
}


-- (98)
BASE -> dpts base #attES paro ES parf #validGC ;

-- Attributs inh de ES.
-- Verification que l'appelant est une fonction.
#attES {
local
do
  if (BASE^klass.parent() = null) then
	  error(NO_PARENT_CLASS,BASE^klass.name());
	end 
  ES^typesParams := new ArrayList<Type>();
  ES^codeH := "";
	ES^tvar := BASE^tvar;
	ES^tfun := BASE^tfun;
	ES^talias := BASE^talias;
	ES^tklass := BASE^tklass;
	ES^tns := BASE^tns;
	ES^machine := BASE^machine;
	ES^ni := BASE^ni;
  ES^indentation := BASE^indentation + 1 ; 
  ES^klass := BASE^klass;
end
}

-- Verification qu'il existe bien un constructeur parent avec cette signature.
#validGC {
local
	ci : ConstructorInfo;
	k : Klass;
do
  k := BASE^klass.parent();
	ci := k.lookupConstructor(ES^typesParamsS);
	if (ci = null) then
	  error(NO_CONSTR_WITH_SUCH_PARS, BASE^klass.name());
	end
	BASE^code := ES^code ;
  BASE^ci := ci;
end
}


---- (99) Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF -> MODE TYPE ident ;
--
---- (100)
--MODE -> ref ;
--
---- (101)
--MODE -> out ; 


-- (102)
F -> true #attF ;

-- Set de l'attribut de type de F pour indiquer qu'il s'agit d'un booléen.
-- Génération du code pour load la valeur du booléen dans la mémoire.
#attF {
local
  t : BooleanType;
	rw : RegisterWrapper;
  r : Register;
do
  -- Creation du type et du registre.
  t := new BooleanType();
  rw := new RegisterWrapper();
	-- Set de l'attribut type.
	F^type := t;
	-- Génération du code, et set de l'attribut le contenant.
  F^code := F^machine.generateLoadConstant(new ConstantInfo(t, true), rw); 
	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
	r := rw.get();
	F^reg := r;
	F^regAdr := null;
  -- Une expression de base ne peut representer une variable.
  -- Donc pas de vi.
  F^estVar := false;
	F^vi := null;
end
}


-- (103)
F -> false #attF;

-- Set de l'attribut de type de F pour indiquer qu'il s'agit d'un booléen.
-- Génération du code pour load la valeur du booléen dans la mémoire.
#attF {
local
  t : BooleanType;
	rw : RegisterWrapper;
  r : Register;
do
  -- Creation du type et du registre.
  t := new BooleanType();
  rw := new RegisterWrapper();
	-- Set de l'attribut type.
	F^type := t;
	-- Génération du code, et set de l'attribut le contenant.
  F^code := F^machine.generateLoadConstant(new ConstantInfo(t, false), rw); 
	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
	r := rw.get();
	F^reg := r;
	F^regAdr := null;
  -- Une expression de base ne peut representer une variable.
  -- Donc pas de vi.
  F^estVar := false;
	F^vi := null;
end
}


-- (104)
F -> this #attFX FX #attF ;

-- Attributs inh de FX.
#attFX {
local
  listeDepl : DisplacementList ;
  info : SymbolInfo; 
	rw : RegisterWrapper;
  code : String;
do
  if (F^klass = null) then
	  error(NOT_IN_A_CLASS);
	end
--Initialisations.
  rw := new RegisterWrapper();
	listeDepl := new DisplacementList();
	info := null;
	listeDepl.add(F^klass.thisDisplacement(F^machine), false);
	FX^listeDepl := listeDepl;
	FX^estFun := false;
	FX^typeH := F^klass;
	FX^nom := F^klass.name();
	FX^tvar := F^tvar;
	FX^tfun := F^tfun;
	FX^talias := F^talias;
	FX^tklass := F^tklass;
	FX^machine := F^machine;
	FX^ni := F^ni;
  FX^indentation := F^indentation + 1 ; 
  FX^klass := F^klass;
  code := F^machine.generateLoadFromStack(F^klass.thisDisplacement(F^machine), rw);
  FX^regH := rw.get();
	FX^codeH := code;
end
}

-- Attributs syn de F.
#attF {
local
  listeDepl : DisplacementList; 
	ra : RegisterWrapper;
	rv : RegisterWrapper;
	reg : Register; 
	regAdr : Register;
	estVar : boolean;
  code : String;
do
  listeDepl := FX^listeDeplS;
	rv := new RegisterWrapper();
	ra := new RegisterWrapper();
	code := FX^code 
	      + F^machine.generateComment("(104) Make address:", "\t\t") 
	      + F^machine.generateMakeAddress(listeDepl, FX^reg, rv, ra)
				+ F^machine.generateComment("(104) End make address.", "\t\t");
  reg := rv.get();
	regAdr := ra.get();
	if (listeDepl.size() != 1) then --> 1) then
    -- On a pas un this seul, il peut s'agir d'une variable si FX le permet.
		estVar := FX^estVar;
	else 
	  -- Le this seul, pas une variable.
	  estVar := false;
	end
    -- Sinon, accès direct à this, on ne génère pas de code.	
	F^vi := null;
	F^code := code;
  F^estVar := estVar;
  F^type := FX^type;
	F^reg := reg;
	F^regAdr := regAdr;
end
}


-- (105) : base = super
F -> base #attFX FX #attF ;
global
  kl : Klass;

-- Attributs inh de FX.
#attFX {
local
  listeDepl : DisplacementList ;
do
  kl := null;
  if (F^klass = null) then
	  error(NOT_IN_A_CLASS);
	else
	  kl := F^klass.parent();
		if (kl = null) then
		  error(NO_PARENT_CLASS, F^klass.name());
		end
	end
  --Initialisations.
  listeDepl := new DisplacementList();
	listeDepl.add(0, false);
	FX^listeDepl := listeDepl;
	-- On a un appel de fonction.
	FX^estFun := true;
	FX^klass := kl;
	FX^typeH := kl;
	FX^nom := kl.name();
	FX^tvar := F^tvar;
	FX^tfun := F^tfun;
	FX^talias := F^talias;
	FX^tklass := F^tklass;
	FX^machine := F^machine;
	FX^ni := F^ni;
  FX^listeNi := F^listeNi;
	FX^indentation := F^indentation + 1 ; 
  FX^klass := F^klass;
  FX^regH := null; --TODO
  FX^codeH := "";
end
}

-- Attributs syn de F.
#attF {
local
  listeDepl : DisplacementList; 
  reg : Register;
	regAdr : Register;
	rv : RegisterWrapper;
	ra : RegisterWrapper;
	code : String;
do
  listeDepl := FX^listeDeplS;
  rv := new RegisterWrapper();
	ra := new RegisterWrapper();
	code := FX^code
		    + F^machine.generateComment("(105) Make address:", "\t\t")
		    + F^machine.generateMakeAddress(listeDepl, FX^reg, rv, ra)
				+ F^machine.generateComment("(105) End make address.", "\t\t"); 
	reg := rv.get();
	regAdr := ra.get();
	F^vi := null;
	F^code := code;
  F^estVar := false;
  F^type := kl;
	F^reg := reg;
	F^regAdr := regAdr;
end
}


-- (106) objet null
F -> null2 #attF ;

#attF {
local
do
	F^estVar := false;
	F^vi := null;
	F^code := F^machine.generateComment("(106) Null object: NO CODE", "\t\t");
	F^type := null;
	F^reg := null;
	F^regAdr := null;
end
}


-- (107)
F -> new identc #attIDC IDC #attES paro ES parf #attF ;

#attIDC {
local 
  ni : NamespaceInfo;
	k : Klass;
do
	-- On recherche l'existence d'identc, d'abord dans les ns, 
	-- en précisant le ns de F comme parent.
  k := null;
  ni := F^tns.lookup(identc^txt, F^ni, F^listeNi);
  if (ni = null) then
		-- On cherche si ce n'est pas une classe, avec le même ns en parent.
		k := F^tklass.lookup(identc^txt, F^ni, F^listeNi);
		if (k = null) then
		  error(INVALID_PATH);
		end
	end
  IDC^tns := F^tns;
  IDC^tklass := F^tklass;
	IDC^klass := k;
	IDC^ni := ni;
  IDC^listeNi := F^listeNi;
  IDC^indentation := F^indentation + 1;
end
}

#attES{
local 
do
  ES^typesParams := new ArrayList<Type>();
  ES^codeH := "";
	ES^tvar := F^tvar;
	ES^tfun := F^tfun;
	ES^talias := F^talias;
	ES^tklass := F^tklass;
	ES^machine := F^machine;
	ES^ni := F^ni;
	ES^listeNi := F^listeNi;
  ES^indentation := F^indentation + 1 ; 
  ES^klass := F^klass;
end
}

-- Verification qu'il existe bien un constructeur avec cette signature.
#attF {
local
	ci : ConstructorInfo;
do
  ci := IDC^klassS.lookupConstructor(ES^typesParamsS);
	if (ci = null) then
	  error(NO_CONSTR_WITH_SUCH_PARS, identc^txt);
	end
	F^code := ES^code + F^machine.generateConstructorCall(ci);
	F^estVar := false;
	F^vi := null;
	F^type := IDC^klassS;
  F^reg := null;
	F^regAdr := null;
end
}


end
