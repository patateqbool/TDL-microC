----------------------------------------------------
-- Grammaires de MC  et MCS                       --
----------------------------------------------------

--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : AbstractMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;

-- Dernières updates : attributs noirs et verts.

inh tvar : VariableTable for
         ENTITES, ENTITE, BLOC, F, INSTS, INST, SIX, E, AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX,
				 R, RX, T, TX, FX, ES, ESX
         ;

inh talias : AliasTable for 
         ENTITES, ENTITE, BLOC, STYPE, TYPE, F, INSTS, INST, SIX, CHAMPS, CHAMP, E,
				 AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX,
         R, RX, T, TX, FX, ES, ESX
         ; --Table des alias contenant les types propres au programme.

syn taliasS : AliasTable for
         ENTITE
				 ;

inh tfun : FunctionTable for
         ENTITES, ENTITE, BLOC, F, INSTS, INST, SIX, E, AFFX, A, AX, DECL, FONCTION, PARFS, PARF, PARFSX,
				 R, RX, T, TX, FX, ES, ESX
				 ;

syn tfunS : FunctionTable for 
         ENTITE
         ;

syn type : Type for
         TYPE, STYPE, PTRS, F, CHAMP, E, A, AFFX, AX, FX,
				 R, RX, T, TX 
         ;

inh typesParams : List<Type> for
         ES, ESX
				 ;
 
syn typesParamsS : List<Type> for
         ES, ESX
				 ;

inh typeH : Type for
         PTRS, DECL, FONCTION, FX, AFFX
         ;

inh funInfoH : FunctionInfo for
         PARFS, PARFSX, BLOC, INSTS, INST, SIX, PARF--, FX
				 ;

syn funInfo : FunctionInfo for
         PARF, PARFS, PARFSX, DECL, FONCTION
	       ;

-- Attribut servant à savoir du quantième paramètre il s'agit. 
inh cParam : int for
         PARFS, PARF, PARFSX
				 ;

inh nom : String for 
         DECL, FONCTION, FX
				 ;

syn nomS : String for 
         CHAMP
				 ;

syn code : String for
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
				 ;

inh codeH : String for
				 ES, ESX
				 ;

syn op : Integer for -- Operator for
				 OPADD, OPMUL, OPUN, RX, TX
				 ;

syn oprel : Integer for -- : RelationalOperator for
				 OPREL, AX
				 ;

syn reg : Register for
				 F, FX, T, TX, R, RX, E, AFFX, A, AX
				 ;
				 
syn estVar : boolean for
         R, RX, FX, T, TX, E, A, AFFX, AX, F
				 ;


inh estFun : boolean for
         FX
				 ;

inh affPossible : boolean for
         AFFX
         ;

inh listeDepl : DisplacementList for
				 FX
				 ;

syn listeDeplS : DisplacementList for
				 FX
				 ;

syn vi : VariableInfo for
         R, T, F, E, A
			   ;

inh champs : StructFields for
				 CHAMPS
				 ;

syn champsS : StructFields for
				 CHAMPS
				 ;

inh ni : NamespaceInfo for 
         ENTITE, PARF, INST, F, FX, ENTITES, FONCTION, DECL,
				 PARFS, PARFSX, INSTS, BLOC, AFFX, E, SIX, A, R, AX, T, RX,
				 TX, ES, ESX
				 ;

--inh rechKlass : boolean for
--         IDC
--				 ;
--
--syn klassHerit : Klass for
--				 HERITAGE, IDC
--				 ;
--
--inh tklass : KlassTable for
--				 ;	
--
---- TODO: on aura besoin de tklassS
--inh tns : NamespaceTable for
--				 ;	
--
--syn niS : NamespaceInfo for
--				 IDC
--				 ;
--
--syn acc : Integer for
--				 ACCES
--				 ;
--
--inh acch : Integer for
--
--				 ;
--
--inh nomIDC: String for
--				 IDC
--				 ;
-- ces attributs permettent de recuperer les instructions du code ASM inline       
--syn code_asm : STRING for ASM;
-- la TDS courante
--inh tds_asm : TDS for ASM;

--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
-- TODO décommenter plus tard.
-- compil ASM;

-- (1) : REGLES DE PRODUCTION
PROGRAMME -> #attENTITES ENTITES #attPROGRAMME;
global
   machine : AbstractMachine;
-- Transmission de la machine cible  (choisie par l'option -m au lancement) 
#attENTITES {
local
do
  machine := PROGRAMME^source.getMachine();
  if machine = null then
    error(NO_MACH, PROGRAMME^source.getMachName());
  else
    ENTITES^machine := machine;
  end
  ENTITES^tvar := new VariableTable();
  ENTITES^tfun := new FunctionTable();
  ENTITES^talias := new AliasTable();
	ENTITES^machine := machine;
	ENTITES^ni := new DefaultNamespaceInfo();
end
}
-- Ecrit le code dans un fichier
#attPROGRAMME {
local
do
   machine.writeCode(PROGRAMME^source.getFileName(), ENTITES^code); 
end
}

-- (2)
ENTITES -> #attENTITES ;

-- Fin du code.
#attENTITES {
local
do
  ENTITES^code := "";
end
}

-- (3)
ENTITES -> #attENTITE ENTITE #attENTITES1 ENTITES #attENTITES ;

-- Passage des attributs hérités.
#attENTITE {
local
do
  ENTITE^machine := ENTITES^machine;
	ENTITE^tvar := ENTITES^tvar;
	ENTITE^tfun := ENTITES^tfun;
	ENTITE^talias := ENTITES^talias;
	ENTITE^ni := ENTITES^ni;
end
}

-- Transmission des TDS mise à jour après ENTITE à ENTITES1.
-- (La transmission de ENTITES à ENTITE se fait, normalement, automatiquement).
#attENTITES1 {
local
do
  ENTITES1^tvar := ENTITES^tvar;
  ENTITES1^tfun := ENTITE^tfunS;
	ENTITES1^talias := ENTITE^taliasS;
	ENTITES1^machine := ENTITES^machine;
	ENTITES1^ni := ENTITES^ni;
end
}

-- Concaténation et passage du code.
#attENTITES {
local
do
  ENTITES^code := ENTITE^code + ENTITES1^code;
end
}

---------------------------------------------
-------- DEFINITION D'UN NOM DE TYPE --------
--      (commence avec une majuscule)      --
---------------------------------------------

-- (4)
ENTITE -> typedef #attTYPE TYPE identc pv #attENTITE ;

#attTYPE {
local
do
  TYPE^talias := ENTITE^talias;
end
}

-- Ajout de identc à la table des alias.
-- Vérifie que identc n'est pas déjà utilisé (par une variable, une fonction ou un autre alias).
#attENTITE {
local
  info : SymbolInfo;
  infoVar : VariableInfo;
	t : Type;
	ta : AliasTable;
do
  ta := ENTITE^talias;
  info := ENTITE^tvar.lookup(identc^txt, ENTITE^ni, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, identc^txt);
  else
     info := ENTITE^tfun.lookup(identc^txt, ENTITE^ni, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
    if info != null then
        error(IDENT_TAKEN, identc^txt);
     -- Sinon, on peut ajouter le nouveau type à la TDS.
    else
		  -- Vérification dans la table des alias.
			t := ta.lookup(identc^txt);
			if (t != null) then
			  error(IDENT_TAKEN, identc^txt);
      else
        ta.insert(identc^txt, TYPE^type );
			end
    end
  end  
	-- On fait remonter la nouvelle talias.
	ENTITE^taliasS := ta;
	-- Les autres tds ne sont pas modifiées.
	ENTITE^tfunS := ENTITE^tfun;
	-- Pas de code pour cette RP.
	ENTITE^code := ENTITE^machine.generateComment("Typedef mècouïes", "\t\t");
end
}

---------------------------------------------------------
-- DEFINITION D'UNE VARIABLE GLOBALE OU D'UNE FONCTION --
--            (commence par une minuscule)             --
---------------------------------------------------------

-- (5)
ENTITE -> #attTYPE TYPE ident #attDECL DECL #attENTITE; 

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := ENTITE^talias;
end
}

-- Attributs inh de DECL.
-- On n'ajoute pas encore la variable / fonction à la table car on ne sait pas encore la nature.
-- Passage du nom et du type retour pour la récursivité en cas de declaration de fonction.
#attDECL {
local
  info : SymbolInfo;
	t : Type;
do
  DECL^nom := ident^txt;
  DECL^typeH := TYPE^type;
  DECL^tvar := ENTITE^tvar;
  DECL^tfun := ENTITE^tfun;
	DECL^talias := ENTITE^talias;
	DECL^machine := ENTITE^machine;
	DECL^ni := ENTITE^ni;
end
}

-- Attributs syn de ENTITE.
-- On effectue ici la vérification de disponibilité du nom,
-- et on effectue l'ajout dans la TDS appropriée.
#attENTITE {
local
  tv : VariableTable;
	tf : FunctionTable;
	fi : FunctionInfo;
  info : SymbolInfo;
	t : Type;
	b : boolean;
do
	write("À la fin de (5)\n");
  fi := DECL^funInfo;
  tv := ENTITE^tvar;
	tf := ENTITE^tfun;
  -- Si l'ident apprait dans tvar ou talias, on a une erreur.
	info := ENTITE^tvar.lookup(ident^txt, ENTITE^ni, true);
  if (info != null) then
    error(IDENT_TAKEN, ident^txt);
  else
		t := ENTITE^talias.lookup(ident^txt);
		write("(5) info not null\n");
		if (t!= null) then
		  error(ALREADY_AN_ALIAS, ident^txt);
	  else
			write("(5) ident not already taken for type\n");
		  --info := tf.lookup(ident^txt, ENTITE^ni, true);
      if (fi = null) then
				write("(5) It's a variable declaration\n");
	      -- On a une variable.
        if (tf.exists(ident^txt, ENTITE^ni, fi)) then
				  -- Dans ce cas, il ne faut pas que l'ident soit pris par une fonction.
          error(IDENT_TAKEN, ident^txt);
        else
					write("(5) Add variable \\o/\n");
				  -- Si ce n'est pas le cas, on peut add la variable à la tvar.
          tv.insert(ident^txt, TYPE^type, ENTITE^ni);
				end
	   -- else
			--	write("(5) It's a function declaration\n");
        -- On a une fonction.
				-- On ajoute la fonction à la tfun, 
				-- si la valeur retour est false c'est qu'on avait déjà une fonction
				-- avec la même signature. Dans ce cas, erreur.
				--if (!(tf.insert(ident^txt, ENTITE^ni, fi))) then 
				  --error(ALREADY_A_FUN_WITH_THAT_SIGN, ident^txt);
				--end
	    end
    end
	end
  ENTITE^tfunS := tf ;
	-- La talias n'est pas modifiée par cette RP.
	ENTITE^taliasS := ENTITE^talias ;
  -- Passage du code généré par DECL à ENTITE.
	write("Code (5) : " + DECL^code + "\n");
  ENTITE^code := DECL^code;
end
}


-- (6) : VARIABLE
DECL -> pv #attDECL;

-- Attributs syn de DECL.
-- On génère le code d'allocation mémoire pour cette variable.
-- funInfo est à null car il ne s'agit pas d'une fonction.
#attDECL {
local
	code : String;
do
	code := DECL^machine.generateAllocateInStack(DECL^typeH);
  DECL^code := code;
	DECL^funInfo := null;
	write("À la fin de (6) Hodor y meurt. Code: " + code + "\n");
end
}


-- FONCTION (7)
DECL -> #attFONCTION FONCTION #attDECL;

-- Attributs inh de FONCTION.
-- On fait passer typeH qui servira à créer le functionInfo.
#attFONCTION {
local
do
  FONCTION^nom := DECL^nom;
  FONCTION^typeH := DECL^typeH;
	FONCTION^tvar := DECL^tvar;
	FONCTION^talias := DECL^talias;
	FONCTION^tfun := DECL^tfun;
	FONCTION^machine := DECL^machine;
	FONCTION^ni := DECL^ni;
end
}

-- "Mise à jour" des TDS de DECL.
#attDECL {
local
	code : String;
do
	code := FONCTION^code;
  -- Passage du code de declaration de la fonction à DECL.
  DECL^code := code;
	write("Code (7) : " + code + "\n");
	-- Passage du functionInfo.
	DECL^funInfo := FONCTION^funInfo;
end
}


-- (8)
FONCTION -> #attPARFS paro PARFS parf #attBLOC BLOC #attFONCTION ;

global
	tvparams : VariableTable;

-- Init des attributs hérités pour PARFS.
#attPARFS {
local
do
	tvparams := new VariableTable(FONCTION^tvar);
  -- On crée la TDSvar fille pour la passer à PARFS.
  PARFS^tvar := tvparams;
  PARFS^tfun := FONCTION^tfun;
	PARFS^talias := FONCTION^talias;
	-- Creation de la FunctionInfo avec le type retour.
  PARFS^funInfoH := new FunctionInfo(FONCTION^nom, FONCTION^typeH, FONCTION^ni);
  -- Initialisation du compteur de parametres.
  PARFS^cParam := 0;
  PARFS^machine := FONCTION^machine;
	PARFS^ni := FONCTION^ni;
	write("Regle (8)\n");
end
}

-- Ajout de la FunctionInfo à la tfun de BLOC.
-- Passage de la FunctionInfo à BLOC.
#attBLOC {
local
  tf : FunctionTable;
  fi : FunctionInfo;
do
  tf := FONCTION^tfun;
  fi := PARFS^funInfo;
  
	if (!(tf.insert(FONCTION^nom, fi))) then
		error(ALREADY_A_FUN_WITH_THAT_SIGN, FONCTION^nom);
	end
  
	BLOC^tfun := tf;
	BLOC^funInfoH := fi;
  BLOC^tvar := new VariableTable(tvparams);
	BLOC^talias := FONCTION^talias;
	BLOC^machine := FONCTION^machine;
	BLOC^ni := FONCTION^ni;
	write("Regle (8) : milieu\n");
end
}

-- Generation du code de la declaration de la fonction.
#attFONCTION {
local
	code : String;
do
	code := FONCTION^machine.generateFunctionDeclaration(PARFS^funInfo , BLOC^code);
	write("Code (8) : " + code + "\n");
  FONCTION^code := code; 
	FONCTION^funInfo := PARFS^funInfo;
end
}

-------------------------------------------
-------- PARAMETRES DE FONCTION -----------
-------------------------------------------

-- (9)
PARFS -> #attPARFS ;

#attPARFS {
local
do
	write("Regle (9)\n");
  -- fin de la liste des parmètres, on transmet le fi 'final'.
  PARFS^funInfo := PARFS^funInfoH ;
end
}


-- (10)
PARFS -> #attPARF PARF #attPARFSX PARFSX #attPARFS ;

-- Passage des params inh de PARF.
#attPARF {
local
  c : int;
do
	write("Regle (10)\n");
  -- Incrementation du compteur de parametres.
  c := PARFS^cParam + 1;
  PARF^cParam := c;
	-- Passage des tds.
  PARF^tvar := PARFS^tvar;
  PARF^tfun := PARFS^tfun;
  PARF^talias := PARFS^talias;
	PARF^machine := PARFS^machine;
	PARF^ni := PARFS^ni;
  -- Passage de c à PARFSX aussi.
	PARFSX^cParam := c;
end
}

-- Passage des tds à PARFSX.
#attPARFSX {
local
  fi : FunctionInfo ; 
do
  PARFSX^funInfoH := PARF^funInfo;
  write("(10) middle : passage tvar\n" + PARFS^tvar + "\n");
	PARFSX^tvar := PARFS^tvar;
	PARFSX^tfun := PARFS^tfun;
	PARFSX^talias := PARFS^talias;
	PARFSX^machine := PARFS^machine;
	PARFSX^ni := PARFS^ni;
end
}

-- On fait remonter la tvar contenant les params de la fonction.
-- Ainsi que le fi final.
#attPARFS {
local
do
  PARFS^funInfo := PARFSX^funInfo;
end
}

-- (11)
PARFSX -> #attPARFSX ;

-- Passage de FunctionInfo (transformation d'attribut hérité en attribut synthétisé).
#attPARFSX {
local
do
  PARFSX^funInfo := PARFSX^funInfoH ;
end
}

 
-- (12)
PARFSX -> virg #attPARF PARF #attPARFSX1 PARFSX #attPARFSX ;

-- Passages des attributs.
#attPARF {
local
  c : int;
do
  -- Incrementation du compteur de parametres.
  c := PARFSX^cParam + 1;
  PARF^cParam := c;
	-- Passage des tds.
  PARF^tvar := PARFSX^tvar;
  PARF^tfun := PARFSX^tfun;
  PARF^talias := PARFSX^talias;
	PARF^machine := PARFSX^machine;
	PARF^ni := PARFSX^ni;
  -- On passe aussi c à PARFSX1.
  PARFSX1^cParam := c;
end
}

-- Ajout du paramètre de PARF au functionInfo et passage à PARFSX1.
-- Passage des tds.
#attPARFSX1 {
local
do
  PARFSX1^funInfoH := PARF^funInfo;
	PARFSX1^tvar := PARFSX^tvar;
	PARFSX1^tfun := PARFSX^tfun;
	PARFSX1^talias := PARFSX^talias;
	PARFSX1^machine := PARFSX^machine;
	PARFSX1^ni := PARFSX^ni;
end
}

-- Transmission de FunctionInfo.
#attPARFSX {
local
do
  PARFSX^funInfo := PARFSX1^funInfo ;
end
}


-- (13)
PARF -> #attTYPE TYPE ident #attPARF; 

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := PARF^talias;
end
}


-- Ajout de ident à la TDS locale.
-- Vérifications concernant ident.
-- Passage du type.
#attPARF {
local
  tv : VariableTable;
	t : Type;
	info : SymbolInfo;
  fi : FunctionInfo;
do
	write("Regle (13) : " + TYPE^type + " " + ident^txt + " [" + PARF^ni.name() + "]" + "\n");
  
	tv := PARF^tvar;
  fi := PARF^funInfoH;
  -- Vérifications concernant ident.
  --info := tv.lookup(ident^txt, PARF^ni, false);
  -- Si identc est une clef dans la TDSvar, erreur.
  if (tv.exists(ident^txt, PARF^ni, false)) then
    error(IDENT_TAKEN, ident^txt);
  else
    --info := PARF^tfun.lookup(ident^txt, PARF^ni, false);
    -- De même si identc est déjà utilisé dans la TDSfun.
    if (PARF^tfun.exists(ident^txt, PARF^ni)) then
      error(IDENT_TAKEN, ident^txt);
    else
		  t := PARF^talias.lookup(ident^txt);
			-- De même dans talias.
			if (t != null) then
			  error(IDENT_TAKEN, ident^txt);
			else
			  -- Ajout de ident à la TDS locale et au fi.
			  fi.add(TYPE^type);
				write("(13) ns = " + PARF^ni.name() + ", " + fi + "\n");
        tv.insert(ident^txt, new VariableInfo(TYPE^type, fi.displacement(PARF^cParam), PARF^ni));
        write("(13) Après ajout :\n" + tv + "\n");      
			end
		end
  end
	PARF^funInfo := fi;
end
}


----------------------------------------------------------------
-------- LES TYPES (de base, noms, struct et pointeurs) --------
----------------------------------------------------------------

-- (14)
TYPE -> #attSTYPE STYPE #attPTRS PTRS #attTYPE;

-- Passage talias.
#attSTYPE {
local
do
  STYPE^talias := TYPE^talias;
end
}

-- Passage du type de STYPE à PTRS pour qu'il "pointeurise" la chose.
#attPTRS {
local
do
  PTRS^typeH := STYPE^type;
end
}

-- Recuperation du type final de l'expression.
#attTYPE {
local
do
  TYPE^type := PTRS^type;
end
}


-- Des * pour definir un pointeur (15)
PTRS -> #attPTRS ;

-- Passage de l'attribut hérité à celui synthétisé. 
#attPTRS {
local
do
  PTRS^type := PTRS^typeH;
end
}


-- (16)
PTRS -> mult #attPTRS1 PTRS #attPTRS ;

-- Passage du type une foix la couche de pointeur ajoutée.
#attPTRS1 {
local
do
  PTRS1^typeH := new PointerType(PTRS^typeH);
end
}

-- Passage de l'attribut type synthétisé.
#attPTRS {
local
do
  PTRS^type := PTRS1^type;
end
}


-- Types de base (17)
STYPE-> void #attSTYPE ;

#attSTYPE {
local
do
  STYPE^type := new VoidType();
end
}


-- (18)
STYPE-> int #attSTYPE ;

#attSTYPE {
local
do
  STYPE^type  := new IntegerType();
end
}


-- (19)
STYPE-> char #attSTYPE ;

#attSTYPE {
local
do
  STYPE^type  := new CharacterType();
end
}

-- (20) : Nom de type (commence par une majuscule) 
STYPE -> identc #attSTYPE ;

#attSTYPE {
local
  typeRech : Type;
do
  typeRech := STYPE^talias.lookup(identc^txt);
  -- Si identc n'est pas une clef dans la TDSvar, erreur.
  if typeRech = null then
     error(IDENT_UNDEFINED, identc^txt);
  end
  STYPE^type := typeRech;
end
}


------------------------
------ STRUCTURES ------
------------------------

-- (21)
STYPE -> struct aco #attCHAMPS CHAMPS acf #attSTYPE ;

-- Création de la liste de champs qui servira à construire le type.
#attCHAMPS {
local
do
  CHAMPS^champs := new StructFields();
	CHAMPS^talias := STYPE^talias;
end
}

-- On récupère la liste des champs, synthétisée par CHAMPS,
-- pour créer le type.
#attSTYPE {
do
  STYPE^type := new StructType(CHAMPS^champsS);
end
}


-- (22)
CHAMPS -> #attCHAMPS ;

-- Passage de l'attribut hérité à celui synthétisé.
#attCHAMPS {
local
do
  CHAMPS^champsS := CHAMPS^champs;
end
}


-- (23) : Un nom de champ commence par une minuscule.
CHAMPS -> #attCHAMP CHAMP #attCHAMPS1 CHAMPS #attCHAMPS ;

-- Passage talias.
#attCHAMP {
local
do
  CHAMP^talias := CHAMPS^talias;
end
}

#attCHAMPS1 {
local
  c : StructFields;
do
  c := CHAMPS^champs;
  if (c.exists(CHAMP^nomS)) then
	  -- si un champ porte déjà ce nom : erreur.
    error(IDENT_TAKEN, CHAMP^nomS);
  else
	  -- Sinon, on ajoute le champ au StructFields.
    c.insert(CHAMP^nomS,CHAMP^type);
   end
	 -- On passe le StructFields à CHAMPS1.
	 CHAMPS1^champs := c;
end
}

-- Passage du StructFields.
#attCHAMPS {
local
do
  CHAMPS^champsS := CHAMPS1^champsS;
end
}


-- (24) 
CHAMP -> #attTYPE TYPE ident pv #attCHAMP ;

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := CHAMP^talias;
end
}

-- Passage des attributs qui serviront à créer le champ.
#attCHAMP {
local
do
  CHAMP^nomS := ident^txt;
  CHAMP^type := TYPE^type;
end
}


----------------------------------------------------------------
----------- CORPS DE FONCTION ET BLOC D'INSTRUCTIONS -----------
----------------------------------------------------------------

-- (25)
BLOC ->  aco #attINSTS INSTS acf #attBLOC ;

-- Probablement inutile, mais passage des TDS de BLOC à INSTS.
-- Ainsi que la FunctionInfo de la fonction.
#attINSTS {
local
do
	write("Regle (25)\n");
  INSTS^tvar := BLOC^tvar;
  INSTS^tfun := BLOC^tfun;
	INSTS^talias := BLOC^talias;
	INSTS^machine := BLOC^machine;
  INSTS^funInfoH := BLOC^funInfoH;
	INSTS^ni := BLOC^ni;
end
}

-- Generation du flush de fin de bloc.
-- Passage du code généré par les INSTS (et le flush) à BLOC.
#attBLOC {
local
  code : String;
do
  code := INSTS^code;
	write("Code (25) [pre-flush] : " + code + "\n");
  code := code + BLOC^machine.generateFlush(BLOC^tvar);
	write("Code (25) : " + code + "\n");
  BLOC^code := code;
end
}



-- Instructions
-- (26) : Fin des instructions du bloc.
INSTS -> #attINSTS ;

-- Initialisation de l'attribut code (chaine vide).
#attINSTS {
local
do
	write("Regle (26)\n");
  INSTS^code := "";
end
}


-- (27)
INSTS -> #attINST INST #attINSTS1 INSTS #attINSTS ;

-- Passage du type retour de la fonction.
#attINST {
local
do
	write("Regle (27)\n");
  INST^funInfoH := INSTS^funInfoH;
	INSTS1^funInfoH := INSTS^funInfoH;
	INST^tvar := INSTS^tvar;
	INST^tfun := INSTS^tfun;
	INST^talias := INSTS^talias;
	INST^machine := INSTS^machine;
	INST^ni := INSTS^ni;
end
}

-- Passage des TDS de INST à INSTS1.
#attINSTS1 {
local
do
	write("Regle (27) : milieu : " + INST^code + "\n");
  INSTS1^tvar := INSTS^tvar;
	-- tfun, talias et machine directement hérité de INSTS.
  INSTS1^tfun := INSTS^tfun; 
	INSTS1^talias := INSTS^talias;
	INSTS1^machine := INSTS^machine;
	INSTS1^ni := INSTS^ni;
end
}

-- Concaténation des codes et passage à INSTS.
#attINSTS {
local
	code : String;
do
	code := INST^code + INSTS1^code;
  INSTS^code := code;
	write("Regle (27) : fin : " + code + "\n");
end
}


-- (28) : Declaration de variable locale avec ou sans init 
INST -> #attTYPE TYPE ident #attAFFX AFFX pv #attINST;

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := INST^talias;
end
}

-- Passage des attributs hérités de AFFX. 
#attAFFX {
local
do
  AFFX^machine := INST^machine;
	AFFX^tvar := INST^tvar;
	AFFX^tfun := INST^tfun;
	AFFX^talias := INST^talias;
	-- Une affectation est possible.
	AFFX^affPossible := true;
		-- Le type de cette affectationn doit être celui de TYPE.
	AFFX^typeH := TYPE^type;
	AFFX^ni := INST^ni;
end
}

-- Génération du code
-- On vérifie si on a TYPE ident := X; ou TYPE ident;
-- Dans le cas où l'affectation existe, on vérifie la compatibilité des types.
#attINST {
local
  nom : String;
  code : String;
	info : SymbolInfo;
	t : Type;
	tv : VariableTable;
	si : SymbolInfo;
do
  nom := ident^txt;
  tv := INST^tvar;
  --info := INST^tvar.lookup(nom, INST^ni, true);
	code := "";
  -- Si ident est une clef dans la TDSvar, erreur.
  if (INST^tvar.exists(nom, INST^ni, true)) then
     error(IDENT_TAKEN, nom);
  else
    --info := INST^tfun.lookup(nom, INST^ni, false);
    -- De même si identc est déjà utilisé dans la TDSfun.
    if (INST^tfun.exists(nom, INST^ni)) then
      error(ALREADY_A_FUNCTION_IDENT, nom);
		else
		  t := INST^talias.lookup(nom);
			-- De même pour la talias.
			if (t != null) then 
			  error(ALREADY_AN_ALIAS, nom);
			else
		    -- Sinon, on ajoute cet id à la tdsvar.
	   	  tv.insert(nom, TYPE^type, INST^ni);
				code := INST^machine.generateAllocateInStack(TYPE^type);
			end
    end
  end 
	if !(AFFX^estVar) then
    -- On a une affectation.	
		-- Verification de types inutile, elle est faite dans AFFX.
		-- On génère le code pour stocker la valeur du registre 
		-- de AFFX dans la variable qu'on vient de déclarer.
		si := tv.lookup(ident^txt, INST^ni, true);
		match si
		with VariableInfo then
		  code := code + INST^machine.generateStoreVariable(si, AFFX^reg);
		else
		  error(SHOULD_NOT_HAPPEN_SI_NOT_VI);
		end
	end
	INST^code := code;
end
}


-- (29) : Instruction expression (affectation et appel de procedure)
INST -> #attE E pv #attINST ;

#attE {
local
do
	E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
	E^ni := INST^ni;
end
}

#attINST {
local
do
	-- Remonéte du code.
	INST^code := E^code;
end
}


-- (30) : Bloc d'instructions
INST ->  #attBLOC BLOC #attINST;

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#attBLOC {
local
	tfille : VariableTable;
do
	tfille := new VariableTable(INST^tvar);
	BLOC^tvar := tfille;
	BLOC^funInfoH := INST^funInfoH;
  BLOC^ni := INST^ni;
end
}

-- La tvar de INST n'est pas modifiée par BLOC.
#attINST {
local
do
	-- Passage du code de BLOC à INST.
	-- Les instructions de fin de bloc (flush etc) sont générés dans la RP de BLOC.
	INST^code := BLOC^code;
end
}


-- (31) : Conditionnelle
INST -> si paro #attE E parf #attBLOC BLOC #attSIX SIX #attINST;

#attE {
local
do
	E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
	E^ni := INST^ni;
end
}

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#attBLOC {
local
	tfille : VariableTable;
do
	BLOC^funInfoH := INST^funInfoH;
	tfille := new VariableTable(INST^tvar);
	BLOC^tvar := tfille;
	BLOC^tfun := INST^tfun;
	BLOC^talias := INST^talias;
	BLOC^machine := INST^machine;
	BLOC^ni := INST^ni;
end
}

-- Transmission des TDS 'parentes' à SIX.
#attSIX {
local
do
	SIX^funInfoH := INST^funInfoH;
	SIX^tvar := INST^tvar;
	SIX^tfun := INST^tfun;
	SIX^talias := INST^talias;
	SIX^machine := INST^machine;
	SIX^ni := INST^ni;
end
}

#attINST {
local
	code : String;
do
	-- Génération du code pour une conditionnelle.
	code := E^code;
	-- On vérifie que le type dans la conditionnelle est bien un entier (en l'absence de booléens)
	match E^type
	with IntegerType then
		-- Si c'est le cas, on génère le code
		code := code + INST^machine.generateIfThenElse(E^reg,BLOC^code,SIX^code);
	else
		-- Sinon, on renvoie une erreur
		error(TYPE_NOT_EQUAL);
	end
	INST^code := code ;
end
}


-- (32)
SIX -> sinon #attBLOC BLOC #attSIX;

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
-- Passage du type retour de la fonction.
#attBLOC {
local
	tfille : VariableTable;
do
	BLOC^funInfoH := SIX^funInfoH;
	tfille := new VariableTable(SIX^tvar);
	BLOC^tvar := tfille;
	BLOC^tfun := SIX^tfun;
	BLOC^talias := SIX^talias;
	BLOC^machine := SIX^machine;
	BLOC^ni := SIX^ni;
end
}

-- Passage du code du BLOC à SIX.
#attSIX {
local
do
	SIX^code := BLOC^code;
end
}


-- (33)
SIX -> #attSIX ;
-- Rien à faire pour la gestion des TDS.
-- Génération d'une chaine de caractère vide.
#attSIX {
local
do
	SIX^code := "";
end
}



-- (34) : Retour de fonction.
INST ->  retour #attE E pv #attINST ;

#attE {
local
do
	write("Regle (34)\n");
	E^machine := INST^machine;
	E^tvar := INST^tvar;
	E^tfun := INST^tfun;
	E^talias := INST^talias;
	E^ni := INST^ni;
end
}

-- Vérification que E est du type retour de la fonction.
#attINST {
local
	typeRet : Type;
	code : String;
do
	write("(34) Début de la fin\n");
	
	if (INST^funInfoH = null) then
		write("(34) funInfoH est null !\n");
	end

	typeRet := INST^funInfoH.returnType();
	-- Si typeRet ne correspond pas à E^type
	-- alors erreur.
	write("(34) E^type = " + E^type + "; fi^type = " + typeRet + "\n");
	if (!typeRet.isEqualTo(E^type)) then
		error(TYPE_NOT_COMPATIBLE);  
	end
	write("(34) Milieu de la fin : " + E^reg.debug() + "\n");
	--Génération du code de retour de la fonction et du flush.
	code := E^code
				+ INST^machine.generateFlush(INST^tvar)
	    	+ INST^machine.generateFunctionReturn(INST^funInfoH, E^reg);
	write("Code (34) : " + code + "\n");
	INST^code := code;
end
}


-----------------------------------------------------------------------
--------------------------- LES EXPRESSIONS ---------------------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------

-- (35)
E -> #attA A #attAFFX AFFX #attE;

#attA {
local
do
	write("Regle (35): E\n");
	A^machine := E^machine;
	A^tvar := E^tvar;
	A^tfun := E^tfun;
	A^talias := E^talias;
	A^ni := E^ni;
end
}

-- Passage des attributs hérités de AFFX.
-- Maj d'un attribut pour AFFX signalant si A est, ou non, une variable.
-- Maj de l'attribut typeH de AFFX afin de tester que les types correspondent.
#attAFFX {
local
do
	write("Regle (35) : milieu : " + A^code + "\n");
	AFFX^machine := E^machine;
	AFFX^tvar := E^tvar;
	AFFX^tfun := E^tfun;
	AFFX^talias := E^talias;
	AFFX^ni := E^ni;
	-- L'affectation est possible si A est une variable.
	AFFX^affPossible := A^estVar;
	-- Le type de cette afectation doit être le même que A.
	AFFX^typeH := A^type;
end
}

-- Génération du code de l'affectation.
-- Passage des attributs syn de E.
#attE {
local
	code : String;
	reg : Register;
	estVar : boolean;
	vi : VariableInfo;
do
	write("(35) Debut de la fin\n");
	reg := new Register();
	code := A^code + AFFX^code;
	estVar := false;
	vi := null;
	-- On n'a pas d'affectation à droite.
	if (AFFX^estVar) then
		-- E peut dans ce cas représenter une variable.
		estVar := true ;
		vi := A^vi ;
		reg := A^reg ;
	else 
		if (A^estVar) then
			-- E ne représente pas de variable.
			estVar := false ;
			vi := null ;
			-- On génère le code de l'affectation.
			-- La compatibilité des types est effectuée dans AFFX.
			code := code + E^machine.generateStoreVariable(A^vi,AFFX^reg);
			write("(35) Code else : " + code + "\n");
			reg := AFFX^reg;
		else
			error(LEFT_PART_NOT_VARIABLE);
		end
	end
	write("(35) reg = " + reg.debug() + "\n");
	write("(35) type = " + A^type + "\n");
	E^type := A^type;
	E^reg := reg;
	E^estVar := estVar;
	E^vi := vi;
	E^code := code;
  write("Code 35: " + code + "\n");
end
}


-- (36) : Affectation
AFFX -> affect #attA A #attAFFX ;

#attA {
local
do
	A^machine := AFFX^machine;
	A^tvar := AFFX^tvar;
	A^tfun := AFFX^tfun;
	A^talias := AFFX^talias;
	A^ni := AFFX^ni;
end
}

-- Vérifie que l'affectation est valide :
--   - la partie à gauche du = doit être une variable,
--   - le type de A doit être compatible avec celui de AFFX.
#attAFFX {
local
do
	if !(AFFX^affPossible) then
		error(LEFT_PART_NOT_VARIABLE );
	else
		-- Verification d'égalité des types.
		if !(A^type.isEqualTo(AFFX^typeH)) then
		error(TYPE_NOT_COMPATIBLE);    
		end
	end
	-- On met l'attribut estVar de AFFX à faux car la règle 
	-- appelante ne pourra pas être une variable suite à cette RP.
	-- Le registre et le type de AFFX sont ceux de A.
	AFFX^estVar := false;
	AFFX^reg := A^reg;
	AFFX^type := A^type;
	AFFX^code := A^code;
end
}


-- (37)
AFFX -> #attAFFX ;

-- On met estVar à true car cette RP n'empeche pas la representation d'une var.
-- code est vide, reg est null, type aussi.
#attAFFX {
local
do
	write("Regle (37)\n");
	AFFX^estVar := true ;
	AFFX^reg := null;
	AFFX^type := null;
	AFFX^code := "";
end
}


-- (38) : Relation
A -> #attR R #attAX AX #attA ;

#attR {
local
do
	write("Regle (38)\n");
	R^machine := A^machine;
	R^tvar := A^tvar;
	R^tfun := A^tfun;
	R^talias := A^talias;
	R^ni := A^ni;
end
}

#attAX {
local
do
	write("Regle (38) : milieu\n");
	AX^machine := A^machine;
	AX^tvar := A^tvar;
	AX^tfun := A^tfun;
	AX^talias := A^talias;
	AX^ni := A^ni;
end
}

-- Attributs syn pour A.
#attA {
local
	reg : Register;
	code : String;
	vi : VariableInfo;
	estVar : boolean;
	t : Type;
	type : Type;
do
	type := null;
	reg := new Register();
	code := R^code + AX^code;
	t := R^type;
	write("(38) R^type = " + t + "\n");
	-- Si AX n'est pas une variable, on doit générer le code de l'opération.
	if !(AX^estVar) then
		-- Le type de A doit être comparable, ie il doit s'agir d'un type simple.
		match t
		with SimpleType then 
			-- Si le type est comparable :
			-- On vérifie que les types de R et AX sont bien compatibles.
			if !(t.isCompatible(AX^type)) then 
				error(TYPE_NOT_EQUAL);
			else
				-- On génnère le code de l'opération.
				code := code + A^machine.generateOperation(AX^oprel,R^reg,AX^reg,reg);
				-- Une comparaison renvoie un entier (/un booléen)
				type := new IntegerType();
			end
		else
			-- Le type n'est pas simple : impossible de faire une comparaison.
			error(TYPE_NOT_COMPARABLE);
		end
	else
		reg := R^reg;
		type := R^type;
	end
	-- A représente une variable si AX ne l'empêche pas 
	-- et R représente une variable, on fait alors passer
	-- la vi de R à A. Sinon, vi est à null pour R.
	if (R^estVar)&&(AX^estVar) then 
		estVar := true;
		vi := R^vi;
	else
		estVar := false;
		vi := null;
	end
	-- Le registre de A contient le résultat de l'opération.
	A^reg := reg;
	-- Passage des autres attributs.
	A^type := type;
	A^code := code;
	write("(38) Reg : " + reg.debug() + "\n");
	write("(38) Code : " + code + "\n");
	A^vi := vi;
	A^estVar := estVar;
end
}


-- (39)
AX -> OPREL #attR R #attAX ;

-- Rien à faire passer à OPREL.
#attR {
local
do
	R^machine := AX^machine;
	R^tvar := AX^tvar;
	R^tfun := AX^tfun;
	R^talias := AX^talias;
	R^ni := AX^ni;
end
}

-- Paramètres syn de AX.
#attAX {
local
do
	-- La RP appelante ne represente pas une variable.
	AX^estVar := false;
	-- Les autres attributs font passer ceux de R.
	AX^oprel := OPREL^oprel;
	AX^reg := R^reg;
	AX^type := R^type;
	AX^code := R^code;
end
}


-- (40)
AX -> #attAX ;

-- Paramètres syn de AX.
#attAX {
local
do
	write("Regle (40)\n");
	-- L'oprel de AX est null dans ce cas.
	-- Il faut tout de même l'initialiser comme il s'agit d'un attribut synthétisé.
	AX^oprel := null;
	-- La RP n'empeche pas d'etre une variable.
	AX^estVar := true;
	-- Il faut init code.
	AX^code := "";
	-- Registre à null, de même que type.
	AX^reg := null;
	AX^type := null;
end
}


-- (41) Operateurs relationnels
OPREL -> inf #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 13;
end
}


-- (42)
OPREL -> sup #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 15; 
end
}


-- (43)
OPREL -> infeg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 14;
end
}


-- (44)
OPREL -> supeg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 16;
end
}


-- (45)
OPREL -> eg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 11;
end
}


-- (46)
OPREL -> neg #attOPREL ;

#attOPREL {
local
do
	OPREL^oprel := 12;
end
}


-- (47)
R -> #attT T #attRX RX #attR ;

-- Attributs inh de T.
#attT {
local
do
	write("Regle (47)\n");
	T^machine := R^machine;
	T^talias := R^talias;
	T^tfun := R^tfun;
	T^tvar := R^tvar;
	T^ni := R^ni;
end
}


-- Attributs inh de RX.
#attRX {
local
do
	write("Regle (47) : milieu\n");
	RX^machine := R^machine;
	RX^talias := R^talias;
	RX^tfun := R^tfun;
	RX^tvar := R^tvar;
	RX^ni := R^ni;
end
}

-- Attributs syn de R.
#attR {
local
	code : String;
	reg : Register;
	vi : VariableInfo;
	estVar : boolean;
	type : Type;
do
	-- Init du registre dans lequel sera stocké le résultat de l'opération.
	reg := new Register();
	code := T^code + RX^code;
	type := T^type;

	write("(47) T^type = " + type + "\n");

	if (RX^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
			if !(type.isCompatible(RX^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := code + R^machine.generateOperation(RX^op,T^reg,RX^reg,reg);
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	else
		reg := T^reg;
	end
	-- R est variable si T l'est et RX ne l'empeche pas,
	-- dans ce cas, on lui donne la vi de R. Dans le cas
	-- contraire, l'attribut vi de R est à null.
	if ((T^estVar)&&(RX^estVar)) then
		estVar := true;
		vi := T^vi;
	else
		estVar := false;
		vi := null;
	end
	-- Passage des attributs.
	R^reg := reg;
	R^code := code;
	R^estVar := estVar;
	R^vi := vi;
	R^type := type;
	write("(47) reg : " + reg.debug() + "\n");
	write("(47) code : " + code + "\n");
end
}


-- (48) : Additions ...
RX -> OPADD #attT T #attRX1 RX #attRX ;

-- Attributs inh de T.
#attT {
local
do
	T^machine := RX^machine;
	T^talias := RX^talias;
	T^tfun := RX^tfun;
	T^tvar := RX^tvar;
	T^ni := RX^ni;
end
}


-- Pas d'attribut inh pour OPADD.
-- Attributs inh de RX1.
#attRX1 {
local
do
	RX1^machine := RX^machine;
	RX1^talias := RX^talias;
	RX1^tfun := RX^tfun;
	RX1^tvar := RX^tvar;
	RX1^ni := RX^ni;
end
}

-- Attributs syn pour RX.
-- Génération du code de T RX en fonction de RX.
#attRX {
local
	code : String;
	reg : Register;
	type : Type;
do
	reg := new Register();
	type := T^type;
	-- On met le code de T et RX1.
	code := T^code + RX1^code;
	if (RX1^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
			if !(type.isCompatible(RX1^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := code + RX^machine.generateOperation(RX1^op,T^reg,RX1^reg,reg);
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	end
	-- Passage de l'operateur de OPADD à RX.
	RX^op := OPADD^op;
	RX^reg := reg;
	RX^code := code;
	RX^type := type;
	-- Si cette RP apparait dans l'expression, alors il ne s'agit pas d'une variable.
	RX^estVar := false;
end
}


-- (49)
RX -> #attRX;

#attRX {
local
do
	RX^op := 0;
	-- N'empeche pas la représentation d'une variable.
	RX^estVar := true;
	RX^code := "";
	RX^type := null;
	RX^reg := null;
end
}


-- (50) : Operateurs additifs
OPADD -> plus #attOPADD ;

#attOPADD {
local
do
	OPADD^op := 1;
end
}


-- (51)
OPADD -> moins #attOPADD ;

#attOPADD {
local
do
	OPADD^op := 2;
end
}


-- (52)
OPADD -> ou #attOPADD ;

#attOPADD {
local
do
	OPADD^op :=  6;
end
}


-- (53) : Multiplication, ...
T -> #attF F #attTX TX #attT ;

-- Attributs inh de F.
#attF {
local
do
	write("Regle (53)\n");
	F^machine := T^machine;
	F^talias := T^talias;
	F^tfun := T^tfun;
	F^tvar := T^tvar;
	F^ni := T^ni;
end
}

-- Attributs inh de TX.
#attTX {
local
do
	write("Regle (53) : milieu\n");
	TX^machine := T^machine;
	TX^talias := T^talias;
	TX^tfun := T^tfun;
	TX^tvar := T^tvar;
	TX^ni := T^ni;
end
}

-- Attributs syn de T. 
#attT {
local
	code : String;
	reg : Register;
	vi : VariableInfo;
	estVar : boolean;
	t : Type;
do
	reg := new Register();
	code := F^code + TX^code;
	t := F^type;
	if (TX^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match t
		with SimpleType then
			if !(t.isCompatible(TX^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := code + T^machine.generateOperation(TX^op,F^reg,TX^reg,reg);
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	else
		reg := F^reg;
	end
	-- T est une variable si F l'est et TX ne l'empeche pas.
	-- Dans ce cas, vi de T est celui de F.
	-- Sinon, vi est à null.
	if ((F^estVar)&&(TX^estVar)) then
		estVar := true;
		vi := F^vi;
	else
		estVar := false;
		vi := null;
	end
	-- Passage des attributs.
	write("(53) reg : " + reg.debug() + "\n");
	T^reg := reg;
	T^code := code;
	T^vi := vi;
	T^estVar := estVar;
	T^type := t;
	write("(53) code : " + code + "\n");
end
}


-- (54)
TX -> OPMUL #attF F #attTX1 TX #attTX;

-- Pas d'attribut inh pour OPMUL.
-- Attributs inh de F.
#attF {
local
do
	F^machine := TX^machine;
	F^talias := TX^talias;
	F^tfun := TX^tfun;
	F^tvar := TX^tvar;
	F^ni := TX^ni;
end
}

-- Attributs inh de TX1.
#attTX1 {
local
do
	TX1^machine := TX^machine;
	TX1^talias := TX^talias;
	TX1^tfun := TX^tfun;
	TX1^tvar := TX^tvar;
	TX1^ni := TX^ni;
end
}

-- Attributs syn de TX.
#attTX {
local
	code : String;
	reg : Register;
	type : Type;
do
	reg := new Register();
	code := F^code + TX1^code;
	type := F^type;
	if (TX1^op != 0) then
		-- Si il y a un opération : verif sur les types.
		match type
		with SimpleType then
			if !(type.isCompatible(TX1^type)) then
				error(TYPE_NOT_COMPATIBLE);
			else
				code := code + TX^machine.generateOperation(TX1^op,F^reg,TX1^reg,reg);
			end
		else
			error(TYPE_NOT_SIMPLE);
		end
	end
	TX^op := OPMUL^op;
	TX^code := code;
	TX^reg := reg;
	--Cette RP empeche l'expression d'etre une variable.
	TX^estVar := false;
	TX^type := type;
end
}


-- (55)
TX -> #attTX ;

-- Attributs syn de TX.
#attTX {
local
do
	TX^op := 0;
	TX^code := "";
	TX^reg := null;
	-- N'empeche pas l'espression de rpz une var.
	TX^estVar := true;
	TX^type := null;
end
}


-- (56) : Operateurs multiplicatifs
OPMUL -> mult #attOPMUL ;

#attOPMUL {
local
do
	OPMUL^op := 3;
end
}


-- (57)
OPMUL -> div #attOPMUL;

#attOPMUL {
local
do
	OPMUL^op := 4;
end
}


-- (58)
OPMUL -> mod #attOPMUL ;

#attOPMUL {
local
do
	OPMUL^op := 7;
end
}


-- (59)
OPMUL -> et #attOPMUL ;

#attOPMUL {
local
do
	OPMUL^op := 17;
end
}


---------------------------------------
--------- Expressions de base ---------
---------------------------------------

-- (60) : Constante entiere
F -> entier #attF ;

-- Attributs syn de F.
-- Génération du code pour load la valeur de l'entier dans la mémoire.
#attF {
local
	t : IntegerType;
	r : Register;
  c : ConstantInfo;
do
  write("(60) Debut\n");
	-- Creation du type et du registre.
	t := new IntegerType();
	r := new Register();
	-- Récup de l'entier et conversion au bon format.
	-- Génération du code, et set de l'attribut le contenant.
	c := new ConstantInfo(t, entier^txt);
	write("(60) : ConstantInfo : " + c + "\n");
	F^code := F^machine.generateLoadConstant(c, r); 
	write("(60) reg : " + r.debug() + "\n");
	-- Une expression de base ne peut representer une variable.
	-- Donc pas de vi.
	F^vi := null;
	F^estVar := false;
	-- Set de l'attribut type.
	F^type := t;
	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
	F^reg := r;
end
}


-- (61) : Constante chaine
F -> chaine #attF ;

-- Attributs syn de F.
-- Génération de code pour load la chaine.
#attF {
local
	l : int;
	t : StringType;
	r : Register;
	s : String;
do
	-- Récup de la chaine.
	s := chaine^txt;
	l := s.length();
	-- Suppression des " au début et à la fin de celle-ci.
	s := s.substring(1,l-1);
	l := l-2;
	-- Initialisation du type, en précisant la taille.
	t := new StringType(l);
	-- Création du registre.
	r := new Register();
	-- Génération du code et set des attributs de F.
	F^code := F^machine.generateLoadConstant(new ConstantInfo(t, s), r);
	-- Une expression de base ne peut representer une variable.
	-- Donc pas de vi.
	F^vi := null;
	F^estVar := false;
	F^type := t;
	F^reg := r;
end
}


-- (62) : Constante caractere
F -> caractere #attF ;

-- Attributs syn de F.
-- Génération de code pour load le caractere.
#attF {
local
	c : char;
	r : Register;
	t : Type;
	reg : Register;
do
	-- Récup du caractère.
	c := caractere^txt.charAt(1);
	-- Init du type et du reg.
	t := new CharacterType();
	reg := new Register();
	-- Gen du code et set des attributs de F.
	F^code := F^machine.generateLoadConstant(new ConstantInfo(t, c), reg);
	-- Une expression de base ne peut representer une variable.
	-- Donc pas de vi.
	F^vi := null;
	F^estVar := false;
	F^type := t;
	F^reg := reg;
end
}


-- (63) : Expression unaire
F ->  OPUN #attF1 F #attF ;

-- Pas d'att inh pour OPUN.
-- Attributs inh de F1.
#attF1 {
local
do
	F1^machine := F^machine;
	F1^talias := F^talias;
	F1^tfun := F^tfun;
	F1^tvar := F^tvar;
	F1^ni := F^ni;
end
}

-- Attributs syn de F.
-- Génération du code pour la déclaration de la variable.
#attF {
local
	reg : Register;
	code : String;
	t : Type;
do
	reg := new Register();
	t := F1^type;
	code := "";
	match t
	with SimpleType then
		code := F1^code + F^machine.generateOperation(OPUN^op,F1^reg,reg);
	else 
		error(TYPE_NOT_SIMPLE);
	end
	F^code := code;
	-- Une variable ne peut contenir d'opérateur unaire.
	-- Donc pas de vi.
	F^estVar := false;
	F^vi := null;
	F^type := t; 
	F^reg := reg;
end
}


-- (64) : Operateurs unaires
OPUN -> plus #attOPUN ;

#attOPUN {
local
do
	OPUN^op := 10;
end
}


-- (65)
OPUN -> moins #attOPUN ;

#attOPUN {
local
do
	OPUN^op := 8;
end
}


-- (66)
OPUN -> non #attOPUN ;

#attOPUN {
local
do
	OPUN^op := 9;
end
}


-- (67) : Pointeur NULL
F -> null #attF ;

-- Le pointeur null ne représente pas une variable.
-- Donc pas de vi.
#attF {
local
do
	F^estVar := false;
	F^vi := null;
	F^code := "";
	F^type := null;
	F^reg := null; -- TODO
end
}

-- (68) : Expression parenthesee
F ->  paro #attE E parf #attFX FX #attF;

-- Attributs inh de E.
#attE {
local
do
	E^machine := F^machine;
	E^tvar := F^tvar;
	E^tfun := F^tfun;
	E^talias := F^talias;
	E^ni := F^ni;
end
}

-- Attributs inh de FX.
#attFX {
local
	dl : DisplacementList;
do
	dl := new DisplacementList();
	FX^machine := F^machine;
	FX^tvar := F^tvar;
	FX^tfun := F^tfun;
	FX^talias := F^talias;
	-- La partie avant FX n'est pas un appel de fonction.
	FX^estFun := false;
	--FX^funInfoH := null;
	-- La liste des déplacements de FX est initialisée ici.
	FX^listeDepl := dl;
	-- On met le nom à "", pas d'appel de fonction de cette manière. 
	FX^nom := "";
	-- On fait passer le type de E à FX pour d'éventuelles verifs.
	FX^typeH := E^type;
	FX^ni := F^ni;
end
}

-- Attributs syn de F.
-- On ne récupère pas le code de FX car il est vide sauf en cas d'appel de fonction, impossible ici.
#attF {
local
  estVar : boolean;
	vi : VariableInfo;
	dl : DisplacementList;
  code : String;
  reg : Register;
do
  dl := FX^listeDeplS;
  reg := new Register();
  code := E^code;
	if ((dl.size()) != 0) then -- : > 0) then
    -- On a accédé à des champs dans FX.
    -- On génère le code correspondant, en prenant le registre de E comme base.
    -- Les verification d'existence de champs ont été faites dans FX.
    code := code + F^machine.generateMakeAddress(dl, E^reg, reg);
  end
  -- F est une variable si E l'est et FX ne l'empeche pas.
  -- Dans ce cas, vi de F prend celui de E. Dans le cas
  -- contraire, il est null.
  if ((E^estVar)&&(FX^estVar)) then
	  estVar := true;
		vi := E^vi;
	else
	  estVar := false;
		vi := null;
	end
  F^code := code;
	F^vi := vi;
	F^estVar := estVar;
	F^type := FX^type;
	F^reg := reg;
end
}


-- (69) : Cast
F ->  paro #attTYPE TYPE parf #attF1 F #attF;

-- Passage de la table des alias.
#attTYPE {
local
do
  TYPE^talias := F^talias;
end
}

-- Attributs inh de F1.
#attF1 {
local
do
  F1^machine := F^machine;
	F1^talias := F^talias;
	F1^tfun := F^tfun;
	F1^tvar := F^tvar;
	F1^ni := F^ni;
end
}

-- Attributs syn de F.
#attF {
local
  t : Type;
	vi : VariableInfo;
do
  t := TYPE^type;
	vi := null;
  if (F1^type.isCompatible(t)) then
		 vi := new VariableInfo(TYPE^type, F1^vi.displacement(), F^ni);
  else
     error(TYPE_NOT_COMPATIBLE);	   
  end
  F^code := F1^code;
  -- (int)a ne représente pas une variable : 
  -- le cast empeche une expression d'etre une variable.
  -- Donc pas de vi.
  F^estVar := false;
	F^vi := vi;
	F^type := t;
	F^reg := F1^reg;
end
}


-- (70) : Dereferencement.
F -> mult #attF1 F #attF;

-- Attributs inh de F1.
#attF1 {
local
do
  F1^machine := F^machine;
	F1^talias := F^talias;
	F1^tfun := F^tfun;
	F1^tvar := F^tvar;
	F1^ni := F^ni;
end
}

-- Attributs syn de F.
-- F représente une variable si F1 en représente une, et que celle-ci est un pointeur.
#attF {
local
  t : Type;
	type : Type;
  reg : Register;
do
	t := F1^type;
	type := null; 
  reg := new Register();
	-- On vérifie que ce qu'on deref' est un pointeur. 
  match t 
	with PointerType then
    type := t.getType();
	else
	  error(SHOULD_BE_A_POINTER);
	end
  -- A la suite du code généré par F1, on load le champ pointé.
	-- TODO : gérer ça suivant qu'on veuille l'addrese pour changer la valeur pointée
	--        ou la valeur pointée directement.
	F^code := F1^code + F^machine.generateLoadFromHeap(F1^reg, 0, reg);
	F^vi := null; --TODO
	F^estVar := true;
	F^type := type;
	F^reg := reg;
end
}


-- (71)
F -> ident #attFX FX #attF ;

global
  varInfo : VariableInfo;
	estFun : boolean;

-- Attributs inh de FX.
-- On cherche ident dans les TDS.
-- Instenciation des attributs nécessaires.
#attFX {
local
  listeDepl : DisplacementList ;
	type : Type;
  info : SymbolInfo; 
do
 
  write("Regle (71) : " + ident^txt + ", " + F^ni.name() + "\n");
  --Initialisations.
  listeDepl := new DisplacementList();
	estFun := false;
	type := null;
	varInfo := null;
	info := null;
	write("(71) VARTABLE :\n" + F^tvar);

	-- Recherche dans la TVar (globalement).
  if (!(F^tvar.exists(ident^txt, F^ni, false))) then
		write("(71) " + ident^txt + " not in tvar\n");
	  -- ident n'est pas dans la TVar, F n'est pas une variable.
		-- On regarde dans la TFun s'il s'agit de l'identifiant d'une fonction.
    if (!(F^tfun.exists(ident^txt, F^ni))) then
		  -- On n'a pas trouvé le symbole dans les TDS : erreur.
			error(IDENT_UNDEFINED, ident^txt);
    else
		  -- L'id est celui d'une fonction.
			-- On passe estFun à vrai.
			write("(71) C'est une fonction\n");
			listeDepl.add(0, false);
			estFun := true;
			type := null;
    end
  else
		-- On peut passer le type.
		write("(71) " + ident^txt + " is a var\n");
		info := F^tvar.lookup(ident^txt, F^ni, false);
		match info
		with VariableInfo then
		  varInfo := info;
	    type := varInfo.type();
		  -- On rajoute toujours le déplacement de a à la liste.
		  -- Le test pour savoir si a est bien un struct se fait dans les RP ,de FX.
		  listeDepl.add(varInfo.displacement(), false);
		else
		  error(SHOULD_NOT_HAPPEN_SI_NOT_VI);
		end
  end
	-- On passe les attributs qui serviront à FX.
	FX^listeDepl := listeDepl;
	FX^estFun := estFun;
	--FX^funInfoH := funInfo;
	FX^typeH := type;
	FX^nom := ident^txt;
	FX^tvar := F^tvar;
	FX^tfun := F^tfun;
	FX^talias := F^talias;
	FX^machine := F^machine;
	FX^ni := F^ni;
	write("Regle 71 : au milieu à peu près\n");
end
}

-- Attributs syn de F.
#attF {
local
  listeDepl : DisplacementList; 
  reg : Register;
	code : String;
do
	write("Après Règle 71\n");
  -- Génération du code.
  -- Traitements différents selon qu'on ait : - éffectué un appel de fonction.
  --																					- accédé simplement à une variable.
  --               														- accédé à un champ de struct.
  listeDepl := FX^listeDeplS;
  reg := new Register();
	code := "";
	if estFun then
		write("(71) C'est une fonction\n");
    -- On a un appel de fonction, peut être suivi d'accés à des champs de struct.
	  -- regRetourFun est le registre contenant le résultat de l'appel de fonction,
		-- il se trouve dans le FunctionInfo \o/.
		write("(71) DL :\n" + listeDepl + "\n     reg : " + FX^reg.debug() + "\n"); 
    code := F^machine.generateMakeAddress(listeDepl, FX^reg, reg);
	else 
	  -- On n'a pas d'appel de fonction. 
		if ((listeDepl.size() != 0 )&&(listeDepl.size() != 1)) then --> 1) then
	    -- Des déplacements ont été ajoutés à la liste en plus de celui de ident : on a accédé à des champs de struct !
		  -- Le registre contient l'adresse de la variable accédée par FX dans le struct.
      code := F^machine.generateMakeAddress(listeDepl, reg);
		else
      -- Accés direct à une variable.
   		-- La VariableInfo est déjà dans varInfo.
      code := F^machine.generateLoadValue(varInfo, reg);
		end
  end
	F^vi := varInfo;
	F^code := FX^code + code;
  F^estVar := true;
  F^type := FX^type;
	F^reg := reg;
	write("(71) reg : " + reg.debug() + "\n");
	write("(71) code: " + code + "\n");
end
}


-- (72)
FX -> #attFX ;

-- Attributs syn de FX. 
#attFX {
local
do
  -- Vérifie qu'on n'attendait pas une liste d'argument pour un appel de fonction.
  if (FX^estFun) then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  FX^code := "";
  FX^type := FX^typeH;
  FX^listeDeplS := FX^listeDepl;
	FX^estVar := true;
	FX^reg := null;
	write("Regle (72) (FX -> /\\)\n");
end
}


-- (73) : Acces champ
FX -> pt ident #attFX1 FX #attFX;

-- Attributs inh de FX1. 
#attFX1 {
local
  typeStruct : StructType; 
	type : Type;
	type2 : Type;
	listeDepl : DisplacementList;
	fields : List<String>;
do
  -- On vérifie qu'on était pas dans un appel de fonction.
	if FX^estFun then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  listeDepl := FX^listeDepl;
	type := FX^typeH;
  -- On vérifie que ce qui est à gauche de cet appel est bien un struct.
	type2 := FX^typeH;
  match type2
	with StructType then  
		-- On vérifie que le champ existe et on y accède.
    typeStruct := type2;
		fields := typeStruct.fields();
		if (fields.indexOf(ident^txt) = (-1)) then
		  -- Si le instanceOf renvoie -1, c'est que l'identifiant n'apparait pas dans les champs : erreur.
		  error(CHAMP_INEXISTANT, ident^txt);
		else
      -- Si le champ existe, on ajoute le déplacement correspondant à la liste.
			listeDepl.add(typeStruct.fieldDisplacement(ident^txt),false);
			-- On récupère le type.
   		type := typeStruct.find(ident^txt);
	  end
	else
		-- Sinon : erreur !
	  error(NOT_STRUCT);
  end
	FX1^listeDepl := listeDepl;
	FX1^estFun := false;
	--FX1^funInfoH := null;
	FX1^typeH := type;
  FX1^nom := ident^txt;	
	FX1^tvar := FX^tvar;
	FX1^tfun := FX^tfun;
	FX1^talias := FX^talias;
	FX1^machine := FX^machine;
	FX1^ni := FX^ni;
end
}

-- Attributs syn de FX.
-- On fait remonter le code, le type et la liste de deplacement.
#attFX{
local
do
  FX^code := FX1^code;
  FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
	FX^estVar := FX1^estVar;
	FX^reg := null;
end
}


-- (74) : Acces champ pointeur
FX -> arrow ident #attFX1 FX #attFX;

-- Attributs inh de FX1.
-- Comme dans la RP precedent, on doit vérifier que la règle est applicable.
-- Le type passé à FX doit etre celui d'un pointeur et le type pointé un struct.
-- La champ doit exister dans le type pointé.
#attFX1 {
local
  type : Type;
	typeP : Type;
	typeS : Type;
	listeDepl : DisplacementList;
	fields : List<String>;
do
  -- On vérifie qu'on était pas dans un appel de fonction.
	if FX^estFun then
	  error(FUNCTION_CALL_WITHOUT_PARS);
	end
  type := FX^typeH;
	listeDepl := FX^listeDepl;
	typeP := type;
	match typeP
	with PointerType then
	-- Si type est un pointeur on va vérifier qu'il s'agit d'un pointeur sur struct.
		type := typeP.getType();
		-- Si le type pointé est struct, on va vérifier que le champ existe.
		typeS := type;
    match typeS
		with StructType then
			fields := typeS.fields();
      if (fields.indexOf(ident^txt) = -1) then
		    -- Si le instanceOf renvoie -1, c'est que l'identifiant n'apparait pas dans les champs : erreur.
		    error(CHAMP_INEXISTANT, ident^txt);
		  else
        -- Si le champ existe, on ajoute le déplacement correspondant à la liste.
		  	listeDepl.add(typeS.fieldDisplacement(ident^txt),true);
		  	-- On récupère le type.
   	  	type := typeS.find(ident^txt);
	    end
		-- Sinon : erreur !
		else
      error(NOT_STRUCT);
		end
	else
	-- Sinon : erreur !
	  error(NOT_A_POINTEUR);
  end
	FX1^estFun := false;
	--FX1^funInfoH := null;
	FX1^typeH := type;
	FX1^listeDepl := listeDepl;
  FX1^nom := ident^txt;
	FX1^tvar := FX^tvar;
	FX1^tfun := FX^tfun;
	FX1^talias := FX^talias;
	FX1^machine := FX^machine;
	FX1^ni := FX^ni;
end
}

-- Attributs syn de FX.
-- On fait remonter le code, le type et la liste de deplacement.
#attFX {
local
do
  FX^code := FX1^code;
  FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
	FX^estVar := FX1^estVar;
	FX^reg := null;
end
}


-- (75) : Appel de sous-programme
-- La verification des paramètres ainsi que la generation des pushs
-- se font dans ES.
FX -> #attES paro ES parf #attFX1 FX #attFX;

global
	code : String;  

-- Attributs inh de ES.
-- Verification que l'appelant est une fonction.
#attES {
local
do
	code := "";

	write("Regle (75)\n");
  if !(FX^estFun) then
	  error(NOT_A_FUN);
	end
  ES^typesParams := new ArrayList<Type>();
  ES^codeH := "";
	ES^tvar := FX^tvar;
	ES^tfun := FX^tfun;
	ES^talias := FX^talias;
	ES^machine := FX^machine;
	ES^ni := FX^ni;
end
}

-- Attributs inh de FX1.
-- Verification qu'il existe bien une fonction avec cette signature.
#attFX1 {
local
	type : Type;
	si : SymbolInfo;
	reg : Register;
do
	reg := null;
	type := null;

  if (FX^nom = "") then
	  error(NO_PAR_CALL);
	else
	  -- On cherche avec la fonction qui ne prend pas de booléen, mais une liste de types pour les params.
    si := FX^tfun.lookup(FX^nom, FX^ni, ES^typesParamsS);
		write("(75) " + si + "\n");
	  if (si = null) then
	    error(NO_FUN_WITH_SUCH_PARS, FX^nom);
	  end
		match si
		with FunctionInfo then
	  	code := ES^code + FX^machine.generateFunctionCall(si);
			type := si.returnType();
			reg := si.register();
  	else 
	  	error(SHOULD_NOT_HAPPEN_SI_NOT_FI);
		end
	end

  -- La liste des deplacements n'a pas été modifié par le parcours des arguments.
  FX1^listeDepl := FX^listeDepl;
	-- L'appel de fonction n'est pas une fonction.
	FX1^estFun := false; 
	--FX1^funInfoH := null;
	-- Le type de l'appel est le type de retour de la fonction.
	FX1^typeH := type;
	-- Pas de nom pour FX ici.
	FX1^nom := "";
	FX1^tvar := FX^tvar;
	FX1^tfun := FX^tfun;
	FX1^talias := FX^talias;
	FX1^machine := FX^machine;
	FX^reg := reg;
	write("(75) Code: " + code + "\n");
end
}

-- Attributs syn de FX.
-- On push les arguments, le code est dans ES^code.
-- Puis on appel la fonction. Et on met le code de FX1.
#attFX {
local
do
  code := code + FX1^code;	
	FX^code := code;
	FX^type := FX1^type;
	FX^listeDeplS := FX1^listeDeplS;
	FX^estVar := false;
end
}


-- (76) : Arguments appel de sous-programme
ES -> #attES ;

-- Attributs syn de ES
#attES {
local
do
  -- Passage de la liste des types des params de l'appel.
  ES^typesParamsS := ES^typesParams;
  -- On n'a rien à ajouter comme code à cette RP.
  -- On fait remonter le code des paramètres précédents.
  ES^code := ES^codeH;
end
}


-- (77)
ES -> #attE E #attESX ESX #attES ;

-- Attributs inh de E
#attE {
local
do
  E^machine := ES^machine;
	E^tvar := ES^tvar;
	E^tfun := ES^tfun;
	E^talias := ES^talias;
	E^ni := ES^ni;
end
}

-- Attributs inh de ESX et ajout du type du paramètre.
#attESX {
local
  l : List<Type>;
  code : String;
do
  -- Ajout du type de E à la liste des types des params.
  l := ES^typesParams;
	l.add(E^type);
  -- Ajout du code du push pour ce param.
  code := E^code + ES^machine.generateFunctionPushArgument(E^reg);
  ESX^typesParams := l;
  ESX^codeH := code;
	ESX^machine := ES^machine;
	ESX^tvar := ES^tvar;
	ESX^tfun := ES^tfun;
	ESX^talias := ES^talias;
	ESX^ni := ES^ni;
end
}

-- Passage du code de ESX à ES.
-- Et remontée de la liste des types.
#attES {
local
do
  ES^code := ESX^code;
	ES^typesParamsS := ESX^typesParamsS;
end
}


-- (78)
ESX -> #attESX ;

-- Attributs syn de ESX.
#attESX {
local
do
  ESX^typesParamsS := ESX^typesParams;
  ESX^code := ESX^codeH;
end
}


-- (79)
ESX -> virg #attE E #attESX1 ESX #attESX ;

-- Attributs inh de E.
#attE {
local
do
  E^machine := ESX^machine;
	E^tvar := ESX^tvar;
	E^tfun := ESX^tfun;
	E^talias := ESX^talias;
	E^ni := ESX^ni;
end
}

-- Attributs inh de ESX1, ajout du type du param.
#attESX1 {
local
  l : List<Type>;
	code : String;
do
  l := ESX^typesParams;
  l.add(E^type);
  code := ESX^codeH + E^code + ESX^machine.generateFunctionPushArgument(E^reg);
  ESX1^typesParams := l;
  ESX1^codeH := code;
	ESX1^machine := ESX^machine;
	ESX1^tvar := ESX^tvar;
	ESX1^tfun := ESX^tfun;
	ESX1^talias := ESX^talias;
	ESX1^ni := ESX^ni;
end
}

-- Attributs syn de ESX.
-- Passage du code de ESX à ES.
-- Et remontée de la liste des types.
#attESX {
local
do
  ESX^code := ESX1^code;
  ESX^typesParamsS := ESX1^typesParamsS;
end
}

-------------------------------------------
--------------- INLINE ASM ----------------
-------------------------------------------
--
---- (80)
--ENTITE -> asm #tds ASM #gen; 
--#tds {
--do 
--  -- A faire : Remplacer 'null' par la table courante pour que
--  -- le code ASM puisse acceder aux variables de MC ou MCS
--  ASM^tds_asm := null; 
--end
--}
--
--#gen {
--do
--  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
--end
--}
--
--
---- (81)
--INST ->  asm   #tds ASM #gen ;
--#tds {
--do
--  -- A remplacer par la table courante pour que
--  -- l'assembleur puisse acceder aux variables
--  ASM^tds_asm := null; 
--end
--}
--
--#gen {
--do
--  -- ASM^code_asm contient le code assembleur inline
--  -- dans lequel les noms de variables ont ete remplaces
--  -- par leurs adresses.
--end
--}

------------------- CS extension --------------------
------ Decommenter les regles suivantes pour l'extension CS
-----------------------------------------------------
--
---- (82)
--TYPE -> bool #typage ;
--
--#typage {
--local
--do
--  TYPE^type := new BooleanType();
--end
--}
--
---- (83) definit un contenu d'un namespace
--ENTITE -> namespace identc #ajout aco ENTITES acf ;
--
---- Ajout de identc à la table des namespaces.
---- Vérifie que identc n'est pas déjà utilisé (par une classe ou un namespace).
--#ajout {
--local
---- TODO: vérifier tout ca quand Namespace & co seront finis
--	tns : NamespaceTable;
--do
--  tns := ENTITE^tns;
--  -- Si identc est une clef dans la TDSKlass, erreur.
--  if ENTITE^tklass.lookup(identc^txt, ENTITE^ni) != null then
--     error(IDENT_TAKEN, identc^txt);
--  else
--  -- Si identc est une clef dans la TDSNamespace, erreur.	
--    if tns.lookup(identc^txt, ENTITE^ni) != null then
--      error(IDENT_TAKEN, identc^txt);
--    else
--     -- Sinon, on peut ajouter le nouveau namespace à la TDS.
--			tns.insert(identc^txt, ENTITE^ni);
--    end
--  end  
--  -- Pas de code pour cette RP.	
--	ENTITE^code := "";
--	ENTITES^machine := ENTITE^machine;
--	ENTITES^tvar : =ENTITE^tvar;
--	ENTITES^tfun := ENTITE^tfun;
--	ENTITES^talias := ENTITE^talias;
--  ENTITES^tns := ENTITE^tns;
--	ENTITES^tklass := ENTITE^tklass;
--	ENTITE^tnsS := tns;
--	--TODO: Faire remonter les tns avec des tnsS au sein du prog µC
--end
--}
--
---- (84) donne l acces au contenu du 'namespace'
--ENTITE -> using identc #passIdentc IDC #trait pv ;
--
--#passIdentc {
--local 
--do
--  -- On commence la recherche du namespace
--  -- TODO: vérif à faire
--	if (ENTITE^tns.exists(identc^txt, ENTITE^ni)) then 
--		-- S'il est possible de continuer (i.e. identc namespace) on le fait dans IDC
--	  IDC^rechKlass := false;
--	  IDC^machine := ENTITE^machine;
--    IDC^tns := ENTITE^tns;
--  	IDC^tklass := ENTITE^tklass;
--		IDC^nomIDC := identc^txt;
--		IDC^ni := ENTITE^ni;
--	else
--		error(IDENT_UNDEFINED, identc^txt);
--	end
--end
--}
--
--#trait {
--local 
--do
--  -- TODO: attendre l'arrivé une liste de ni
--	ENTITE^ni := ENTITE^ni.add(IDC^niS);
--end
--}
--
-- (85)
--IDC -> #verifRetour ;
--
--#verifRetour {
--local 
--do
--  -- On verifie si on cherche à obtenir une classe ou un namespace
--	if IDC^rechKlass then
--	  -- On cherche si on a bien obtenu une classe
--	  if IDC^tklass.exists(IDC^nomIDC, IDC^ni) then
--	    -- Si c'est le cas, on la renvoie
--		  IDC^klassHerit := IDC^tklass.lookup(IDC^nomIDC, IDC^ni);
--		else
--		  -- Sinon, on renvoie une erreur
--		  error(IDENT_UNDEFINED, IDC^nomIDC);
--	  end
--	else
--	  -- On cherche si on a bien obtenu un namespace
--	  if IDC^tns.exists(IDC^nomIDC, IDC^ni) then
--	    -- Si c'est le cas, on la renvoie
--		  IDC^niS := IDC^tns.lookup(IDC^nomIDC, IDC^ni);
--		else
--		  -- Sinon, on renvoie une erreur
--		  error(IDENT_UNDEFINED, IDC^nomIDC);
--	  end
--	end
--end
--}
--
---- (86)
--IDC -> pt identc #passIdentc IDC #retour ;
--
--#passIdentc {
--local 
--do
--  -- On cherche si on a bien obtenu un namespace précédemment
--	-- Comme on n'a pas de classe interne, on doit avoir ni.ni.ni.X
--	if (IDC^tns.exists(IDC^nomIDC, IDC^ni) then
--	  -- On teste l'exist d'identc
--	  -- TODO: vérif quand ce sera bien
--  	if (IDC^tklass.exists(identc^txt, IDC^ni) or IDC^tns.exists(identc^txt, IDC^ni)) then
--			-- S'il existe, on transmet ce qu'il faut
--	    IDC1^rechKlass := IDC^rechKlass;
--		  IDC1^machine := IDC^machine;
--      IDC1^tns := IDC^tns;
--  	  IDC1^tklass := IDC^tklass;
--		  IDC1^nomIDC := identc^txt;
--			IDC1^ni := IDC^tns.lookup(IDC^nomIDC,IDC^ni);
--	  else
--			-- Sinon, erreur
--		  error(IDENT_UNDEFINED, identc^txt);
--		end
--	else
--		-- Sinon, on a une classe (ou autre)
--		error(IDENT_UNDEFINED, IDC^nomIDC);
--	end
--end
--}
--
--#retour {
--local 
--do
--  -- On propage ce qu'il y a à propager
--	if IDC^rechKlass then
--		IDC^klassHerit := IDC1^klassHerit;
--	else
--		IDC^niS := IDC1^niS;
--	end
--end
--}
--
---- (87) definition d'une classe (peut etre en dehors d'un namespace)
--
--ENTITE -> ACCES class identc #verif HERITAGE #ajout aco DEFS acf ;
--
---- Vérifie que identc n'est pas déjà utilisé (par une classe ou un namespace).
--#verif {
--local
---- TODO: vérifier tout ca quand KlassTable & co seront finis
--do
--  -- Si identc est une clef dans la TDSKlass, erreur.
--  if tklass.lookup(identc^txt, ENTITE^ni) != null then
--     error(IDENT_TAKEN, identc^txt);
--  else
--    if ENTITE^tns.lookup(identc^txt, ENTITE^ni) != null then
--      error(IDENT_TAKEN, identc^txt);
--    else
--		  -- Pas de code pour cette RP.	
--		  ENTITE^code := "";
--			HERITAGE^machine := ENTITE^machine;
-- 		  HERITAGE^tns := ENTITE^tns;
--			HERITAGE^tklass := ENTITE^tklass;
--			HERITAGE^ni := ENTITE^ni;
--    end
--  end  
--end
--}
--
--#ajout {
--local
--	tk : KlassTable;
--	kl : Klass;
--do
--  tk := ENTITE^tklass;
--	kl := new Klass(ACCES^acc,identc^txt,HERITAGE^klassHerit,ENTITE^ni);
--	tk.insert(kl);
--  -- On peut enfin ajouter la nouvelle classe à la TDS, maintenant qu'on a la classe héritée.
--	--TODO: Faire remonter les tklass avec des tklassS au sein du prog µC	
--	ENTITE^tklassS = tk; 
--	DEFS^machine := ENTITE^machine;
--	DEFS^klass := kl;
--	DEFS^ni := ENTITE^ni;
--end
--}
--
--
---- (88) : Acces 
--ACCES -> #acc public;
--
--#acc {
--local
--do
--  ACCES^acc := 1;
--end
--}
--
---- (89)
--ACCES -> #acc private;
--
--#acc {
--local
--do
--  ACCES^acc := 2;
--end
--}
--
---- (90)
--ACCES -> #acc;
--
--#acc {
--local
--do
--  ACCES^acc := 3;
--end
--}
--
---- (91) heritage
--
--HERITAGE -> #heritNull;
--
--#heritNull{
--local 
--do
--  -- Aucun héritage
--	HERITAGE^klassHerit := null;
--end
--}
--
---- (92)
--HERITAGE -> dpts identc #passIdentc IDC #herit;
--
--#passIdentc{
--local 
--do
--  -- On commence la recherche de la classe dont on hérite
--  -- TODO: vérif quand la partie arm est clean
--	if (HERITAGE^tklass.exists(identc^txt, HERITAGE^ni) or HERITAGE^tns.exists(identc^txt, HERITAGE^ni)) then 
--		-- S'il est possible de continuer (i.e. identc ou namespace ou classe) on le fait dans IDC
--	  IDC^rechKlass := true;
--	  IDC^machine := HERITAGE^machine;
--    IDC^tns := HERITAGE^tns;
--  	IDC^tklass := HERITAGE^tklass;
--		IDC^nomIDC := identc^txt;
--		IDC^ni := HERITAGE^ni;
--	else
--		error(IDENT_UNDEFINED, identc^txt);
--	end
--end
--}
--
--#herit{
--local 
--do
--	-- On renvoie la classe dont on hérite
--	HERITAGE^classHerit := IDC^classHerit;
--end
--}
---- membres d'une classe
--
---- (93)
--DEFS -> ;
--
---- (94)
--DEFS ->  ACCES #passdef DEF #passdefs DEFS ;
--
--#passdef {
--local
--do
--	DEF^machine := DEFS^machine;
--	DEF^kl :=DEFS^kl;
--	DEF^ni := DEFS^ni;
--	DEF^accH := ACCES^acc;
--end
--}
--#passdefs {
--local
--do
--	DEFS1^machine := DEFS^machine;
--	DEFS1^kl :=DEFS^kl;
--	DEFS1^ni := DEFS^ni;
--end
--}
--
---- (95)
--DEF  ->  TYPE ident #verifIdent DECL #addenKlass ;
--
--#verifIdent {
--local
--do
--	if (DEF^kl.name() = ident^txt) then
--		error(DEFINITION_SAME_NAME_CLASS,ident^txt);
--	end if;
--end
--}
--
--#addenKlass {
--local
--	fi : FunctionInfo
--do
--	if (DEF^funInfo = null) then
--		if (DEF^kl.attributeExists(ident^txt)) then
--		  error(ALREADY_ATTRIBUTE,ident^txt,DEF^kl.name());			
--		else
--		  DEF^kl.addAttribute(DEF^name,DEF^accH,TYPE^type);		
--		end if;
--	else
--		fi := DECL^funInfo;
--		match fi
--		with MethodInfo then
--			if (DEF^kl.attributeExists(ident^txt,fi)) then
--		  	error(ALREADY_METHOD,ident^txt,DEF^kl.name());			
--			else
--		 		DEF^kl.addMethod(DEF^name,DEF^accH,DEF^funInfo);		
--			end if;
--		else
--			error(NOT_A_METHOD);
--		end
--	end if
--end
--}
--
--
---- (96) constructeur
--
--DEF  ->  identc #verifIdentc #attPARFS paro PARFS parf BASE #attBLOC BLOC #attDEF ;
--
--global
--	tvparams : VariableTable;
--
--#verifIdentc {
--local
--do
--	if (DEF^kl.name() != identc^txt) then
--		error(CONSTR_NOT_NAME_CLASS,ident^txt,DEF^kl.name());
--	end if;
--end
--}
--
---- Init des attributs hérités pour PARFS.
--#attPARFS {
--local
--do
--	tvparams := new VariableTable();
--  -- On crée une TDSvar vide pour la passer à PARFS.
--  PARFS^tvar := tvparams;
--  PARFS^tfun := new FunctionTable();
--	PARFS^talias := new AliasTable();
--	-- Creation de la FunctionInfo avec le type retour.
--  PARFS^funInfoH := new FunctionInfo(identc^txt, DEF^kl.name(), DEF^ni);
--  -- Initialisation du compteur de parametres.
--  PARFS^cParam := 0;
--  PARFS^machine := DEF^machine;
--	PARFS^ni := DEF^ni;
--end
--}
--
---- Ajout de la FunctionInfo à la tfun de BLOC.
---- Passage de la FunctionInfo à BLOC.
--#attBLOC {
--local
--  tf : FunctionTable;
--  fi : FunctionInfo;
--do
--  tf := PARFS^tfun;
--  fi := PARFS^funInfo;
-- 	BLOC^tfun := tf;
--	BLOC^funInfoH := fi;
--  BLOC^tvar := new VariableTable(tvparams);
--	BLOC^talias := PARFS^talias;
--	BLOC^machine := PARFS^machine;
--	BLOC^ni := PARFS^ni;
--end
--}
--
---- Génération du constructeur
--#attDEF {
--local
--	fi : FunctionInfo
--do
--	fi := DECL^funInfo;
--	match fi
--	with ConstructorInfo then
--		DEF^kl.addConstructor(fi);
--	else
--			error(NOT_A_CONSTR);
--	end
--	--TODO: evaluer la nécessité de ce truc
--	DEF^funInfo := PARFS^funInfo;
--end
--}
--
---- appel eventuel au constructeur de la classe parente.
--
---- (97)
--BASE -> ;
--
---- (98)
--BASE -> dpts base paro ES parf  ;
--
---- (99) Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--
--PARF ->  MODE TYPE ident ;
--
---- (100)
--MODE -> ref ;
--
---- (101)
--MODE -> out ; 
--
---- (102)
--F -> true #typeEtGenCode #estVarEtVi ;
--
---- Set de l'attribut de type de F pour indiquer qu'il s'agit d'un booléen.
---- Génération du code pour load la valeur du booléen dans la mémoire.
--
--#typeEtGenCode {
--local
--  t : BooleanType;
--  r : Register;
--do
--  -- Creation du type et du registre.
--  t := new BooleanType();
--  r := new Register();
--	-- Set de l'attribut type.
--	F^type := t;
--	-- Génération du code, et set de l'attribut le contenant.
--  F^code := F^machine.generateLoadConstant(new ConstantInfo(t, true), r); 
--	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
--	F^reg := r;
--end
--}
--
---- Une expression de base ne peut representer une variable.
---- Donc pas de vi.
--
--#estVarEtVi {
--local
--do
--  F^estVar := false;
--	F^vi := null;
--end
--}
--
---- (103)
--F -> false #typeEtGenCode #estVarEtVi ;
--
---- Set de l'attribut de type de F pour indiquer qu'il s'agit d'un booléen.
---- Génération du code pour load la valeur du booléen dans la mémoire.
--
--#typeEtGenCode {
--local
--  t : BooleanType;
--  r : Register;
--do
--  -- Creation du type et du registre.
--  t := new BooleanType();
--  r := new Register();
--	-- Set de l'attribut type.
--	F^type := t;
--	-- Génération du code, et set de l'attribut le contenant.
--  F^code := F^machine.generateLoadConstant(new ConstantInfo(t, false), r); 
--	-- Set de l'attribut registre de F, c'est le registre contenant l'entier.
--	F^reg := r;
--end
--}
--
---- Une expression de base ne peut representer une variable.
---- Donc pas de vi.
--
--#estVarEtVi {
--local
--do
--  F^estVar := false;
--	F^vi := null;
--end
--}
--
---- (104)
--F -> this FX;
--
---- (105) base = super
--
--F -> base FX;
--
---- (106) compatible avec null
--
--F -> null2;
--
---- (107)
--F -> new identc IDC paro ES parf ;

end
