----------------------------------------------------
-- Grammaires de MC  et MCS                       --
----------------------------------------------------
--options
option auto = true;
option version = 0.0.1;
option k=2;
--attributes 

-- le fichier source
inh source : MCSSourceFile for PROGRAMME;
-- la machine cible pour la generation de code
inh machine : IMachine for 
         ENTITES, ENTITE, DECL, FONCTION, INST, BLOC, INSTS, SIX,
         PARFS, PARF, PARFSX, ES, ESX, 
         E, AFFX, A, AX, R, RX, T, TX, F,FX
--         -- decommenter la ligne suivante pour MCS
--       , BASE, DEFS, DEF
--         -- fin extension MCS
         ;

-- TODO : Verifier que les attributs sont bien def.

inh tvar : VariableTable for  -- A completer --
         ENTITES, ENTITE, F
         ;

syn tvarS : VariableTable for 
         PARFS, DECL, ENTITE
         ; -- Utilisée pour récupérer la TDS màj avec les paramètres de la fonction.

inh tfun : FunctionTable for -- A completer --
         ENTITES, ENTITE
	 ;

syn tfunS : FunctionTable for 
         DECL, ENTITE
         ;

syn type : Type for -- A completer --
         TYPE, STYPE, PTRS, DECL, FONCTION
         ;
 
inh typeH : Type for -- A Modifier --
         PTRS, INSTS, BLOC, INST, DECL, FONCTION, SIX
         ;

inh funInfoH : FunctionInfo for
         PARFS, PARFSX
				 ;

syn funInfo : FunctionInfo for
         PARFS, PARFSX
	       ;

-- Attribut servant à savoir du quantième paramètre il s'agit. 
inh cParam : int for
         PARFS, PARF, PARFSX
				 ;

inh nom : String for -- A completer (pas sur) --
         DECL, FONCTION
         ;

syn code : String for
         
				 ;

syn op : Operator for
				 OPADD, OPMULT, OPUN, RX
				 ;

syn oprel : RelationalOperator for
				 OPREL
				 ;

syn reg : Register for
				 F, T, RX
				 ;


-- ces attributs permettent de recuperer les instructions du code ASM inline       
syn code_asm : STRING for ASM;
-- la TDS courante
inh tds_asm : TDS for ASM;

--terminals
space separateur is  "[\r\n\t ]+";     
space comm is  "\/\/[^\n]*\n";
sugar paro is  "\(";
sugar parf is  "\)";
sugar aco is  "\{";     
sugar acf is  "\}"; 
sugar virg is  ",";
sugar pt is "\.";
sugar pv is  "\;";
sugar affect is  "=";
sugar si is  "if";
sugar sinon is  "else";
sugar void is  "void";
sugar asm is  "asm";
sugar int is  "int";
sugar char is  "char";
sugar struct is "struct";
sugar typedef is "typedef";
-- decommenter pour MCS
--sugar ref is "ref" ;
--sugar out is "out";
--sugar namespace is "namespace";
--sugar using is "using";
--sugar class is "class";
--sugar public is "public" ;
--sugar private is "private";
--sugar dpts is "\:";
--sugar bool is "bool";
--sugar true is "true";
--sugar false is "false";
--sugar this is "this";
--sugar new is "new" ;
--sugar null2 is "null";
--sugar base is "base" ;
-- 
sugar retour is  "return";
sugar arrow is "\-\>";
sugar null is  "NULL";
sugar inf is  "\<";
sugar infeg is  "\<=";
sugar sup is  "\>";
sugar supeg is  "\>=";
sugar eg is  "==";
sugar neg is  "\!=";
sugar plus is  "\+";
sugar moins is  "\-";
sugar ou is  "\|\|";
sugar mult is  "\*";
sugar div is  "\/";
sugar mod is  "\%" ; 
sugar et is  "\&\&";
sugar non is  "\!";
term entier is  "[0-9]+";
term caractere is  "\'[^\']\'";
term chaine is  "\"[^\"]*\"";
term ident is  "[a-z][_0-9A-Za-z]*";
term identc is  "[A-Z][_0-9A-Za-z]*";

-- pour les instructions en assembleur TAM 'inline'
compil ASM;

-- REGLS DE PRODUCTION
PROGRAMME -> #init #initTDS ENTITES #gen;
global
   machine : IMachine;
-- Transmission de la machine cible  (choisie par l'option -m au lancement) 
#init {
local
do
   machine := PROGRAMME^source.getMachine();
   if machine = null then
     error(NO_MACH, PROGRAMME^source.getMachName());
   else
     ENTITES^machine := machine;
   end
end
}

-- Initialisation des TDS sans parent.
#initTDS {
local
do
  ENTITES^tvar := new VariableTable();
  ENTITES^tfun := new FunctionTable();
end
}
-- Ecrit le code dans un fichier
#gen {
local
do
   machine.writeCode(PROGRAMME^source.getFileName(), ENTITES^code);  
end
}


ENTITES -> #code ;

-- Pas de code : initialisation du code.
#code {
local
do
  ENTITES^code := "";
end
}


ENTITES -> ENTITE #transmissionTDS ENTITES #passCode ;

-- Transmission des TDS mise à jour après ENTITE à ENTITES1.
-- (La transmission de ENTITES à ENTITE se fait, normalement, automatiquement).
#transmissionTDS {
local
do
  ENTITES1^tvar := ENTITE^tvarS;
  ENTITES1^tfun := ENTITE^tfunS;
end
}

-- Concaténation et passage du code.
#passCode {
local
do
  ENTITES^code := ENTITE^code + ENTITES1^code;
end
}

---------------------------------------------
-------- DEFINITION D'UN NOM DE TYPE --------
--      (commence avec une majuscule)      --
---------------------------------------------

ENTITE -> typedef TYPE #ajout identc pv ;

-- Ajout de identc à TDSvar.
-- Vérifie que identc n'est pas déjà utilisé (par une variable ou une fonction).
#ajout {
local
  info : SymbolInfo;
  infoVar : VariableInfo;
do
  info := ENTITE^tvar.lookup(identc^txt, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, identc^txt);
  else {
     info := ENTITE^tfun.lookup(identc^txt, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
     if info != null then
        error(IDENT_TAKEN, identc^txt);
     -- Sinon, on peut ajouter le nouveau type à la TDS.
     else {
        -- TODO
        -- Création de la VariableInfo à ajouter à la TDS.
        -- Y aura un TypeType.
        ENTITE^tvar.insert(identc^txt, --type );
    }
  }  
end
}

---------------------------------------------------------
-- DEFINITION D'UNE VARIABLE GLOBALE OU D'UNE FONCTION --
--            (commence par une minuscule)             --
---------------------------------------------------------

ENTITE -> TYPE ident #idLibre DECL #majTDS #passCode; 

-- Vérification que ident n'est pas déjà utilisé dans une TDS.
-- On n'ajoute pas encore la variable / fonction à la table car on ne sait pas encore la nature.
-- On fait par contre passer les infos (ident^txt et type) à DECL pour qu'il puisse effectuer lui même l'ajout.
-- On fait aussi passer les TDS pour qu'il puisse les màj et s'en servir.
#idLibre {
local
  info : SymbolInfo;
do
  info := ENTITE^tvar.lookup(ident^txt, true);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, ident^txt);
  else {
     info := ENTITE^tfun.lookup(ident^txt, true);
     -- De même si identc est déjà utilisé dans la TDSfun.
     if info != null then
        error(IDENT_TAKEN, ident^txt);
     -- Sinon, on fait passer les infos utiles à DECL.
     else {
        DECL^typeH := TYPE^type;
        DECL^nom := ident^txt;
        DECL^tvar := ENTITE^tvar;
        DECL^tfun := ENTITE^tfun;
    }
  }  
end
}

-- On met à jour les TDS de ENTITE à l'aide de celles de DECL.
#majTDS {
local
do
  ENTITE^tvarS := DECL^tvarS ;
  ENTITE^tfunS := DECL^tfunS ;
end
}

--Useless
-- Passage du code généré par DECL à ENTITE.
#passCode {
local
do
  ENTITE^code := DECL^code;
end
}

-- VARIABLE
DECL -> pv #ajoutDansTDS #genCode;

-- Ajout de la variable (puisqu'on sait désormais que c'en est une) à la TDSvar (de DECL) la TDSfun reste inchangée.
-- DECL possède les attributs nécessaires à la création de la VariableInfo.
-- Les tds à jours sont mises dans des attributs spéciaux de manière à ce que la règle de prod précèdete puisse les récupérer.
#ajoutDansTDS {
local
  tv : VariableTable ;
do
  tv := DECL^tvar;
  tv.insert(DECL^nom, DECL^typeH);
  DECL^tvarS := tv;
  DECL^tfunS := DECL^tfun ; -- La TDS fun n'est pas affectée.
end
}

-- Génération du code pour la déclaration de la variable.
#genCode {
local
  vi : VariableInfo;
do
  vi := DECL^tvarS.lookup(DECL^nom);
	DECL^code := DECL^machine.generateStoreVariable(vi);
end
}


-- FONCTION
DECL -> #transmission FONCTION #majTDS #passCode;

-- L'ajout de la fonction dans la TDS nécessitant la connaissance des params, on ne peut pas le faire dans cette RP.
-- On fait passer le type retour ainsi que le nom de la fonction à FONCTION pour l'ajout.
#transmission {
local
do
  FONCTION^nom := DECL^nom;
  FONCTION^typeH := DECL^typeH;
end
}

-- "Mise à jour" des TDS de DECL.
#majTDS {
local
do
 -- La nouvelle TDSfun contient les infos concernant la nouvelle fonction.
  DECL^tfunS := FONCTION^tfunS;
 -- La TDSvar est inchangée.
  DECL^tvarS := DECL^tvar;
end
}

--Passage du code de declaration de la fonction à DECL.
#passCode {
local
do
  DECL^code := FONCTION^code;
end
}



FONCTION -> #creationTDSfille #creationFunctionInfo #initC paro PARFS parf #ajoutEtPassFI #creationTDSPetiteFille BLOC #declFonction ;

-- On crée la TDSvar fille pour la passer à PARFS.
#creationTDSfille {
local
do
  PARFS^tvar := new VariableTable(FONCTION^tvar);
  PARFS^tfun := FONCTION^tfun;
end
}

-- Creation de la FunctionInfo avec le type retour.
#creationFunctionInfo {
local
do
  PARFS^funInfoH := new FunctionInfo(FONCTION^type);
end
}

-- Initialisation du compteur de parametres.
#initC {
local 
do
  PARFS^cParam := 0;
end
}

-- Ajout de la FunctionInfo à tfun.
-- Passage de tfun à FONCTION et BLOC.
-- Passage de la FunctionInfo à BLOC.
#ajoutEtPassFI {
local
  tf : FunctionTable;
do
  tf := PARFS^tfun;
  tf.insert(FONCTION^nom, PARFS^funInfo);
-- Passage de tfun à FONCTION et à BLOC.
  FONCTION^tfunS := tf;
  BLOC^tfun := tf;
-- Passage de funInfo à BLOC.
  BLOC^funInfoH := PARFS^funInfo;
end
}

-- Creation d'une TDS fille de la Tvar de PARFS et passage en tant que tvar de BLOC.
#creationTDSPetiteFille {
local
do
  BLOC^tvar := new VariableTable(PARFS^tvarS);
end
}

-- Generation du code de la declaration de la fonction.
#declFonction {
local
do
  FONCTION^code := FONCTION^machine.generateFunctionDeclaration(PARFS^funInfo , BLOC^code);
end
}

-------------------------------------------
-------- PARAMETRES DE FONCTION -----------
-------------------------------------------
PARFS ->  #passageFunInfo #transTvar ;

#passageFunInfo {
local
do
  PARFS^funInfo := PARFS^funInfoH ;
end
}

-- Passage de tvar, de manière à ce que l'attribut tvarS de PARFS soit initialisé.
#transTvar {
local
do
  PARFS^tvarS := PARFS^tvar;
end
}



PARFS -> #increC PARF #ajoutType PARFSX #majTvarSynt #transFI ;
-- (Normalement le passage des TDS de PARFS à PARF puis de PARF à PARFSX se fait automatiquement).

-- Incrementation du compteur de parametres, et passage de l'attribut.
#incrC {
local
  c : int;
do
  c := PARFS^cParam + 1;
	PARF^cParam := c;
	PARFSX^cParam := c;
end
}

-- Création de lTypes de PARFS à partir de la liste des types de PARFSX et du type de PARF.
#ajoutType {
local
  fi : functionInfo ; 
do
  fi := PARFS^funInfoH ;
  -- On ajoute le type de PARF à la variable FunctionInfo.
  fi.add(PARF^type);
  PARFSX^funInfoH := fi;
end
}

-- On crée une TDSvar synthétisée à partir de la liste des paramètres qu'on passe à PARFS.
-- Ce sera la TDS du corps de la fonction.
#majTvarSynt {
local
do
  PARFS^tvarS := PARFSX^tvar;
end
}

-- Transmission de FunctionInfo.
#transFI {
local
do
  PARFS^funInfo := PARFSX^funInfo ;
end
}


PARFSX ->  #passageFunInfo ;

-- Passage de FunctionInfo (transformation d'attribut hérité en attribut synthétisé).
#passageFunInfo {
local
do
  PARFSX^funInfo := PARFSX^funInfoH ;
end
}

 
PARFSX -> #incrC virg #passFI PARF #passFI2 PARFSX #transFI ;

-- Incrementation du compteur de parametres, et passage de l'attribut.
#incrC {
local
  c : int;
do
  c := PARFSX^cParam + 1;
	PARF^cParam := c;
	PARFSX1^cParam := c;
end
}


-- Passage de la FunctionInfo de PARFSX à PARF.
#passFI {
local
do
  PARF^funInfoH := PARFSX^funInfoH;
end
}

-- Passage de la FunctionInfo de PARF à PARFSX1.
#passFI2 {
local
do
  PARFSX2^funInfoH := PARF^funInfo;
end
}

-- Transmission de FunctionInfo.
#transFI {
local
do
  PARFSX^funInfo := PARFSX1^funInfo ;
end
}



PARF ->  TYPE #ajouts ident ;

-- Ajout du type du param à FunctionInfo.
-- Ajout de ident à la TDS locale.
-- Vérifications concernant ident.
#ajouts {
local
  fi : FunctionInfo;
	info : SymbolInfo;
do
  -- Ajout du type du param à FunctionInfo.
  fi := PARF^funInfoH;
	fi.add(TYPE^type);

  -- Vérifications concernant ident.
  info := PARF^tvar.lookup(ident^txt, false);
  -- Si identc est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, ident^txt);
  else {
     info := ENTITE^tfun.lookup(ident^txt, false);
     -- De même si identc est déjà utilisé dans la TDSfun.
     if info != null then
        error(IDENT_TAKEN, ident^txt);
     -- Ajout de ident à la TDS locale.
     else {
        PARF^tvar.insert(ident^txt, 
				                 new VariableInfo(TYPE^type, PARF^funInfo.displacement(PARF^cParam)));
     }
  }
	PARF^funInfo := fi;
end
}


----------------------------------------------------------------
-------- LES TYPES (de base, noms, struct et pointeurs) --------
----------------------------------------------------------------
TYPE -> STYPE #passage PTRS #recupType;

-- Passage du type de STYPE à PTRS pour qu'il "pointeurise" la chose.
#passage {
local
do
  PTRS^typeH := STYPE^type;
end
}

-- Recuperation du type final de l'expression.
#recupType {
local
do
  TYPE^type := PTRS^type;
end
}


-- Des * pour definir un pointeur
PTRS -> #passage ;

-- Passage de l'attribut hérité à celui synthétisé. 
#passage {
local
do
  PTRS^type := PTRS^typeH;
end
}


PTRS -> mult #point PTRS #passage ;

-- Passage du type une foix la couche de pointeur ajoutée.
#point {
local
do
  PTRS1^typeH := new PointerType(PTRS^typeH);
end
}

-- Probablement inutile : passage de l'attribut type synthétisé.
#passage {
local
do
  PTRS^type := PTRS1^type;
end
}


-- Types de base
STYPE-> void #typage ;

#typage {
local
do
  STYPE^type := new VoidType();
end
}

STYPE-> int #typage ;

#typage {
local
do
  STYPE^type  := new IntegerType();
end
}


STYPE-> char #typage ;

#typage {
local
do
  STYPE^type  := new CharacterType();
end
}

-- TODO
-- Nom de type (commence par une majuscule)
STYPE -> identc #testtype;

local
#testtype {
  info : SymbolInfo;
  tinfo : TypeInfo
do
  info := STYPE^tvar.lookup(identc^txt, false);
  -- Si identc n'est pas une clef dans la TDSvar, erreur.
  if info = null then
     error(IDENT_UNDEFINED, identc^txt);
  else {
     match info
       with TypeInfo then
         tinfo := info;
         STYPE^type :=  tinfo.type();
       else
          error(NOT_A_TYPE,identc^txt);
       end
  } 
  end
}


-- Struct
STYPE -> struct aco #ch CHAMPS acf  #type ;

global 
  lc : StructFields ;
#ch {
do
  lc := new StructFields();
  CHAMPS^champs := lc;
end
}

#type {
do
  STYPE^type := new StructType(lc);
end
}

CHAMPS -> ;

-- Un nom de champ commence par une minuscule
CHAMPS -> CHAMP #ch CHAMPS ;
#ch {
 local
 do
 -- J'ai changé l'attribut pour récupérer l'identifiant
 -- Il vaut mieux stocker directement la chaine comme attribut de CHAMP.
    if CHAMPS^champs.exist(CHAMP^nom) then
       error(IDENT_TAKEN, CHAMP^nom);
    else 
		-- Pourquoi le call ?
    -- call CHAMPS^champs.insert(CHAMP^nom,CHAMP^type);
      CHAMPS^champs.insert(CHAMP^nom,CHAMP^type);
		end
 end
}


CHAMP -> TYPE #ajout ident pv;

#ajout {
  local
  do
    CHAMP^nom = ident^txt;
    CHAMP^type = TYPE^type;
  end
}


----------------------------------------------------------------
----------- CORPS DE FONCTION ET BLOC D'INSTRUCTIONS -----------
----------------------------------------------------------------
BLOC ->  aco #passage INSTS acf  #flushPassCode ;

-- Probablement inutile, mais passage des TDS de BLOC à INSTS.
-- Ainsi que la FunctionInfo de la fonction.
#passage {
local
do
  INSTS^tvar := BLOC^tvar;
  INSTS^tfun := BLOC^tfun;
	INSTS^funInfoH := BLOC^funInfoH;
end
}

-- Generation du flush de fin de bloc.
-- Passage du code généré par les INSTS (et le flush) à BLOC.
#flushPassCode {
local
  code : String;
do
  code := INSTS^code;
  code := code + BLOC^machine.generateFlush(BLOC^tvar);
  BLOC^code := code;
end
}



-- Instructions
-- Fin des instructions de la fonction.
INSTS -> #initCode ;

-- Initialisation de l'attribut code (chaine vide).
#initCode {
local
do
  INSTS^code := "";
end
}

INSTS -> #funInfo INST #passage INSTS #passCode ;

-- Passage du type retour de la fonction.
#funInfo {
local
do
  INST^funInfoH := INSTS^funInfoH;
	INSTS1^funInfoH := INSTS^funInfoH;
end
}

-- Passage des TDS de INST à INSTS1.
#passage {
local
do
  INSTS1^tvar := INST^tvarS;
  INSTS1^tfun := INST^tfun;  -- La table des fonctions ne changera pas.
end
}

-- Concaténation des codes et passage à INSTS.
#passCode {
local
do
  INSTS^code := INST^code + INSTS1^code;
end
}


-- TODO : gen code.
-- Declaration de variable locale avec ou sans init 
INST ->  TYPE ident #ajoutTDS AFFX pv ;

-- Vérifiation que l'identifiant n'est pas déjà use localement.
-- Ajout à la Tvar.
#ajoutTDS {
local
  info : SymbolInfo;
	tv : VariableTable;
do
  info := INST^tvar.lookup(ident^txt, true);
  -- Si ident est une clef dans la TDSvar, erreur.
  if info != null then
     error(IDENT_TAKEN, ident^txt);
  else {
     info := ENTITE^tfun.lookup(ident^txt, false);
     -- De même si identc est déjà utilisé dans la TDSfun.
     if info != null then
        error(IDENT_TAKEN, ident^txt);
     -- Sinon, on ajoute cet id à la tdsvar.
     else {
		    tv := INST^tvar;
				tv.insert(ident^txt, TYPE^type);
        INST^tvarS := tv;
    }
  } 
end
}

-- TODO : Passage tvar.
-- Instruction expression (affectation et appel de procedure)
INST -> E pv ;



-- Bloc d'instructions
INST ->  #tdsFille #passFI BLOC #passTvar #passCode;

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#tdsFille {
local
  tfille : VariableTable;
do
  tfille := new VariableTable(INST^tvar);
	BLOC^tvar := tfille;
end
}

-- Passage de la FunctionInfo.
#passFI {
local
do
  BLOC^funInfoH := INST^funInfoH;
end
}

-- La tvar de INST n'est pas modifiée par BLOC.
#passTvar {
local
do
  INST^tvarS := INST^tvar;
end
}

-- Passage du code de BLOC à INST.
#passCode {
local
do
  INST^code := BLOC^code;
end
}

-- Conditionnelle
INST -> si paro E parf #passFI #tdsFille BLOC #transTDS SIX #passAttributs #passCode;

-- Passage de FunctionInfo.
#passFI {
local
do
  BLOC^funInfoH := INST^funInfoH;
	SIX^funInfoH := INST^funInfoH;
end
}

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
#tdsFille {
local
  tfille : VariableTable;
do
  tfille := new VariableTable(INST^tvar);
	BLOC^tvar := tfille;
	-- Useless?
	BLOC^tfun := INST^tfun;
end
}

-- Useless?
-- Transmission des TDS 'parentes' à SIX.
#transTDS {
local
do
  SIX^tvar := INST^tvar;
	SIX^tfun := INST^tfun;
end
}

-- Passage de la TDSvar en attribut synthétisé.
#passAttributs {
local
do
  INST^tvarS := INST^tvar;
end
}

-- Concaténation et passage du code.
#passCode {
local
do
  INST^code := BLOC^code + SIX^code;
end
}

SIX -> sinon #passFI #tdsFille BLOC #passCode;

-- Passage de FunctionInfo
#passFI {
local
do
  BLOC^funInfoH := SIX^funInfoH;
end
}

-- Création d'une tvar fille héritant de celle de INST pour BLOC.
-- Passage du type retour de la fonction.
#tdsFille {
local
  tfille : VariableTable;
do
  tfille := new VariableTable(SIX^tvar);
	BLOC^tvar := tfille;
	-- Useless?
	BLOC^tfun := SIX^tfun;
end
}

-- Passage du code du BLOC à SIX.
#passCode{
local
do
  SIX^code := BLOC^code;
end
}



SIX -> #codeVide ;
-- Rien à faire pour la gestion des TDS.
-- Génération d'une chaine de caractère vide.
#codeVide {
local
do
  SIX^code := "";
end
}



-- Retour de fonction
-- TODO : Vérifier que E est du type retour de la fonction (INST^funInfoH.returnType() ).
--        generateFlush PUIS generateReturn.
INST ->  retour E pv #verifTypage #genCode ;

-- Vérification que E est du type retour de la fonction.
#verifTypage {
local
  typeRet : Type;
do
  typeRet := INST^funInfoH.returnType();
	-- TODO : si typeRet ne correspond pas à E^type
	--        alors erreur.
end
}

--Génération du code de retour de la fonction et du flush.
#genCode {
local
  code : String;
do
  code :=   INST^machine.generateFlush(INST^tvar)
	        + INST^machine.generateFunctionReturn(INST^funInfoH, E^reg);
	INST^code := code;
end
}


-----------------------------------------------------------------------
--------------------------- LES EXPRESSIONS ---------------------------
-----------------------------------------------------------------------
-- E = expression (y compris l'affectation)
-- A = expression figurant dans une affectation
-- R = expression figurant dans une expresion relationnelle
-- T = expression figurant dans une expression additive (TERME)
-- F = expression figurant dans une expression multiplicative (FACTEUR)
-----------------------------------------------------------------------
E ->   A  AFFX ;
-- affectation
AFFX -> affect  A  ;
AFFX -> ;
-- relation
A ->   R AX  ;
AX -> OPREL R ;
AX -> ;

-- operateurs relationnels
OPREL -> #opr inf ;

#opr {
local
do
  OPREL^oprel := LT;
end
}

OPREL -> #opr sup ;

#opr {
local
do
  OPREL^oprel := GT;
end
}

OPREL -> #opr infeg ;

#opr {
local
do
  OPREL^oprel := LEQ;
end
}

OPREL -> #opr supeg ;

#opr {
local
do
  OPREL^oprel := GEQ;
end
}

OPREL -> #opr eg ;

#opr {
local
do
  OPREL^oprel := EQ;
end
}

OPREL -> #opr neg ;

#opr {
local
do
  OPREL^oprel := NEQ;
end
}

R ->  T  RX ;
-- additions ...
RX ->   OPADD T RX #actuOp ;

#actuOp {
local
do
  if (RX1^op != NOP) {
	  RX1^machine.generateOperation(RX1^op,T^reg,RX1^reg,RX^reg);
	}
	RX^op = OPADD^op;
end
}

RX -> #nop;

#nop {
local
do
  RX^op := NOP;
end
}

-- operateurs additifs
OPADD -> #op plus ;

#op {
local
do
  OPADD^op := ADD;
end
}

OPADD -> #op moins ;

#op {
local
do
  OPADD^op := SUB;
end
}

OPADD -> #op ou ;

-- TODO : faire chier GUILLAUME DUPONT pour qu'il ajoute OU
#op {
local
do
  OPADD^op := MUL;
end
}

-- multiplication, ...
T ->  F  TX  ;
TX ->   OPMUL  F TX  #actuOp;

#actuOp {
local
do
  if (TX1^op != NOP) {
	  TX1^machine.generateOperation(TX1^op,F^reg,TX1^reg,TX^reg);
	}
	TX^op = OPMUL^op;
end
}

TX ->  #nop ;

#nop {
local
do
  TX^op := NOP;
end
}

-- operateurs multiplicatifs
OPMUL -> #op mult ;
#op {
local
do
  OPMUL^op := MUL;
end
}

OPMUL -> #op div ;

#op {
local
do
  OPMUL^op := DIV;
end
}

OPMUL -> #op mod ;

-- TODO : faire chier GUILLAUME DUPONT pour qu'il ajoute MOD
#op {
local
do
  OPMUL^op := MUL;
end
}

OPMUL -> #op et ;

-- TODO : faire chier GUILLAUME DUPONT pour qu'il ajoute ET
#op {
local
do
  OPMUL^op := MUL;
end
}

-- expressions de base
-- Constante entiere
F -> entier   ;
-- Constante chaine
F -> chaine ;
-- Constante caractere
F -> caractere ;
-- expression unaire
F ->  OPUN  F  #genCode;

-- Génération du code pour la déclaration de la variable.
#genCode {
local
do
	F^code:= F^machine.generateOperation(OPUN^op,F1^reg,F^reg);
end
}

-- operateurs unaires
OPUN -> plus ;

-- TODO : faire chier GUILLAUME DUPONT pour qu'il ajoute PLUS
#op {
local
do
  OPUN^op := MUL;
end
}

OPUN -> moins ;

#op {
local
do
  OPUN^op := NEG;
end
}

OPUN -> non;

-- TODO : faire chier GUILLAUME DUPONT pour qu'il ajoute NON
#op {
local
do
  OPUN^op := MUL;
end
}

-- pointeur NULL
F -> null  ;
-- expression parenthesee
F ->  paro E parf FX ;

F ->  paro TYPE parf #cast  F ;

#cast {
local
do
  if F1^type.isCompatible(TYPE^type) then
	   F^type := TYPE^type;
  else {
	   -- Pas de méthode name() dans Type pour l'instant.
     error(TYPE_NOT_COMPATIBLE, F1^type.name(), TYPE^type.name());	   
  } 
end
}

F -> mult F ;

F -> #rechercheId ident FX ;

-- Recherche de l'identifiant dans la tds.
#rechercheId {
local
  info : VariableInfo;
do
  info := F^tvar.lookup(ident^txt);
	if (info = null) then
	  error(IDENT_UNDEFINED, ident^txt);
	else {
    -- TODO : transmission du type.
		--        des trucs avec FX ?
	}
end
}


FX -> ;
-- acces champ
FX ->   pt  ident FX ;
-- acces champ pointeur
FX ->   arrow  ident FX ;
-- appel de sous-programme
FX ->   paro ES parf FX;
-- arguments appel de sous-programme
ES -> ;
ES -> E ESX  ;
ESX ->  ;
ESX -> virg E ESX ;


-----------------------------------------
------------- INLINE ASM ----------------
-----------------------------------------
ENTITE -> asm #tds ASM #gen; 
#tds {
do 
  -- A faire : Remplacer 'null' par la table courante pour que
  -- le code  ASM puisse acceder aux variables de MC ou MCS
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- On recupere le code assembleur 'inline' dans : ASM^code_asm ;
end
}

INST ->  asm   #tds ASM #gen ;
#tds {
do
  -- A remplacer par la table courante pour que
  -- l'assembleur puisse acceder aux variables
  ASM^tds_asm := null; 
end
}

#gen {
do
  -- ASM^code_asm contient le code assembleur inline
  -- dans lequel les noms de variables ont ete remplaces
  -- par leurs adresses.
end
}

----------------- CS extension --------------------
-- Decommenter les regles suivantes pour l'extension CS
-------------------------------------------------
--TYPE -> bool;
---- definit un contenu d'un namespace
--ENTITE -> namespace identc aco ENTITES acf ;
---- donne l acces au contenu du 'namespace'
--ENTITE -> using identc IDC pv ;
--IDC -> ;
--IDC -> pt identc IDC ;
---- definition d'une classe (peut etre en dehors d'un namespace)
--ENTITE -> ACCES class identc HERITAGE aco DEFS acf ;
---- acces 
--ACCES -> public;
--ACCES -> private;
--ACCES -> ;
---- heritage
--HERITAGE -> ;
--HERITAGE -> dpts identc IDC ;
---- membres d'une classe
--DEFS -> ;
--DEFS ->  ACCES DEF DEFS ;
--DEF  ->  TYPE ident DECL ;
---- constructeur
--DEF  ->  identc paro PARFS parf BASE BLOC;
---- appel eventuel au constructeur de la classe parente.
--BASE -> ;
--BASE -> dpts base paro ES parf  ;
---- Mode de passage pour les fonctions et méthodes : rien : D, ref : D/R, out : R
--PARF ->  MODE TYPE ident ;
--MODE -> ref ;
--MODE -> out ; 
--F -> true;
--F -> false;
--F -> this FX;
--F -> base FX;
--F -> null2;
--F -> new identc IDC paro ES parf ;
end
